// Code generated by 'ccgo -pkgname ch3 -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T -Isrc/h3lib/include -I../src/h3lib/include ../src/h3lib/lib/algos.c ../src/h3lib/lib/baseCells.c ../src/h3lib/lib/bbox.c ../src/h3lib/lib/coordijk.c ../src/h3lib/lib/directedEdge.c ../src/h3lib/lib/faceijk.c ../src/h3lib/lib/h3Assert.c ../src/h3lib/lib/h3Index.c ../src/h3lib/lib/iterators.c ../src/h3lib/lib/latLng.c ../src/h3lib/lib/linkedGeo.c ../src/h3lib/lib/localij.c ../src/h3lib/lib/mathExtensions.c ../src/h3lib/lib/polygon.c ../src/h3lib/lib/vec2d.c ../src/h3lib/lib/vec3d.c ../src/h3lib/lib/vertex.c ../src/h3lib/lib/vertexGraph.c', DO NOT EDIT.

package ch3

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DALGOS_H                      = 0                                               // algos.h:21:1:
	DALLOC_H                      = 0                                               // alloc.h:25:1:
	DBASECELLS_H                  = 0                                               // baseCells.h:21:1:
	DBBOX_H                       = 0                                               // bbox.h:21:1:
	DBIG_ENDIAN                   = 4321                                            // endian.h:28:1:
	DBUFSIZ                       = 8192                                            // stdio.h:99:1:
	DBYTE_ORDER                   = 1234                                            // endian.h:30:1:
	DCONSTANTS_H                  = 0                                               // constants.h:21:1:
	DCOORDIJK_H                   = 0                                               // coordijk.h:31:1:
	DDBL_DECIMAL_DIG              = 17                                              // float.h:220:1:
	DDBL_DIG                      = 15                                              // float.h:54:1:
	DDBL_HAS_SUBNORM              = 1                                               // float.h:228:1:
	DDBL_MANT_DIG                 = 53                                              // float.h:40:1:
	DDBL_MAX_10_EXP               = 308                                             // float.h:94:1:
	DDBL_MAX_EXP                  = 1024                                            // float.h:82:1:
	DDBL_MIN_10_EXP               = -307                                            // float.h:74:1:
	DDBL_MIN_EXP                  = -1021                                           // float.h:62:1:
	DDECIMAL_DIG                  = 21                                              // float.h:209:1:
	DDECLSPEC                     = 0                                               // h3api.h:49:1:
	DEARTH_RADIUS_KM              = 6371.007180918475                               // constants.h:59:1:
	DEOF                          = -1                                              // stdio.h:104:1:
	DEPSILON                      = 0.0000000000000001                              // constants.h:42:1:
	DEPSILON_DEG                  = .000000001                                      // latLng.h:31:1:
	DEPSILON_RAD                  = 0                                               // latLng.h:33:1:
	DEXIT_FAILURE                 = 1                                               // stdlib.h:92:1:
	DEXIT_SUCCESS                 = 0                                               // stdlib.h:93:1:
	DFACEIJK_H                    = 0                                               // faceijk.h:25:1:
	DFD_SETSIZE                   = 1024                                            // select.h:73:1:
	DFILENAME_MAX                 = 4096                                            // stdio_lim.h:27:1:
	DFLT_DECIMAL_DIG              = 9                                               // float.h:219:1:
	DFLT_DIG                      = 6                                               // float.h:53:1:
	DFLT_EPSILON                  = 0                                               // float.h:113:1:
	DFLT_EVAL_METHOD              = 0                                               // float.h:197:1:
	DFLT_HAS_SUBNORM              = 1                                               // float.h:227:1:
	DFLT_MANT_DIG                 = 24                                              // float.h:39:1:
	DFLT_MAX                      = 0                                               // float.h:104:1:
	DFLT_MAX_10_EXP               = 38                                              // float.h:93:1:
	DFLT_MAX_EXP                  = 128                                             // float.h:81:1:
	DFLT_MIN                      = 0                                               // float.h:121:1:
	DFLT_MIN_10_EXP               = -37                                             // float.h:73:1:
	DFLT_MIN_EXP                  = -125                                            // float.h:61:1:
	DFLT_RADIX                    = 2                                               // float.h:33:1:
	DFLT_ROUNDS                   = 1                                               // float.h:128:1:
	DFLT_TRUE_MIN                 = 0                                               // float.h:235:1:
	DFOPEN_MAX                    = 16                                              // stdio_lim.h:37:1:
	DFP_ILOGB0                    = -2147483648                                     // math.h:207:1:
	DFP_ILOGBNAN                  = -2147483648                                     // math.h:212:1:
	DFP_INFINITE                  = 1                                               // math.h:940:1:
	DFP_NAN                       = 0                                               // math.h:937:1:
	DFP_NORMAL                    = 4                                               // math.h:949:1:
	DFP_SUBNORMAL                 = 3                                               // math.h:946:1:
	DFP_ZERO                      = 2                                               // math.h:943:1:
	DGEOPOINT_H                   = 0                                               // latLng.h:21:1:
	DH3API_H                      = 0                                               // h3api.h:24:1:
	DH3ASSERT_H                   = 0                                               // h3Assert.h:42:1:
	DH3INDEX_H                    = 0                                               // h3Index.h:21:1:
	DH3_BC_OFFSET                 = 45                                              // h3Index.h:38:1:
	DH3_CELL_MODE                 = 1                                               // constants.h:81:1:
	DH3_DIRECTEDEDGE_MODE         = 2                                               // constants.h:82:1:
	DH3_EDGE_MODE                 = 3                                               // constants.h:83:1:
	DH3_INIT                      = 35184372088831                                  // h3Index.h:90:1:
	DH3_MAX_OFFSET                = 63                                              // h3Index.h:32:1:
	DH3_MODE_OFFSET               = 59                                              // h3Index.h:35:1:
	DH3_NULL                      = 0                                               // h3api.h:76:1:
	DH3_NUM_BITS                  = 64                                              // h3Index.h:29:1:
	DH3_PER_DIGIT_OFFSET          = 3                                               // h3Index.h:47:1:
	DH3_RESERVED_OFFSET           = 56                                              // h3Index.h:44:1:
	DH3_RES_MASK                  = 67553994410557440                               // h3Index.h:68:1:
	DH3_RES_MASK_NEGATIVE         = 18379190079298994175                            // h3Index.h:71:1:
	DH3_RES_OFFSET                = 52                                              // h3Index.h:41:1:
	DH3_VERSION_MAJOR             = 4                                               // h3api.h:109:1:
	DH3_VERSION_MINOR             = 1                                               // h3api.h:110:1:
	DH3_VERSION_PATCH             = 0                                               // h3api.h:111:1:
	DH3_VERTEX_MODE               = 4                                               // constants.h:84:1:
	DIJ                           = 1                                               // faceijk.h:54:1:
	DINT16_MAX                    = 32767                                           // stdint.h:122:1:
	DINT16_MIN                    = -32768                                          // stdint.h:117:1:
	DINT32_MAX                    = 2147483647                                      // stdint.h:123:1:
	DINT32_MIN                    = -2147483648                                     // stdint.h:118:1:
	DINT64_MAX                    = 9223372036854775807                             // stdint.h:124:1:
	DINT64_MIN                    = -9223372036854775808                            // stdint.h:119:1:
	DINT8_MAX                     = 127                                             // stdint.h:121:1:
	DINT8_MIN                     = -128                                            // stdint.h:116:1:
	DINTMAX_MAX                   = 9223372036854775807                             // stdint.h:199:1:
	DINTMAX_MIN                   = -9223372036854775808                            // stdint.h:197:1:
	DINTPTR_MAX                   = 9223372036854775807                             // stdint.h:187:1:
	DINTPTR_MIN                   = -9223372036854775808                            // stdint.h:186:1:
	DINT_FAST16_MAX               = 9223372036854775807                             // stdint.h:164:1:
	DINT_FAST16_MIN               = -9223372036854775808                            // stdint.h:154:1:
	DINT_FAST32_MAX               = 9223372036854775807                             // stdint.h:165:1:
	DINT_FAST32_MIN               = -9223372036854775808                            // stdint.h:155:1:
	DINT_FAST64_MAX               = 9223372036854775807                             // stdint.h:170:1:
	DINT_FAST64_MIN               = -9223372036854775808                            // stdint.h:160:1:
	DINT_FAST8_MAX                = 127                                             // stdint.h:162:1:
	DINT_FAST8_MIN                = -128                                            // stdint.h:152:1:
	DINT_LEAST16_MAX              = 32767                                           // stdint.h:140:1:
	DINT_LEAST16_MIN              = -32768                                          // stdint.h:135:1:
	DINT_LEAST32_MAX              = 2147483647                                      // stdint.h:141:1:
	DINT_LEAST32_MIN              = -2147483648                                     // stdint.h:136:1:
	DINT_LEAST64_MAX              = 9223372036854775807                             // stdint.h:142:1:
	DINT_LEAST64_MIN              = -9223372036854775808                            // stdint.h:137:1:
	DINT_LEAST8_MAX               = 127                                             // stdint.h:139:1:
	DINT_LEAST8_MIN               = -128                                            // stdint.h:134:1:
	DINVALID_BASE_CELL            = 127                                             // baseCells.h:38:1:
	DINVALID_FACE                 = -1                                              // faceijk.h:61:1:
	DINVALID_ROTATIONS            = -1                                              // baseCells.h:49:1:
	DJK                           = 3                                               // faceijk.h:58:1:
	DKI                           = 2                                               // faceijk.h:56:1:
	DLDBL_DECIMAL_DIG             = 21                                              // float.h:221:1:
	DLDBL_DIG                     = 18                                              // float.h:55:1:
	DLDBL_EPSILON                 = 0                                               // float.h:115:1:
	DLDBL_HAS_SUBNORM             = 1                                               // float.h:229:1:
	DLDBL_MANT_DIG                = 64                                              // float.h:41:1:
	DLDBL_MAX                     = 0                                               // float.h:106:1:
	DLDBL_MAX_10_EXP              = 4932                                            // float.h:95:1:
	DLDBL_MAX_EXP                 = 16384                                           // float.h:83:1:
	DLDBL_MIN                     = 0                                               // float.h:123:1:
	DLDBL_MIN_10_EXP              = -4931                                           // float.h:75:1:
	DLDBL_MIN_EXP                 = -16381                                          // float.h:63:1:
	DLDBL_TRUE_MIN                = 0                                               // float.h:237:1:
	DLINKED_GEO_H                 = 0                                               // linkedGeo.h:21:1:
	DLITTLE_ENDIAN                = 1234                                            // endian.h:27:1:
	DL_ctermid                    = 9                                               // stdio_lim.h:30:1:
	DL_tmpnam                     = 20                                              // stdio_lim.h:25:1:
	DMATH_ERREXCEPT               = 2                                               // math.h:1036:1:
	DMATH_ERRNO                   = 1                                               // math.h:1035:1:
	DMAX_CELL_BNDRY_VERTS         = 10                                              // h3api.h:117:1:
	DMAX_FACE_COORD               = 2                                               // baseCells.h:46:1:
	DMAX_H3_RES                   = 15                                              // constants.h:67:1:
	DMAX_ONE_RING_SIZE            = 7                                               // algos.c:45:1:
	DM_180_PI                     = 57.29577951308232087679815481410517033240547    // constants.h:39:1:
	DM_1_PI                       = 0.31830988618379067154                          // math.h:1154:1:
	DM_2PI                        = 6.28318530717958647692528676655900576839433     // constants.h:34:1:
	DM_2_PI                       = 0.63661977236758134308                          // math.h:1155:1:
	DM_2_SQRTPI                   = 1.12837916709551257390                          // math.h:1156:1:
	DM_AP7_ROT_RADS               = 0.333473172251832115336090755351601070065900389 // constants.h:50:1:
	DM_COS_AP7_ROT                = 0.9449111825230680680167902                     // constants.h:56:1:
	DM_E                          = 2.7182818284590452354                           // math.h:1146:1:
	DM_LN10                       = 2.30258509299404568402                          // math.h:1150:1:
	DM_LN2                        = 0.69314718055994530942                          // math.h:1149:1:
	DM_LOG10E                     = 0.43429448190325182765                          // math.h:1148:1:
	DM_LOG2E                      = 1.4426950408889634074                           // math.h:1147:1:
	DM_PI                         = 3.14159265358979323846                          // math.h:1151:1:
	DM_PI_180                     = 0.0174532925199432957692369076848861271111      // constants.h:37:1:
	DM_PI_2                       = 1.57079632679489661923                          // math.h:1152:1:
	DM_PI_4                       = 0.78539816339744830962                          // math.h:1153:1:
	DM_SIN60                      = 0                                               // constants.h:46:1:
	DM_SIN_AP7_ROT                = 0.3273268353539885718950318                     // constants.h:53:1:
	DM_SQRT1_2                    = 0.70710678118654752440                          // math.h:1158:1:
	DM_SQRT2                      = 1.41421356237309504880                          // math.h:1157:1:
	DM_SQRT3_2                    = 0.8660254037844386467637231707529361834714      // constants.h:44:1:
	DNUM_BASE_CELLS               = 122                                             // constants.h:72:1:
	DNUM_HEX_VERTS                = 6                                               // constants.h:74:1:
	DNUM_ICOSA_FACES              = 20                                              // constants.h:70:1:
	DNUM_PENTAGONS                = 12                                              // constants.h:78:1:
	DNUM_PENT_VERTS               = 5                                               // constants.h:76:1:
	DPDP_ENDIAN                   = 3412                                            // endian.h:29:1:
	DPOLYGON_H                    = 0                                               // polygon.h:21:1:
	DPOLYGON_TO_CELLS_BUFFER      = 12                                              // algos.c:46:1:
	DPTRDIFF_MAX                  = 9223372036854775807                             // stdint.h:210:1:
	DPTRDIFF_MIN                  = -9223372036854775808                            // stdint.h:209:1:
	DP_tmpdir                     = "/tmp"                                          // stdio.h:120:1:
	DRAND_MAX                     = 2147483647                                      // stdlib.h:87:1:
	DRES0_U_GNOMONIC              = 0.38196601125010500003                          // constants.h:64:1:
	DSEEK_CUR                     = 1                                               // stdio.h:110:1:
	DSEEK_END                     = 2                                               // stdio.h:111:1:
	DSEEK_SET                     = 0                                               // stdio.h:109:1:
	DSIG_ATOMIC_MAX               = 2147483647                                      // stdint.h:223:1:
	DSIG_ATOMIC_MIN               = -2147483648                                     // stdint.h:222:1:
	DSIZE_MAX                     = 18446744073709551615                            // stdint.h:227:1:
	DTMP_MAX                      = 238328                                          // stdio_lim.h:26:1:
	DUINT16_MAX                   = 65535                                           // stdint.h:128:1:
	DUINT32_MAX                   = 4294967295                                      // stdint.h:129:1:
	DUINT64_MAX                   = 18446744073709551615                            // stdint.h:130:1:
	DUINT8_MAX                    = 255                                             // stdint.h:127:1:
	DUINTMAX_MAX                  = 18446744073709551615                            // stdint.h:202:1:
	DUINTPTR_MAX                  = 18446744073709551615                            // stdint.h:188:1:
	DUINT_FAST16_MAX              = 18446744073709551615                            // stdint.h:175:1:
	DUINT_FAST32_MAX              = 18446744073709551615                            // stdint.h:176:1:
	DUINT_FAST64_MAX              = 18446744073709551615                            // stdint.h:181:1:
	DUINT_FAST8_MAX               = 255                                             // stdint.h:173:1:
	DUINT_LEAST16_MAX             = 65535                                           // stdint.h:146:1:
	DUINT_LEAST32_MAX             = 4294967295                                      // stdint.h:147:1:
	DUINT_LEAST64_MAX             = 18446744073709551615                            // stdint.h:148:1:
	DUINT_LEAST8_MAX              = 255                                             // stdint.h:145:1:
	DVEC2D_H                      = 0                                               // vec2d.h:21:1:
	DVERTEX_GRAPH_H               = 0                                               // vertexGraph.h:21:1:
	DWCHAR_MAX                    = 2147483647                                      // stdint.h:240:1:
	DWCHAR_MIN                    = -2147483648                                     // stdint.h:239:1:
	DWCONTINUED                   = 8                                               // waitflags.h:32:1:
	DWEXITED                      = 4                                               // waitflags.h:31:1:
	DWINT_MAX                     = 4294967295                                      // stdint.h:245:1:
	DWINT_MIN                     = 0                                               // stdint.h:244:1:
	DWNOHANG                      = 1                                               // waitflags.h:25:1:
	DWNOWAIT                      = 0x01000000                                      // waitflags.h:33:1:
	DWSTOPPED                     = 2                                               // waitflags.h:30:1:
	DWUNTRACED                    = 2                                               // waitflags.h:26:1:
	D_ALLOCA_H                    = 1                                               // alloca.h:19:1:
	D_ASSERT_H                    = 1                                               // assert.h:34:1:
	D_ATFILE_SOURCE               = 1                                               // features.h:352:1:
	D_BITS_ATOMIC_WIDE_COUNTER_H  = 0                                               // atomic_wide_counter.h:20:1:
	D_BITS_BYTESWAP_H             = 1                                               // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H           = 1                                               // endianness.h:2:1:
	D_BITS_ENDIAN_H               = 1                                               // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H        = 0                                               // floatn-common.h:21:1:
	D_BITS_FLOATN_H               = 0                                               // floatn.h:20:1:
	D_BITS_LIBM_SIMD_DECL_STUBS_H = 1                                               // libm-simd-decl-stubs.h:34:1:
	D_BITS_PTHREADTYPES_ARCH_H    = 1                                               // pthreadtypes-arch.h:19:1:
	D_BITS_PTHREADTYPES_COMMON_H  = 1                                               // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H          = 1                                               // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H         = 1                                               // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H            = 1                                               // stdio_lim.h:19:1:
	D_BITS_TIME64_H               = 1                                               // time64.h:24:1:
	D_BITS_TYPESIZES_H            = 1                                               // typesizes.h:24:1:
	D_BITS_TYPES_H                = 1                                               // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H       = 1                                               // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H     = 1                                               // __locale_t.h:20:1:
	D_BITS_UINTN_IDENTITY_H       = 1                                               // uintn-identity.h:24:1:
	D_BITS_WCHAR_H                = 1                                               // wchar.h:20:1:
	D_BSD_SIZE_T_                 = 0                                               // stddef.h:193:1:
	D_BSD_SIZE_T_DEFINED_         = 0                                               // stddef.h:196:1:
	D_DEFAULT_SOURCE              = 1                                               // features.h:237:1:
	D_ENDIAN_H                    = 1                                               // endian.h:19:1:
	D_FEATURES_H                  = 1                                               // features.h:19:1:
	D_FILE_OFFSET_BITS            = 64                                              // <builtin>:25:1:
	D_FLOAT_H___                  = 0                                               // float.h:29:1:
	D_GCC_SIZE_T                  = 0                                               // stddef.h:200:1:
	D_GCC_WCHAR_T                 = 0                                               // stddef.h:280:1:
	D_GCC_WRAP_STDINT_H           = 0                                               // stdint.h:13:1:
	D_IOFBF                       = 0                                               // stdio.h:93:1:
	D_IOLBF                       = 1                                               // stdio.h:94:1:
	D_IONBF                       = 2                                               // stdio.h:95:1:
	D_IO_EOF_SEEN                 = 0x0010                                          // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                 = 0x0020                                          // struct_FILE.h:114:1:
	D_IO_USER_LOCK                = 0x8000                                          // struct_FILE.h:117:1:
	D_LP64                        = 1                                               // <predefined>:313:1:
	D_MATH_H                      = 1                                               // math.h:24:1:
	D_POSIX_C_SOURCE              = 200809                                          // features.h:291:1:
	D_POSIX_SOURCE                = 1                                               // features.h:289:1:
	D_RWLOCK_INTERNAL_H           = 0                                               // struct_rwlock.h:21:1:
	D_SIZET_                      = 0                                               // stddef.h:201:1:
	D_SIZE_T                      = 0                                               // stddef.h:187:1:
	D_SIZE_T_                     = 0                                               // stddef.h:192:1:
	D_SIZE_T_DECLARED             = 0                                               // stddef.h:197:1:
	D_SIZE_T_DEFINED              = 0                                               // stddef.h:195:1:
	D_SIZE_T_DEFINED_             = 0                                               // stddef.h:194:1:
	D_STDBOOL_H                   = 0                                               // stdbool.h:29:1:
	D_STDC_PREDEF_H               = 1                                               // <predefined>:175:1:
	D_STDINT_H                    = 1                                               // stdint.h:23:1:
	D_STDIO_H                     = 1                                               // stdio.h:24:1:
	D_STDLIB_H                    = 1                                               // stdlib.h:36:1:
	D_STRINGS_H                   = 1                                               // strings.h:19:1:
	D_STRING_H                    = 1                                               // string.h:23:1:
	D_STRUCT_TIMESPEC             = 1                                               // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                 = 1                                               // cdefs.h:20:1:
	D_SYS_SELECT_H                = 1                                               // select.h:22:1:
	D_SYS_SIZE_T_H                = 0                                               // stddef.h:188:1:
	D_SYS_TYPES_H                 = 1                                               // types.h:23:1:
	D_THREAD_MUTEX_INTERNAL_H     = 1                                               // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H       = 1                                               // thread-shared-types.h:20:1:
	D_T_SIZE                      = 0                                               // stddef.h:190:1:
	D_T_SIZE_                     = 0                                               // stddef.h:189:1:
	D_T_WCHAR                     = 0                                               // stddef.h:271:1:
	D_T_WCHAR_                    = 0                                               // stddef.h:270:1:
	D_VA_LIST_DEFINED             = 0                                               // stdio.h:53:1:
	D_WCHAR_T                     = 0                                               // stddef.h:269:1:
	D_WCHAR_T_                    = 0                                               // stddef.h:273:1:
	D_WCHAR_T_DECLARED            = 0                                               // stddef.h:281:1:
	D_WCHAR_T_DEFINED             = 0                                               // stddef.h:276:1:
	D_WCHAR_T_DEFINED_            = 0                                               // stddef.h:275:1:
	D_WCHAR_T_H                   = 0                                               // stddef.h:277:1:
	Dfalse                        = 0                                               // stdbool.h:39:1:
	Dlinux                        = 1                                               // <predefined>:256:1:
	Dmath_errhandling             = 3                                               // math.h:1048:1:
	Dtrue                         = 1                                               // stdbool.h:38:1:
	Dunix                         = 1                                               // <predefined>:192:1:
	DINT32_MAX_3                  = 715827882                                       // coordijk.c:33:1:
	DMATHEXTENSIONS_H             = 0                                               // mathExtensions.h:21:1:
	DH3VERTEX_H                   = 0                                               // vertex.h:21:1:
	DINVALID_VERTEX_NUM           = -1                                              // vertex.h:36:1:
	DMAX_BASE_CELL_FACES          = 5                                               // vertex.h:39:1:
	DPRIX16                       = "X"                                             // inttypes.h:135:1:
	DPRIX32                       = "X"                                             // inttypes.h:136:1:
	DPRIX8                        = "X"                                             // inttypes.h:134:1:
	DPRIXFAST8                    = "X"                                             // inttypes.h:144:1:
	DPRIXLEAST16                  = "X"                                             // inttypes.h:140:1:
	DPRIXLEAST32                  = "X"                                             // inttypes.h:141:1:
	DPRIXLEAST8                   = "X"                                             // inttypes.h:139:1:
	DPRId16                       = "d"                                             // inttypes.h:55:1:
	DPRId32                       = "d"                                             // inttypes.h:56:1:
	DPRId8                        = "d"                                             // inttypes.h:54:1:
	DPRIdFAST8                    = "d"                                             // inttypes.h:64:1:
	DPRIdLEAST16                  = "d"                                             // inttypes.h:60:1:
	DPRIdLEAST32                  = "d"                                             // inttypes.h:61:1:
	DPRIdLEAST8                   = "d"                                             // inttypes.h:59:1:
	DPRIi16                       = "i"                                             // inttypes.h:71:1:
	DPRIi32                       = "i"                                             // inttypes.h:72:1:
	DPRIi8                        = "i"                                             // inttypes.h:70:1:
	DPRIiFAST8                    = "i"                                             // inttypes.h:80:1:
	DPRIiLEAST16                  = "i"                                             // inttypes.h:76:1:
	DPRIiLEAST32                  = "i"                                             // inttypes.h:77:1:
	DPRIiLEAST8                   = "i"                                             // inttypes.h:75:1:
	DPRIo16                       = "o"                                             // inttypes.h:87:1:
	DPRIo32                       = "o"                                             // inttypes.h:88:1:
	DPRIo8                        = "o"                                             // inttypes.h:86:1:
	DPRIoFAST8                    = "o"                                             // inttypes.h:96:1:
	DPRIoLEAST16                  = "o"                                             // inttypes.h:92:1:
	DPRIoLEAST32                  = "o"                                             // inttypes.h:93:1:
	DPRIoLEAST8                   = "o"                                             // inttypes.h:91:1:
	DPRIu16                       = "u"                                             // inttypes.h:103:1:
	DPRIu32                       = "u"                                             // inttypes.h:104:1:
	DPRIu8                        = "u"                                             // inttypes.h:102:1:
	DPRIuFAST8                    = "u"                                             // inttypes.h:112:1:
	DPRIuLEAST16                  = "u"                                             // inttypes.h:108:1:
	DPRIuLEAST32                  = "u"                                             // inttypes.h:109:1:
	DPRIuLEAST8                   = "u"                                             // inttypes.h:107:1:
	DPRIx16                       = "x"                                             // inttypes.h:119:1:
	DPRIx32                       = "x"                                             // inttypes.h:120:1:
	DPRIx8                        = "x"                                             // inttypes.h:118:1:
	DPRIxFAST8                    = "x"                                             // inttypes.h:128:1:
	DPRIxLEAST16                  = "x"                                             // inttypes.h:124:1:
	DPRIxLEAST32                  = "x"                                             // inttypes.h:125:1:
	DPRIxLEAST8                   = "x"                                             // inttypes.h:123:1:
	DSCNd16                       = "hd"                                            // inttypes.h:172:1:
	DSCNd32                       = "d"                                             // inttypes.h:173:1:
	DSCNd8                        = "hhd"                                           // inttypes.h:171:1:
	DSCNdFAST8                    = "hhd"                                           // inttypes.h:181:1:
	DSCNdLEAST16                  = "hd"                                            // inttypes.h:177:1:
	DSCNdLEAST32                  = "d"                                             // inttypes.h:178:1:
	DSCNdLEAST8                   = "hhd"                                           // inttypes.h:176:1:
	DSCNi16                       = "hi"                                            // inttypes.h:188:1:
	DSCNi32                       = "i"                                             // inttypes.h:189:1:
	DSCNi8                        = "hhi"                                           // inttypes.h:187:1:
	DSCNiFAST8                    = "hhi"                                           // inttypes.h:197:1:
	DSCNiLEAST16                  = "hi"                                            // inttypes.h:193:1:
	DSCNiLEAST32                  = "i"                                             // inttypes.h:194:1:
	DSCNiLEAST8                   = "hhi"                                           // inttypes.h:192:1:
	DSCNo16                       = "ho"                                            // inttypes.h:220:1:
	DSCNo32                       = "o"                                             // inttypes.h:221:1:
	DSCNo8                        = "hho"                                           // inttypes.h:219:1:
	DSCNoFAST8                    = "hho"                                           // inttypes.h:229:1:
	DSCNoLEAST16                  = "ho"                                            // inttypes.h:225:1:
	DSCNoLEAST32                  = "o"                                             // inttypes.h:226:1:
	DSCNoLEAST8                   = "hho"                                           // inttypes.h:224:1:
	DSCNu16                       = "hu"                                            // inttypes.h:204:1:
	DSCNu32                       = "u"                                             // inttypes.h:205:1:
	DSCNu8                        = "hhu"                                           // inttypes.h:203:1:
	DSCNuFAST8                    = "hhu"                                           // inttypes.h:213:1:
	DSCNuLEAST16                  = "hu"                                            // inttypes.h:209:1:
	DSCNuLEAST32                  = "u"                                             // inttypes.h:210:1:
	DSCNuLEAST8                   = "hhu"                                           // inttypes.h:208:1:
	DSCNx16                       = "hx"                                            // inttypes.h:236:1:
	DSCNx32                       = "x"                                             // inttypes.h:237:1:
	DSCNx8                        = "hhx"                                           // inttypes.h:235:1:
	DSCNxFAST8                    = "hhx"                                           // inttypes.h:245:1:
	DSCNxLEAST16                  = "hx"                                            // inttypes.h:241:1:
	DSCNxLEAST32                  = "x"                                             // inttypes.h:242:1:
	DSCNxLEAST8                   = "hhx"                                           // inttypes.h:240:1:
	D_INTTYPES_H                  = 1                                               // inttypes.h:23:1:
	DM_SQRT7                      = 2.6457513110645905905016157536392604257102      // faceijk.c:36:1:
	DVEC3D_H                      = 0                                               // vec3d.h:21:1:
	DITERATORS_H                  = 0                                               // iterators.h:23:1:
	DDIRECTION_INDEX_OFFSET       = 2                                               // vertex.c:32:1:
)

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
const ( /* coordijk.h:63:1: */
	//* H3 digit in center
	CENTER_DIGIT = 0
	//* H3 digit in k-axes direction
	K_AXES_DIGIT = 1
	//* H3 digit in j-axes direction
	J_AXES_DIGIT = 2
	//* H3 digit in j == k direction
	JK_AXES_DIGIT = 3 // 3
	//* H3 digit in i-axes direction
	I_AXES_DIGIT = 4
	//* H3 digit in i == k direction
	IK_AXES_DIGIT = 5 // 5
	//* H3 digit in i == j direction
	IJ_AXES_DIGIT = 6 // 6
	//* H3 digit in the invalid direction
	INVALID_DIGIT = 7
	// * Valid digits will be less than this value. Same value as INVALID_DIGIT.
	NUM_DIGITS = 7
	//* Child digit which is skipped for pentagons
	PENTAGON_SKIPPED_DIGIT = 1
)

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

// * Digit representing overage type
const ( /* faceijk.h:64:1: */
	//* No overage (on original face)
	NO_OVERAGE = 0
	//* On face edge (only occurs on substrate grids)
	FACE_EDGE = 1
	//* Overage on new face interior
	NEW_FACE = 2
)

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:934:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

const ( /* h3api.h:81:1: */
	E_SUCCESS = 0 // Success (no error)
	E_FAILED  = 1 // The operation failed but a more specific error is not available
	E_DOMAIN  = 2 // Argument was outside of acceptable range (when a more
	// specific error code is not available)
	E_LATLNG_DOMAIN      = 3 // Latitude or longitude arguments were outside of acceptable range
	E_RES_DOMAIN         = 4 // Resolution argument was outside of acceptable range
	E_CELL_INVALID       = 5 // `H3Index` cell argument was not valid
	E_DIR_EDGE_INVALID   = 6 // `H3Index` directed edge argument was not valid
	E_UNDIR_EDGE_INVALID = 7 // `H3Index` undirected edge argument was not valid
	E_VERTEX_INVALID     = 8 // `H3Index` vertex argument was not valid
	E_PENTAGON           = 9 // Pentagon distortion was encountered which the algorithm
	// could not handle it
	E_DUPLICATE_INPUT = 10 // Duplicate input was encountered in the arguments
	// and the algorithm could not handle it
	E_NOT_NEIGHBORS  = 11 // `H3Index` cell arguments were not neighbors
	E_RES_MISMATCH   = 12 // `H3Index` cell arguments had incompatible resolutions
	E_MEMORY_ALLOC   = 13 // Necessary memory allocation failed
	E_MEMORY_BOUNDS  = 14 // Bounds of provided memory were not large enough
	E_OPTION_INVALID = 15
)

type Tptrdiff_t = int64 /* <builtin>:3:26 */

type Tsize_t = uint64 /* <builtin>:9:23 */

type Twchar_t = int32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.c
// @brief   Hexagon grid algorithms

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.h
// @brief   Hexagon grid algorithms

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Signal that all the definitions are present.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//    __STDC_WANT_IEC_60559_EXT__
// 			ISO C2X interfaces defined only in Annex F.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1, 2 or 3; 3 performs stricter checks than 2, which
// 			performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// Features part to handle 64-bit time_t support.
//    Copyright (C) 2021-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We need to know the word size in order to check the time size.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    supported anymore.

// Some user header file might have defined this before.

// Compilers that lack __has_attribute may object to
//        #if defined __has_attribute && __has_attribute (...)
//    even though they do not need to evaluate the right-hand side of the &&.
//    Similarly for __has_builtin, etc.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this only works with
//    gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.

// Compile time conditions to choose between the regular, _chk and _chk_warn
//    variants.  These conditions should get evaluated to constant and optimized
//    away.

// Length is known to be safe at compile time if the __L * __S <= __OBJSZ
//    condition can be folded to a constant and if it is true, or unknown (-1)

// Conversely, we know at compile time that the length is unsafe if the
//    __L * __S <= __OBJSZ condition can be folded to a constant and if it is
//    false.

// Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
//    declared.

// Fortify function f, where object size argument passed to f is the number of
//    elements and not total size.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC and clang have various useful declarations that can be made with
//    the '__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// Tell the compiler which argument to an allocation function
//    indicates the alignment of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonnull function attribute marks pointer parameters that
//    must not be NULL.  This has the name __nonnull in glibc,
//    and __attribute_nonnull__ in files shared with Gnulib to avoid
//    collision with a different __nonnull in DragonFlyBSD 5.9.

// The returns_nonnull function attribute marks the return type of the function
//    as always being non-null.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above, and in clang.
//    It works also in C++ mode (outside of arrays), but only when spelled
//    as '__restrict', not 'restrict'.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 and clang support this.
//    This syntax is not usable in C++ mode.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Gnulib avoids including these, as they don't work on non-glibc or
//    older glibc platforms.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// Designates a 1-based positional argument ref-index of pointer type
//    that can be used to access size-index elements of the pointed-to
//    array according to access mode, or at least one element when
//    size-index is not provided:
//      access (access-mode, <ref-index> [, <size-index>])
// For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
//    use the access attribute to get object sizes from function definition
//    arguments, so we can't use them on functions we fortify.  Drop the object
//    size hints for such functions.

// Designates dealloc as a function to call to deallocate objects
//    allocated by the declared function.

// Specify that a function such as setjmp or vfork may return
//    twice.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint64  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int64   /* types.h:44:25 */
type T__uint64_t = uint64 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = T__int8_t     /* types.h:52:18 */
type T__uint_least8_t = T__uint8_t   /* types.h:53:19 */
type T__int_least16_t = T__int16_t   /* types.h:54:19 */
type T__uint_least16_t = T__uint16_t /* types.h:55:20 */
type T__int_least32_t = T__int32_t   /* types.h:56:19 */
type T__uint_least32_t = T__uint32_t /* types.h:57:20 */
type T__int_least64_t = T__int64_t   /* types.h:58:19 */
type T__uint_least64_t = T__uint64_t /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int64    /* types.h:63:18 */
type T__u_quad_t = uint64 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int64   /* types.h:72:18 */
type T__uintmax_t = uint64 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// And for getitimer, setitimer and rusage

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint64                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint64                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint64                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint64                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int64                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int64                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int64                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint64                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint64                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int64                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int64                /* types.h:162:31 */ // Signed count of microseconds.
type T__suseconds64_t = int64              /* types.h:163:33 */

type T__daddr_t = int32 /* types.h:165:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:166:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:169:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:172:12 */

// Type to represent block size.
type T__blksize_t = int64 /* types.h:175:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int64   /* types.h:180:28 */
type T__blkcnt64_t = int64 /* types.h:181:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint64   /* types.h:184:30 */
type T__fsblkcnt64_t = uint64 /* types.h:185:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint64   /* types.h:188:30 */
type T__fsfilcnt64_t = uint64 /* types.h:189:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int64 /* types.h:192:28 */

type T__ssize_t = int64 /* types.h:194:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int64 /* types.h:197:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint64 /* types.h:199:33 */

// These few don't really vary by system, they always correspond
//
//	to one of the other defined types.
type T__loff_t = T__off64_t /* types.h:203:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr   /* types.h:204:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int64 /* types.h:207:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:210:23 */

// C99: An integer type that can be accessed as an atomic entity,
//
//	even in the presence of asynchronous interrupts.
//	It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:215:13 */

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// wchar_t type related definitions.
//    Copyright (C) 2000-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = T__int8_t   /* stdint-intn.h:24:18 */
type Tint16_t = T__int16_t /* stdint-intn.h:25:19 */
type Tint32_t = T__int32_t /* stdint-intn.h:26:19 */
type Tint64_t = T__int64_t /* stdint-intn.h:27:19 */

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = T__uint8_t   /* stdint-uintn.h:24:19 */
type Tuint16_t = T__uint16_t /* stdint-uintn.h:25:20 */
type Tuint32_t = T__uint32_t /* stdint-uintn.h:26:20 */
type Tuint64_t = T__uint64_t /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = T__int_least8_t   /* stdint.h:43:24 */
type Tint_least16_t = T__int_least16_t /* stdint.h:44:25 */
type Tint_least32_t = T__int_least32_t /* stdint.h:45:25 */
type Tint_least64_t = T__int_least64_t /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = T__uint_least8_t   /* stdint.h:49:25 */
type Tuint_least16_t = T__uint_least16_t /* stdint.h:50:26 */
type Tuint_least32_t = T__uint_least32_t /* stdint.h:51:26 */
type Tuint_least64_t = T__uint_least64_t /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int64 /* stdint.h:60:19 */
type Tint_fast32_t = int64 /* stdint.h:61:19 */
type Tint_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint64 /* stdint.h:73:27 */
type Tuint_fast32_t = uint64 /* stdint.h:74:27 */
type Tuint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int64   /* stdint.h:87:19 */
type Tuintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = T__intmax_t   /* stdint.h:101:21 */
type Tuintmax_t = T__uintmax_t /* stdint.h:102:22 */

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1989-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = T__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   T__off_t
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   T__off64_t
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     T__off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F__ccgo_pad2     [4]byte
	F_lock           uintptr
	F_offset         T__off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          Tsize_t
	F_mode           int32
	F_unused2        [20]int8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type Tva_list = T__gnuc_va_list /* stdio.h:52:24 */

type Toff_t = T__off64_t /* stdio.h:65:19 */

type Tssize_t = T__ssize_t /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t /* stdio.h:86:20 */

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:63:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:81:5 */

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = T__u_char     /* types.h:33:18 */
type Tu_short = T__u_short   /* types.h:34:19 */
type Tu_int = T__u_int       /* types.h:35:17 */
type Tu_long = T__u_long     /* types.h:36:18 */
type Tquad_t = T__quad_t     /* types.h:37:18 */
type Tu_quad_t = T__u_quad_t /* types.h:38:20 */
type Tfsid_t = T__fsid_t     /* types.h:39:18 */
type Tloff_t = T__loff_t     /* types.h:42:18 */

type Tino_t = T__ino64_t /* types.h:49:19 */

type Tdev_t = T__dev_t /* types.h:59:17 */

type Tgid_t = T__gid_t /* types.h:64:17 */

type Tmode_t = T__mode_t /* types.h:69:18 */

type Tnlink_t = T__nlink_t /* types.h:74:19 */

type Tuid_t = T__uid_t /* types.h:79:17 */

type Tpid_t = T__pid_t /* types.h:97:17 */

type Tid_t = T__id_t /* types.h:103:16 */

type Tdaddr_t = T__daddr_t /* types.h:114:19 */
type Tcaddr_t = T__caddr_t /* types.h:115:19 */

type Tkey_t = T__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = T__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = T__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = T__time_t /* time_t.h:10:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = T__timer_t /* timer_t.h:7:19 */

// Copyright (C) 1989-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type Tulong = uint64  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These were defined by ISO C without the first `_'.
type Tu_int8_t = T__uint8_t   /* types.h:158:19 */
type Tu_int16_t = T__uint16_t /* types.h:159:20 */
type Tu_int32_t = T__uint32_t /* types.h:160:20 */
type Tu_int64_t = T__uint64_t /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We don't use `memset' because this would require a prototype and
//    the array isn't too big.

// Get sigset_t.

type T__sigset_t = struct{ F__val [16]uint64 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//
//	microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  T__time_t
	Ftv_usec T__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//
//	has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  T__time_t
	Ftv_nsec T__syscall_slong_t
} /* struct_timespec.h:11:1 */

type Tsuseconds_t = T__suseconds_t /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int64 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ F__fds_bits [16]T__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = T__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = T__blksize_t /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = T__blkcnt64_t     /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = T__fsblkcnt64_t /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = T__fsfilcnt64_t /* types.h:213:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Monotonically increasing wide counters (at least 62 bits).
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Counter that is monotonically increasing (by less than 2**31 per
//
//	increment), with a single writer, and an arbitrary number of
//	readers.
type T__atomic_wide_counter = struct{ F__value64 uint64 } /* atomic_wide_counter.h:33:3 */

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:51:9 */

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:55:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:57:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:60:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    T__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2023 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint64
	F__flags         uint32
	F__ccgo_pad1     [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__wseq         T__atomic_wide_counter
	F__g1_start     T__atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:94:1 */

type T__tss_t = uint32  /* thread-shared-types.h:105:22 */
type T__thrd_t = uint64 /* thread-shared-types.h:106:27 */

type T__once_flag = struct{ F__data int32 } /* thread-shared-types.h:111:3 */

// Thread identifiers.  The structure of the attribute type is not
//
//	exposed on purpose.
type Tpthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//
//	type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//
//	the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [56]int8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct{ F__data S__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//
//	structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct{ F__data S__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//
//	deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [32]int8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:424:1 */

// Data structure for communication with thread safe versions.  This
//
//	type is to be regarded as opaque.  It's only exported because users
//	have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:491:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:829:13 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// H3 is compiled as C, not C++ code. `extern "C"` is needed for C++ code
// to be able to use the library.

// * @brief Identifier for an object (cell, edge, etc) in the H3 system.
//
// The H3Index fits within a 64-bit unsigned integer.
type TH3Index = Tuint64_t /* h3api.h:69:18 */

// *
// Invalid index used to indicate an error from latLngToCell and related
// functions or missing data in arrays of H3 indices. Analogous to NaN in
// floating point.

// * @brief Result code (success or specific error) from an H3 operation
type TH3Error = Tuint32_t /* h3api.h:79:18 */

type TH3ErrorCodes = uint32 /* h3api.h:105:3 */

// library version numbers generated from VERSION file
// clang-format off
// clang-format on

// * Maximum number of cell boundary vertices; worst case is pentagon:
//  5 original verts + 5 edge crossings

//   - @struct LatLng
//     @brief latitude/longitude in radians
type TLatLng = struct {
	Flat float64
	Flng float64
} /* h3api.h:125:3 */

//   - @struct CellBoundary
//     @brief cell boundary in latitude/longitude
type TCellBoundary = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       [10]TLatLng
} /* h3api.h:133:3 */

//   - @struct GeoLoop
//     @brief similar to CellBoundary, but requires more alloc work
type TGeoLoop = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       uintptr
} /* h3api.h:141:3 */

//   - @struct GeoPolygon
//     @brief Simplified core of GeoJSON Polygon coordinates definition
type TGeoPolygon = struct {
	Fgeoloop     TGeoLoop
	FnumHoles    int32
	F__ccgo_pad1 [4]byte
	Fholes       uintptr
} /* h3api.h:150:3 */

//   - @struct GeoMultiPolygon
//     @brief Simplified core of GeoJSON MultiPolygon coordinates definition
type TGeoMultiPolygon = struct {
	FnumPolygons int32
	F__ccgo_pad1 [4]byte
	Fpolygons    uintptr
} /* h3api.h:158:3 */

//   - @struct LinkedLatLng
//     @brief A coordinate node in a linked geo structure, part of a linked list
type SLinkedLatLng = struct {
	Fvertex TLatLng
	Fnext   uintptr
} /* h3api.h:163:9 */

//   - @struct LinkedLatLng
//     @brief A coordinate node in a linked geo structure, part of a linked list
type TLinkedLatLng = SLinkedLatLng /* h3api.h:163:29 */

//   - @struct LinkedGeoLoop
//     @brief A loop node in a linked geo structure, part of a linked list
type SLinkedGeoLoop = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:172:9 */

//   - @struct LinkedGeoLoop
//     @brief A loop node in a linked geo structure, part of a linked list
type TLinkedGeoLoop = SLinkedGeoLoop /* h3api.h:172:30 */

//   - @struct LinkedGeoPolygon
//     @brief A polygon node in a linked geo structure, part of a linked list.
type SLinkedGeoPolygon = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:182:9 */

//   - @struct LinkedGeoPolygon
//     @brief A polygon node in a linked geo structure, part of a linked list.
type TLinkedGeoPolygon = SLinkedGeoPolygon /* h3api.h:182:33 */

// * @struct CoordIJ
// @brief IJ hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJ = struct {
	Fi int32
	Fj int32
} /* h3api.h:197:3 */

//   - @struct BBox
//     @brief  Geographic bounding box with coordinates defined in radians
type TBBox = struct {
	Fnorth float64
	Fsouth float64
	Feast  float64
	Fwest  float64
} /* bbox.h:35:3 */

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

//   - @struct Vec2d
//     @brief 2D floating-point vector
type TVec2d = struct {
	Fx float64
	Fy float64
} /* vec2d.h:31:3 */

// * @struct CoordIJK
// @brief IJK hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJK = struct {
	Fi int32
	Fj int32
	Fk int32
} /* coordijk.h:46:3 */

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
type TDirection = uint32 /* coordijk.h:85:3 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct VertexNode
//     @brief A single node in a vertex graph, part of a linked list
type SVertexNode = struct {
	Ffrom TLatLng
	Fto   TLatLng
	Fnext uintptr
} /* vertexGraph.h:31:9 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct VertexNode
//     @brief A single node in a vertex graph, part of a linked list
type TVertexNode = SVertexNode /* vertexGraph.h:31:27 */

//   - @struct VertexGraph
//     @brief A data structure to store a graph of vertices
type TVertexGraph = struct {
	Fbuckets     uintptr
	FnumBuckets  int32
	Fsize        int32
	Fres         int32
	F__ccgo_pad1 [4]byte
} /* vertexGraph.h:46:3 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Radix of exponent representation, b.

// Number of base-FLT_RADIX digits in the significand, p.

// Number of decimal digits, q, such that any floating-point number with q
//    decimal digits can be rounded into a floating-point number with p radix b
//    digits and back again without change to the q decimal digits,
//
// 	p * log10(b)			if b is a power of 10
// 	floor((p - 1) * log10(b))	otherwise

// Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin

// Minimum negative integer such that 10 raised to that power is in the
//    range of normalized floating-point numbers,
//
// 	ceil(log10(b) * (emin - 1))

// Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.

// Maximum integer such that 10 raised to that power is in the range of
//    representable finite floating-point numbers,
//
// 	floor(log10((1 - b**-p) * b**emax))

// Maximum representable finite floating-point number,
//
// 	(1 - b**-p) * b**emax

// The difference between 1 and the least value greater than 1 that is
//    representable in the given floating point type, b**1-p.

// Minimum normalized positive floating-point number, b**(emin - 1).

// Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.
// ??? This is supposed to change with calls to fesetround in <fenv.h>.

// The floating-point expression evaluation method.  The precise
//    definitions of these values are generalised to include support for
//    the interchange and extended types defined in ISO/IEC TS 18661-3.
//    Prior to this (for C99/C11) the definitions were:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants just to the range and
// 	    precision of the type
// 	 1  evaluate operations and constants of type float and double
// 	    to the range and precision of the double type, evaluate
// 	    long double operations and constants to the range and
// 	    precision of the long double type
// 	 2  evaluate all operations and constants to the range and
// 	    precision of the long double type
//
//    The TS 18661-3 definitions are:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of float, to the range and
// 	    precision of float; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 1  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of double, to the range and
// 	    precision of double; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 2  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of long double, to the range and
// 	    precision of long double; evaluate all other operations and
// 	    constants to the range and precision of the semantic type.
// 	 N  where _FloatN  is a supported interchange floating type
// 	    evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of the _FloatN type, to the
// 	    range and precision of the _FloatN type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
// 	 N + 1, where _FloatNx is a supported extended floating type
// 	    evaluate operations and constants, whose semantic type has at
// 	    most the range and precision of the _FloatNx type, to the range
// 	    and precision of the _FloatNx type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
//
//    The compiler predefines two macros:
//
//       __FLT_EVAL_METHOD__
//       Which, depending on the value given for
//       -fpermitted-flt-eval-methods, may be limited to only those values
//       for FLT_EVAL_METHOD defined in C99/C11.
//
//      __FLT_EVAL_METHOD_TS_18661_3__
//       Which always permits the values for FLT_EVAL_METHOD defined in
//       ISO/IEC TS 18661-3.
//
//      Here we want to use __FLT_EVAL_METHOD__, unless
//      __STDC_WANT_IEC_60559_TYPES_EXT__ is defined, in which case the user
//      is specifically asking for the ISO/IEC TS 18661-3 types, so we use
//      __FLT_EVAL_METHOD_TS_18661_3__.
//
//    ??? This ought to change with the setting of the fp control word;
//    the value provided by the compiler assumes the widest setting.

// Number of decimal digits, n, such that any floating-point number in the
//    widest supported floating type with pmax radix b digits can be rounded
//    to a floating-point number with n decimal digits and back again without
//    change to the value,
//
// 	pmax * log10(b)			if b is a power of 10
// 	ceil(1 + pmax * log10(b))	otherwise

// Versions of DECIMAL_DIG for each floating-point type.

// Whether types support subnormal numbers.

// Minimum positive values, including subnormals.

// Declarations for math functions.
//    Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//	    float_t	floating-point type at least as wide as `float' used
//			to evaluate `float' expressions
//	    double_t	floating-point type at least as wide as `double' used
//			to evaluate `double' expressions
type Tfloat_t = float32  /* math.h:163:15 */
type Tdouble_t = float64 /* math.h:164:16 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:27:1 */

type T__locale_t = uintptr /* __locale_t.h:41:32 */

type Tlocale_t = T__locale_t /* locale_t.h:24:20 */

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file baseCells.h
// @brief   Base cell related lookup tables and access functions.

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lng.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// * @struct FaceIJK
// @brief Face number and ijk coordinates on that face-centered coordinate
// system
type TFaceIJK = struct {
	Fface  int32
	Fcoord TCoordIJK
} /* faceijk.h:38:3 */

// * @struct FaceOrientIJK
// @brief Information to transform into an adjacent face IJK system
type TFaceOrientIJK = struct {
	Fface      int32
	Ftranslate TCoordIJK
	FccwRot60  int32
} /* faceijk.h:48:3 */

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

// * Digit representing overage type
type TOverage = uint32 /* faceijk.h:71:3 */

// * @struct BaseCellData
// @brief information on a single base cell
type TBaseCellData = struct {
	FhomeFijk     TFaceIJK
	FisPentagon   int32
	FcwOffsetPent [2]int32
} /* baseCells.h:36:3 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Return codes from gridDiskUnsafe and related functions.

// *
// Directions used for traversing a hexagonal ring counterclockwise around
// {1, 0, 0}
//
// <pre>
//
//	   _
//	 _/ \\_
//	/ \\5/ \ *   \\0/ \\4/
//	/ \\_/ \ *   \\1/ \\3/
//	  \\2/
//
// </pre>
var sDIRECTIONS = [6]TDirection{J_AXES_DIGIT, JK_AXES_DIGIT,
	K_AXES_DIGIT, IK_AXES_DIGIT,
	I_AXES_DIGIT, IJ_AXES_DIGIT} /* algos.c:62:24 */

// *
// Direction used for traversing to the next outward hexagonal ring.
var sNEXT_RING_DIRECTION TDirection = I_AXES_DIGIT /* algos.c:69:24 */

// *
// New digit when traversing along class II grids.
//
// Current digit -> direction -> new digit.
var sNEW_DIGIT_II = [7][7]TDirection{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, I_AXES_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, IK_AXES_DIGIT,
		J_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IK_AXES_DIGIT},
	{JK_AXES_DIGIT, IJ_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, K_AXES_DIGIT},
	{IK_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT,
		IJ_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT, J_AXES_DIGIT, K_AXES_DIGIT,
		I_AXES_DIGIT, JK_AXES_DIGIT}} /* algos.c:76:24 */

// *
// New traversal direction when traversing along class II grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_II = [7][7]TDirection{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, J_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		I_AXES_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:97:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_DIGIT_III = [7][7]TDirection{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT,
		IJ_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, K_AXES_DIGIT},
	{JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT,
		J_AXES_DIGIT, JK_AXES_DIGIT},
	{IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT,
		I_AXES_DIGIT, IK_AXES_DIGIT}} /* algos.c:118:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_III = [7][7]TDirection{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, JK_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, I_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:139:24 */

// *
// k value which will encompass all cells at resolution 15.
// This is the largest possible k in the H3 grid system.
var sK_ALL_CELLS_AT_RES_15 int32 = 13780510 /* algos.c:159:18 */

// *
// Maximum number of cells that result from the gridDisk algorithm with the
// given k. Formula source and proof: https://oeis.org/A003215
//
// @param   k   k value, k >= 0.
// @param out   size in indexes
func XmaxGridDiskSize(tls *libc.TLS, k int32, out uintptr) TH3Error { /* algos.c:168:9: */
	if k < 0 {
		return E_DOMAIN
	}
	if k >= sK_ALL_CELLS_AT_RES_15 {
		// If a k value of this value or above is provided, this function will
		// estimate more cells than exist in the H3 grid at the finest
		// resolution. This is a problem since the function does signed integer
		// arithmetic on `k`, which could overflow. To prevent that, instead
		// substitute the maximum number of cells in the grid, as it should not
		// be possible for the gridDisk functions to exceed that. Note this is
		// not resolution specific. So, when resolution < 15, this function may
		// still estimate a size larger than the number of cells in the grid.
		return XgetNumCells(tls, DMAX_H3_RES, out)
	}
	*(*Tint64_t)(unsafe.Pointer(out)) = int64(3)*Tint64_t(k)*(Tint64_t(k)+int64(1)) + int64(1)
	return E_SUCCESS
}

// *
// Produce cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin   origin cell
// @param  k        k >= 0
// @param  out      zero-filled array which must be of size maxGridDiskSize(k)
func XgridDisk(tls *libc.TLS, origin TH3Index, k int32, out uintptr) TH3Error { /* algos.c:200:9: */
	return XgridDiskDistances(tls, origin, k, out, uintptr(0))
}

// *
// Produce cells and their distances from the given origin cell, up to
// distance k.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin      origin cell
// @param  k           k >= 0
// @param  out         zero-filled array which must be of size
// maxGridDiskSize(k)
// @param  distances   NULL or a zero-filled array which must be of size
//
//	maxGridDiskSize(k)
func XgridDiskDistances(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr) TH3Error { /* algos.c:221:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Optimistically try the faster gridDiskUnsafe algorithm first
	var failed TH3Error = XgridDiskDistancesUnsafe(tls, origin, k, out, distances)
	if failed != 0 {
		// var maxIdx Tint64_t at bp, 8

		var err TH3Error = XmaxGridDiskSize(tls, k, bp)
		if err != 0 {
			return err
		}
		// Fast algo failed, fall back to slower, correct algo
		// and also wipe out array because contents untrustworthy
		libc.Xmemset(tls, out, 0, uint64(*(*Tint64_t)(unsafe.Pointer(bp)))*uint64(unsafe.Sizeof(TH3Index(0))))

		if distances == uintptr(0) {
			distances = libc.Xcalloc(tls, uint64(*(*Tint64_t)(unsafe.Pointer(bp /* maxIdx */))), uint64(unsafe.Sizeof(int32(0))))
			if !(distances != 0) {
				return E_MEMORY_ALLOC
			}
			var result TH3Error = X_gridDiskDistancesInternal(tls, origin, k, out,
				distances, *(*Tint64_t)(unsafe.Pointer(bp /* maxIdx */)), 0)
			libc.Xfree(tls, distances)
			return result
		} else {
			libc.Xmemset(tls, distances, 0, uint64(*(*Tint64_t)(unsafe.Pointer(bp)))*uint64(unsafe.Sizeof(int32(0))))
			return X_gridDiskDistancesInternal(tls, origin, k, out, distances, *(*Tint64_t)(unsafe.Pointer(bp /* maxIdx */)),
				0)
		}
	} else {
		return E_SUCCESS
	}
	return TH3Error(0)
}

// *
// Internal algorithm for the safe but slow version of gridDiskDistances
//
// Adds the origin cell to the output set (treating it as a hash set)
// and recurses to its neighbors, if needed.
//
// @param  origin      Origin cell
// @param  k           Maximum distance to move from the origin
// @param  out         Array treated as a hash set, elements being either
//
//	H3Index or 0.
//
// @param  distances   Scratch area, with elements paralleling the out array.
//
//	Elements indicate ijk distance from the origin cell to
//	the output cell
//
// @param  maxIdx      Size of out and scratch arrays (must be
// maxGridDiskSize(k))
// @param  curK        Current distance from the origin
func X_gridDiskDistancesInternal(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr, maxIdx Tint64_t, curK int32) TH3Error { /* algos.c:272:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Put origin in the output array. out is used as a hash set.
	var off Tint64_t = Tint64_t(origin % TH3Index(maxIdx))
	for *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) != uint64(0) && *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) != origin {
		off = (off + int64(1)) % maxIdx
	}

	// We either got a free slot in the hash set or hit a duplicate
	// We might need to process the duplicate anyways because we got
	// here on a longer path before.
	if *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) == origin && *(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) <= curK {
		return E_SUCCESS
	}

	*(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) = origin
	*(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) = curK

	// Base case: reached an index k away from the origin.
	if curK >= k {
		return E_SUCCESS
	}

	// Recurse to all neighbors in no particular order.
	{
		var i int32 = 0
		for ; i < 6; i++ {
			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			// var nextNeighbor TH3Index at bp+8, 8

			var neighborResult TH3Error = Xh3NeighborRotations(tls, origin, sDIRECTIONS[i],
				bp, bp+8)
			if neighborResult != E_PENTAGON {
				// E_PENTAGON is an expected case when trying to traverse off of
				// pentagons.
				if neighborResult != E_SUCCESS {
					return neighborResult
				}
				neighborResult = X_gridDiskDistancesInternal(tls,
					*(*TH3Index)(unsafe.Pointer(bp + 8 /* nextNeighbor */)), k, out, distances, maxIdx, curK+1)
				if neighborResult != 0 {
					return neighborResult
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Safe but slow version of gridDiskDistances (also called by it when needed).
//
// Adds the origin cell to the output set (treating it as a hash set)
// and recurses to its neighbors, if needed.
//
// @param  origin      Origin cell
// @param  k           Maximum distance to move from the origin
// @param  out         Array treated as a hash set, elements being either
//
//	H3Index or 0.
//
// @param  distances   Scratch area, with elements paralleling the out array.
//
//	Elements indicate ijk distance from the origin cell to
//	the output cell
func XgridDiskDistancesSafe(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr) TH3Error { /* algos.c:327:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var maxIdx Tint64_t at bp, 8

	var err TH3Error = XmaxGridDiskSize(tls, k, bp)
	if err != 0 {
		return err
	}
	return X_gridDiskDistancesInternal(tls, origin, k, out, distances, *(*Tint64_t)(unsafe.Pointer(bp /* maxIdx */)), 0)
}

// *
// Returns the hexagon index neighboring the origin, in the direction dir.
//
// Implementation note: The only reachable case where this returns 0 is if the
// origin is a pentagon and the translation is in the k direction. Thus,
// 0 can only be returned if origin is a pentagon.
//
// @param origin Origin index
// @param dir Direction to move in
// @param rotations Number of ccw rotations to perform to reorient the
//
//	translation vector. Will be modified to the new number of
//	rotations to perform (such as when crossing a face edge.)
//
// @param out H3Index of the specified neighbor if succesful
// @return E_SUCCESS on success
func Xh3NeighborRotations(tls *libc.TLS, origin TH3Index, dir TDirection, rotations uintptr, out uintptr) TH3Error { /* algos.c:352:9: */
	var current TH3Index = origin

	if dir < CENTER_DIGIT || dir >= INVALID_DIGIT {
		return E_FAILED
	}
	// Ensure that rotations is modulo'd by 6 before any possible addition,
	// to protect against signed integer overflow.
	*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) % 6
	{
		var i int32 = 0
		for ; i < *(*int32)(unsafe.Pointer(rotations)); i++ {
			dir = X_rotate60ccw(tls, dir)
		}
	}

	var newRotations int32 = 0
	var oldBaseCell int32 = int32(current & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if oldBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+2, uint32(368), uintptr(unsafe.Pointer(&__func__)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || oldBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	var oldLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, current)

	// Adjust the indexing digits and, if needed, the base cell.
	var r int32 = int32(current&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	for 1 != 0 {
		if r == -1 {
			current = current&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4)))<<DH3_BC_OFFSET
			newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4))

			if int32(current&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET) == DINVALID_BASE_CELL {
				// Adjust for the deleted k vertex at the base cell level.
				// This edge actually borders a different neighbor.
				current = current&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + 5*4)))<<DH3_BC_OFFSET
				newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + 5*4))

				// perform the adjustment for the k-subsequence we're skipping
				// over.
				current = X_h3Rotate60ccw(tls, current)
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}

			break
		} else {
			var oldDigit TDirection = TDirection(current >> ((DMAX_H3_RES - (r + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			var nextDir TDirection
			if oldDigit == INVALID_DIGIT {
				// Only possible on invalid input
				return E_CELL_INVALID
			} else if XisResolutionClassIII(tls, r+1) != 0 {
				current = current & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(*(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			} else {
				current = current & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(*(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			}

			if nextDir != CENTER_DIGIT {
				dir = nextDir
				r--
			} else {
				// No more adjustment to perform
				break
			}
		}
	}

	var newBaseCell int32 = int32(current & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if X_isBaseCellPentagon(tls, newBaseCell) != 0 {
		var alreadyAdjustedKSubsequence int32 = 0

		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, current) == K_AXES_DIGIT {
			if oldBaseCell != newBaseCell {
				// in this case, we traversed into the deleted
				// k subsequence of a pentagon base cell.
				// We need to rotate out of that case depending
				// on how we got here.
				// check for a cw/ccw offset face; default is ccw

				if func() int32 {
					if X_baseCellIsCwOffset(tls, newBaseCell, XbaseCellData[oldBaseCell].FhomeFijk.Fface) != 0 {
						return 1
					}
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+2, uint32(434), uintptr(unsafe.Pointer(&__func__)))
						}
						return 0
					}()
				}() != 0 {
					current = X_h3Rotate60cw(tls, current)
				} else {
					// See cwOffsetPent in testGridDisk.c for why this is
					// unreachable.
					current = X_h3Rotate60ccw(tls, current)
				}
				alreadyAdjustedKSubsequence = 1
			} else {
				// In this case, we traversed into the deleted
				// k subsequence from within the same pentagon
				// base cell.
				if oldLeadingDigit == CENTER_DIGIT {
					// Undefined: the k direction is deleted from here
					return E_PENTAGON
				} else if oldLeadingDigit == JK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					current = X_h3Rotate60ccw(tls, current)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				} else if oldLeadingDigit == IK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					current = X_h3Rotate60cw(tls, current)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 5
				} else {
					// TODO: Should never occur, but is reachable by fuzzer
					return E_FAILED
				}
			}
		}

		{
			var i int32 = 0
			for ; i < newRotations; i++ {
				current = X_h3RotatePent60ccw(tls, current)
			}
		}

		// Account for differing orientation of the base cells (this edge
		// might not follow properties of some other edges.)
		if oldBaseCell != newBaseCell {
			if X_isBaseCellPolarPentagon(tls, newBaseCell) != 0 {
				// 'polar' base cells behave differently because they have all
				// i neighbors.
				if oldBaseCell != 118 && oldBaseCell != 8 && X_h3LeadingNonZeroDigit(tls, current) != JK_AXES_DIGIT {
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				}
			} else if X_h3LeadingNonZeroDigit(tls, current) == IK_AXES_DIGIT && !(alreadyAdjustedKSubsequence != 0) {
				// account for distortion introduced to the 5 neighbor by the
				// deleted k subsequence.
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}
		}
	} else {
		{
			var i int32 = 0
			for ; i < newRotations; i++ {
				current = X_h3Rotate60ccw(tls, current)
			}
		}
	}

	*(*int32)(unsafe.Pointer(rotations)) = (*(*int32)(unsafe.Pointer(rotations)) + newRotations) % 6
	*(*TH3Index)(unsafe.Pointer(out)) = current

	return E_SUCCESS
}

var __func__ = *(*[20]int8)(unsafe.Pointer(ts + 27)) /* algos.c:353:43 */

// *
// Get the direction from the origin to a given neighbor. This is effectively
// the reverse operation for h3NeighborRotations. Returns INVALID_DIGIT if the
// cells are not neighbors.
//
// TODO: This is currently a brute-force algorithm, but as it's O(6) that's
// probably acceptable.
func XdirectionForNeighbor(tls *libc.TLS, origin TH3Index, destination TH3Index) TDirection { /* algos.c:509:11: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var isPent uint8 = uint8(XisPentagon(tls, origin))
	// Checks each neighbor, in order, to determine which direction the
	// destination neighbor is located. Skips CENTER_DIGIT since that
	// would be the origin; skips deleted K direction for pentagons.
	{
		var direction TDirection
		if isPent != 0 {
			direction = J_AXES_DIGIT
		} else {
			direction = K_AXES_DIGIT
		}
		for ; direction < NUM_DIGITS; direction++ {
			// var neighbor TH3Index at bp+8, 8

			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			var neighborError TH3Error = Xh3NeighborRotations(tls, origin, direction, bp, bp+8)
			if !(neighborError != 0) && *(*TH3Index)(unsafe.Pointer(bp + 8)) == destination {
				return direction
			}
		}
	}
	return INVALID_DIGIT
}

// *
// gridDiskUnsafe produces indexes within k distance of the origin index.
// Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxGridDiskSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XgridDiskUnsafe(tls *libc.TLS, origin TH3Index, k int32, out uintptr) TH3Error { /* algos.c:543:9: */
	return XgridDiskDistancesUnsafe(tls, origin, k, out, uintptr(0))
}

// *
// gridDiskDistancesUnsafe produces indexes within k distance of the origin
// index. Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin. The distances in hexagons is placed in the distances array at
// the same offset.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxGridDiskSize(k).
// @param distances Null or array which must be of size maxGridDiskSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XgridDiskDistancesUnsafe(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr) TH3Error { /* algos.c:565:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TH3Index)(unsafe.Pointer(bp + 8)) = origin

	// Return codes:
	// 1 Pentagon was encountered
	// 2 Pentagon distortion (deleted k subsequence) was encountered
	// Pentagon being encountered is not itself a problem; really the deleted
	// k-subsequence is the problem, but for compatibility reasons we fail on
	// the pentagon.
	if k < 0 {
		return E_DOMAIN
	}

	// k must be >= 0, so origin is always needed
	var idx int32 = 0
	*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))
	if distances != 0 {
		*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = 0
	}
	idx++

	if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return E_PENTAGON
	}

	// 0 < ring <= k, current ring
	var ring int32 = 1
	// 0 <= direction < 6, current side of the ring
	var direction int32 = 0
	// 0 <= i < ring, current position on the side of the ring
	var i int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0

	for ring <= k {
		if direction == 0 && i == 0 {
			// Not putting in the output set as it will be done later, at
			// the end of this ring.
			var neighborResult TH3Error = Xh3NeighborRotations(tls,
				*(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */)), sNEXT_RING_DIRECTION, bp, bp+8)
			if neighborResult != 0 {
				// Should not be possible because `origin` would have to be a
				// pentagon
				// TODO: Reachable via fuzzer
				return neighborResult
			}

			if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
				// Pentagon was encountered; bail out as user doesn't want this.
				return E_PENTAGON
			}
		}

		var neighborResult TH3Error = Xh3NeighborRotations(tls,
			*(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */)), sDIRECTIONS[direction], bp, bp+8)
		if neighborResult != 0 {
			return neighborResult
		}
		*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))
		if distances != 0 {
			*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = ring
		}
		idx++

		i++
		// Check if end of this side of the k-ring
		if i == ring {
			i = 0
			direction++
			// Check if end of this ring.
			if direction == 6 {
				direction = 0
				ring++
			}
		}

		if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
			// Pentagon was encountered; bail out as user doesn't want this.
			return E_PENTAGON
		}
	}
	return E_SUCCESS
}

// *
// gridDisksUnsafe takes an array of input hex IDs and a max k-ring and returns
// an array of hexagon IDs sorted first by the original hex IDs and then by the
// k-ring (0 to max), with no guaranteed sorting within each k-ring group.
//
// @param h3Set A pointer to an array of H3Indexes
// @param length The total number of H3Indexes in h3Set
// @param k The number of rings to generate
// @param out A pointer to the output memory to dump the new set of H3Indexes to
//
//	The memory block should be equal to maxGridDiskSize(k) * length
//
// @return 0 if no pentagon is encountered. Cannot trust output otherwise
func XgridDisksUnsafe(tls *libc.TLS, h3Set uintptr, length int32, k int32, out uintptr) TH3Error { /* algos.c:662:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var segment uintptr
	// var segmentSize Tint64_t at bp, 8

	var err TH3Error = XmaxGridDiskSize(tls, k, bp)
	if err != 0 {
		return err
	}
	{
		var i int32 = 0
		for ; i < length; i++ {
			// Determine the appropriate segment of the output array to operate on
			segment = out + uintptr(Tint64_t(i)**(*Tint64_t)(unsafe.Pointer(bp)))*8
			var failed TH3Error = XgridDiskUnsafe(tls, *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8)), k, segment)
			if failed != 0 {
				return failed
			}
		}
	}
	return E_SUCCESS
}

// *
// Returns the "hollow" ring of hexagons at exactly grid distance k from
// the origin hexagon. In particular, k=0 returns just the origin hexagon.
//
// A nonzero failure code may be returned in some cases, for example,
// if a pentagon is encountered.
// Failure cases may be fixed in future versions.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size 6 * k (or 1 if k == 0)
// @return 0 if successful; nonzero otherwise.
func XgridRingUnsafe(tls *libc.TLS, origin TH3Index, k int32, out uintptr) TH3Error { /* algos.c:692:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TH3Index)(unsafe.Pointer(bp + 8)) = origin

	// Short-circuit on 'identity' ring
	if k == 0 {
		*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))
		return E_SUCCESS
	}
	var idx int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
	// Scratch structure for checking for pentagons
	if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return E_PENTAGON
	}

	{
		var ring int32 = 0
		for ; ring < k; ring++ {
			var neighborResult TH3Error = Xh3NeighborRotations(tls,
				*(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */)), sNEXT_RING_DIRECTION, bp, bp+8)
			if neighborResult != 0 {
				// Should not be possible because `origin` would have to be a
				// pentagon
				// TODO: Reachable via fuzzer
				return neighborResult
			}

			if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
				return E_PENTAGON
			}
		}
	}

	var lastIndex TH3Index = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))

	*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))
	idx++

	{
		var direction int32 = 0
		for ; direction < 6; direction++ {
			{
				var pos int32 = 0
				for ; pos < k; pos++ {
					var neighborResult TH3Error = Xh3NeighborRotations(tls,
						*(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */)), sDIRECTIONS[direction], bp, bp+8)
					if neighborResult != 0 {
						// Should not be possible because `origin` would have to be a
						// pentagon
						// TODO: Reachable via fuzzer
						return neighborResult
					}

					// Skip the very last index, it was already added. We do
					// however need to traverse to it because of the pentagonal
					// distortion check, below.
					if pos != k-1 || direction != 5 {
						*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* origin */))
						idx++

						if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8))) != 0 {
							return E_PENTAGON
						}
					}
				}
			}
		}
	}

	// Check that this matches the expected lastIndex, if it doesn't,
	// it indicates pentagonal distortion occurred and we should report
	// failure.
	if lastIndex != *(*TH3Index)(unsafe.Pointer(bp + 8)) {
		return E_PENTAGON
	} else {
		return E_SUCCESS
	}
	return TH3Error(0)
}

// *
// maxPolygonToCellsSize returns the number of cells to allocate space for
// when performing a polygonToCells on the given GeoJSON-like data structure.
//
// The size is the maximum of either the number of points in the geoloop or the
// number of cells in the bounding box of the geoloop.
//
// @param geoPolygon A GeoJSON-like data structure indicating the poly to fill
// @param res Hexagon resolution (0-15)
// @param out number of cells to allocate for
// @return 0 (E_SUCCESS) on success.
func XmaxPolygonToCellsSize(tls *libc.TLS, geoPolygon uintptr, res int32, flags Tuint32_t, out uintptr) TH3Error { /* algos.c:775:9: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if flags != Tuint32_t(0) {
		return E_OPTION_INVALID
	}
	// Get the bounding box for the GeoJSON-like struct
	// var bbox TBBox at bp+16, 32

	*(*TGeoLoop)(unsafe.Pointer(bp /* geoloop */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeoloop
	XbboxFromGeoLoop(tls, bp, bp+16)
	// var numHexagons Tint64_t at bp+48, 8

	var estimateErr TH3Error = XbboxHexEstimate(tls, bp+16, res, bp+48)
	if estimateErr != 0 {
		return estimateErr
	}
	// This algorithm assumes that the number of vertices is usually less than
	// the number of hexagons, but when it's wrong, this will keep it from
	// failing
	var totalVerts int32 = (*TGeoLoop)(unsafe.Pointer(bp /* &geoloop */)).FnumVerts
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			totalVerts = totalVerts + (*TGeoLoop)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16)).FnumVerts
		}
	}
	if *(*Tint64_t)(unsafe.Pointer(bp + 48)) < Tint64_t(totalVerts) {
		*(*Tint64_t)(unsafe.Pointer(bp + 48 /* numHexagons */)) = Tint64_t(totalVerts)
	}
	// When the polygon is very small, near an icosahedron edge and is an odd
	// resolution, the line tracing needs an extra buffer than the estimator
	// function provides (but beefing that up to cover causes most situations to
	// overallocate memory)
	*(*Tint64_t)(unsafe.Pointer(bp + 48 /* numHexagons */)) += int64(DPOLYGON_TO_CELLS_BUFFER)
	*(*Tint64_t)(unsafe.Pointer(out)) = *(*Tint64_t)(unsafe.Pointer(bp + 48 /* numHexagons */))
	return E_SUCCESS
}

// *
// _getEdgeHexagons takes a given geoloop ring (either the main geoloop or
// one of the holes) and traces it with hexagons and updates the search and
// found memory blocks. This is used for determining the initial hexagon set
// for the polygonToCells algorithm to execute on.
//
// @param geoloop The geoloop (or hole) to be traced
// @param numHexagons The maximum number of hexagons possible for the geoloop
//
//	(also the bounds of the search and found arrays)
//
// @param res The hexagon resolution (0-15)
// @param numSearchHexes The number of hexagons found so far to be searched
// @param search The block of memory containing the hexagons to search from
// @param found The block of memory containing the hexagons found from the
// search
//
// @return An error code if the hash function cannot insert a found hexagon
//
//	into the found array.
func X_getEdgeHexagons(tls *libc.TLS, geoloop uintptr, numHexagons Tint64_t, res int32, numSearchHexes uintptr, search uintptr, found uintptr) TH3Error { /* algos.c:824:9: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	{
		var i int32 = 0
		for ; i < (*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts; i++ {
			*(*TLatLng)(unsafe.Pointer(bp /* origin */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr(i)*16))
			if i == (*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts-1 {
				*(*TLatLng)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts))
			} else {
				*(*TLatLng)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr(i+1)*16))
			}
			// var numHexesEstimate Tint64_t at bp+32, 8

			var estimateErr TH3Error = XlineHexEstimate(tls, bp, bp+16, res, bp+32)
			if estimateErr != 0 {
				return estimateErr
			}
			{
				var j Tint64_t = int64(0)
				for ; j < *(*Tint64_t)(unsafe.Pointer(bp + 32)); j++ {
					// var interpolate TLatLng at bp+40, 16

					(*TLatLng)(unsafe.Pointer(bp + 40 /* &interpolate */)).Flat = (*TLatLng)(unsafe.Pointer(bp)).Flat*float64(*(*Tint64_t)(unsafe.Pointer(bp + 32))-j)/float64(*(*Tint64_t)(unsafe.Pointer(bp + 32))) + (*TLatLng)(unsafe.Pointer(bp+16)).Flat*float64(j)/float64(*(*Tint64_t)(unsafe.Pointer(bp + 32)))
					(*TLatLng)(unsafe.Pointer(bp + 40 /* &interpolate */)).Flng = (*TLatLng)(unsafe.Pointer(bp)).Flng*float64(*(*Tint64_t)(unsafe.Pointer(bp + 32))-j)/float64(*(*Tint64_t)(unsafe.Pointer(bp + 32))) + (*TLatLng)(unsafe.Pointer(bp+16)).Flng*float64(j)/float64(*(*Tint64_t)(unsafe.Pointer(bp + 32)))
					// var pointHex TH3Index at bp+56, 8

					var e TH3Error = XlatLngToCell(tls, bp+40, res, bp+56)
					if e != 0 {
						return e
					}
					// A simple hash to store the hexagon, or move to another place if
					// needed
					var loc Tint64_t = Tint64_t(*(*TH3Index)(unsafe.Pointer(bp + 56)) % TH3Index(numHexagons))
					var loopCount Tint64_t = int64(0)
					for *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) != uint64(0) {
						// If this conditional is reached, the `found` memory block is
						// too small for the given polygon. This should not happen.
						// TODO: Reachable via fuzzer
						if loopCount > numHexagons {
							return E_FAILED
						}
						if *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) == *(*TH3Index)(unsafe.Pointer(bp + 56)) {
							break
						} // At least two points of the geoloop index to the
						// same cell
						loc = (loc + int64(1)) % numHexagons
						loopCount++
					}
					if *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) == *(*TH3Index)(unsafe.Pointer(bp + 56)) {
						continue
					} // Skip this hex, already exists in the found hash
					// Otherwise, set it in the found hash for now
					*(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) = *(*TH3Index)(unsafe.Pointer(bp + 56 /* pointHex */))

					*(*TH3Index)(unsafe.Pointer(search + uintptr(*(*Tint64_t)(unsafe.Pointer(numSearchHexes)))*8)) = *(*TH3Index)(unsafe.Pointer(bp + 56 /* pointHex */))
					*(*Tint64_t)(unsafe.Pointer(numSearchHexes))++
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// polygonToCells takes a given GeoJSON-like data structure and preallocated,
// zeroed memory, and fills it with the hexagons that are contained by
// the GeoJSON-like data structure.
//
// This implementation traces the GeoJSON geoloop(s) in cartesian space with
// hexagons, tests them and their neighbors to be contained by the geoloop(s),
// and then any newly found hexagons are used to test again until no new
// hexagons are found.
//
// @param geoPolygon The geoloop and holes defining the relevant area
// @param res The Hexagon resolution (0-15)
// @param out The slab of zeroed memory to write to. Assumed to be big enough.
func XpolygonToCells(tls *libc.TLS, geoPolygon uintptr, res int32, flags Tuint32_t, out uintptr) TH3Error { /* algos.c:891:9: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	if flags != Tuint32_t(0) {
		return E_OPTION_INVALID
	}
	// One of the goals of the polygonToCells algorithm is that two adjacent
	// polygons with zero overlap have zero overlapping hexagons. That the
	// hexagons are uniquely assigned. There are a few approaches to take here,
	// such as deciding based on which polygon has the greatest overlapping area
	// of the hexagon, or the most number of contained points on the hexagon
	// (using the center point as a tiebreaker).
	//
	// But if the polygons are convex, both of these more complex algorithms can
	// be reduced down to checking whether or not the center of the hexagon is
	// contained in the polygon, and so this is the approach that this
	// polygonToCells algorithm will follow, as it's simpler, faster, and the
	// error for concave polygons is still minimal (only affecting concave
	// shapes on the order of magnitude of the hexagon size or smaller, not
	// impacting larger concave shapes)
	//
	// This first part is identical to the maxPolygonToCellsSize above.

	// Get the bounding boxes for the polygon and any holes
	var bboxes uintptr = libc.Xmalloc(tls, uint64((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles+1)*uint64(unsafe.Sizeof(TBBox{})))
	if !(bboxes != 0) {
		return E_MEMORY_ALLOC
	}
	XbboxesFromGeoPolygon(tls, geoPolygon, bboxes)

	// Get the estimated number of hexagons and allocate some temporary memory
	// for the hexagons
	// var numHexagons Tint64_t at bp, 8

	var numHexagonsError TH3Error = XmaxPolygonToCellsSize(tls, geoPolygon, res, flags, bp)
	if numHexagonsError != 0 {
		libc.Xfree(tls, bboxes)
		return numHexagonsError
	}
	var search uintptr = libc.Xcalloc(tls, uint64(*(*Tint64_t)(unsafe.Pointer(bp /* numHexagons */))), uint64(unsafe.Sizeof(TH3Index(0))))
	if !(search != 0) {
		libc.Xfree(tls, bboxes)
		return E_MEMORY_ALLOC
	}
	var found uintptr = libc.Xcalloc(tls, uint64(*(*Tint64_t)(unsafe.Pointer(bp /* numHexagons */))), uint64(unsafe.Sizeof(TH3Index(0))))
	if !(found != 0) {
		libc.Xfree(tls, bboxes)
		libc.Xfree(tls, search)
		return E_MEMORY_ALLOC
	}

	// Some metadata for tracking the state of the search and found memory
	// blocks
	*(*Tint64_t)(unsafe.Pointer(bp + 24 /* numSearchHexes */)) = int64(0)
	var numFoundHexes Tint64_t = int64(0)

	// 1. Trace the hexagons along the polygon defining the outer geoloop and
	// add them to the search hash. The hexagon containing the geoloop point
	// may or may not be contained by the geoloop (as the hexagon's center
	// point may be outside of the boundary.)
	*(*TGeoLoop)(unsafe.Pointer(bp + 8 /* geoloop */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeoloop
	var edgeHexError TH3Error = X_getEdgeHexagons(tls, bp+8, *(*Tint64_t)(unsafe.Pointer(bp /* numHexagons */)), res,
		bp+24, search, found)
	// If this branch is reached, we have exceeded the maximum number of
	// hexagons possible and need to clean up the allocated memory.
	// TODO: Reachable via fuzzer
	if edgeHexError != 0 {
		libc.Xfree(tls, search)
		libc.Xfree(tls, found)
		libc.Xfree(tls, bboxes)
		return edgeHexError
	}

	// 2. Iterate over all holes, trace the polygons defining the holes with
	// hexagons and add to only the search hash. We're going to temporarily use
	// the `found` hash to use for dedupe purposes and then re-zero it once
	// we're done here, otherwise we'd have to scan the whole set on each insert
	// to make sure there's no duplicates, which is very inefficient.
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			var hole uintptr = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes + uintptr(i)*16
			edgeHexError = X_getEdgeHexagons(tls, hole, *(*Tint64_t)(unsafe.Pointer(bp /* numHexagons */)), res, bp+24,
				search, found)
			// If this branch is reached, we have exceeded the maximum number of
			// hexagons possible and need to clean up the allocated memory.
			// TODO: Reachable via fuzzer
			if edgeHexError != 0 {
				libc.Xfree(tls, search)
				libc.Xfree(tls, found)
				libc.Xfree(tls, bboxes)
				return edgeHexError
			}
		}
	}

	// 3. Re-zero the found hash so it can be used in the main loop below
	{
		var i1 Tint64_t = int64(0)
		for ; i1 < *(*Tint64_t)(unsafe.Pointer(bp)); i1++ {
			*(*TH3Index)(unsafe.Pointer(found + uintptr(i1)*8)) = uint64(DH3_NULL)
		}
	}

	// 4. Begin main loop. While the search hash is not empty do the following
	for *(*Tint64_t)(unsafe.Pointer(bp + 24)) > int64(0) {
		// Iterate through all hexagons in the current search hash, then loop
		// through all neighbors and test Point-in-Poly, if point-in-poly
		// succeeds, add to out and found hashes if not already there.
		var currentSearchNum Tint64_t = int64(0)
		var i Tint64_t = int64(0)
		for currentSearchNum < *(*Tint64_t)(unsafe.Pointer(bp + 24)) {
			*(*[7]TH3Index)(unsafe.Pointer(bp + 32 /* ring */)) = [7]TH3Index{0: uint64(0)}
			var searchHex TH3Index = *(*TH3Index)(unsafe.Pointer(search + uintptr(i)*8))
			XgridDisk(tls, searchHex, 1, bp+32)
			{
				var j int32 = 0
				for ; j < DMAX_ONE_RING_SIZE; j++ {
					if *(*TH3Index)(unsafe.Pointer(bp + 32 + uintptr(j)*8)) == uint64(DH3_NULL) {
						continue // Skip if this was a pentagon and only had 5
						// neighbors
					}

					var hex TH3Index = *(*TH3Index)(unsafe.Pointer(bp + 32 + uintptr(j)*8))

					// A simple hash to store the hexagon, or move to another place
					// if needed. This MUST be done before the point-in-poly check
					// since that's far more expensive
					var loc Tint64_t = Tint64_t(hex % TH3Index(*(*Tint64_t)(unsafe.Pointer(bp))))
					var loopCount Tint64_t = int64(0)
					for *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) != uint64(0) {
						// If this branch is reached, we have exceeded the maximum
						// number of hexagons possible and need to clean up the
						// allocated memory.
						// TODO: Reachable via fuzzer
						if loopCount > *(*Tint64_t)(unsafe.Pointer(bp)) {
							libc.Xfree(tls, search)
							libc.Xfree(tls, found)
							libc.Xfree(tls, bboxes)
							return E_FAILED
						}
						if *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
							break
						} // Skip duplicates found
						loc = (loc + int64(1)) % *(*Tint64_t)(unsafe.Pointer(bp))
						loopCount++
					}
					if *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
						continue // Skip this hex, already exists in the out hash
					}

					// Check if the hexagon is in the polygon or not
					// var hexCenter TLatLng at bp+88, 16

					XcellToLatLng(tls, hex, bp+88)

					// If not, skip
					if !(XpointInsidePolygon(tls, geoPolygon, bboxes, bp+88) != 0) {
						continue
					}

					// Otherwise set it in the output array
					*(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) = hex

					// Set the hexagon in the found hash
					*(*TH3Index)(unsafe.Pointer(found + uintptr(numFoundHexes)*8)) = hex
					numFoundHexes++
				}
			}
			currentSearchNum++
			i++
		}

		// Swap the search and found pointers, copy the found hex count to the
		// search hex count, and zero everything related to the found memory.
		var temp uintptr = search
		search = found
		found = temp
		{
			var j Tint64_t = int64(0)
			for ; j < *(*Tint64_t)(unsafe.Pointer(bp + 24)); j++ {
				*(*TH3Index)(unsafe.Pointer(found + uintptr(j)*8)) = uint64(0)
			}
		}
		*(*Tint64_t)(unsafe.Pointer(bp + 24 /* numSearchHexes */)) = numFoundHexes
		numFoundHexes = int64(0)
		// Repeat until no new hexagons are found
	}
	// The out memory structure should be complete, end it here
	libc.Xfree(tls, bboxes)
	libc.Xfree(tls, search)
	libc.Xfree(tls, found)
	return E_SUCCESS
}

// *
// Internal: Create a vertex graph from a set of hexagons. It is the
// responsibility of the caller to call destroyVertexGraph on the populated
// graph, otherwise the memory in the graph nodes will not be freed.
// @private
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in the set
// @param graph    Output graph
func Xh3SetToVertexGraph(tls *libc.TLS, h3Set uintptr, numHexes int32, graph uintptr) TH3Error { /* algos.c:1075:9: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var vertices TCellBoundary at bp, 168

	var fromVtx uintptr
	var toVtx uintptr
	var edge uintptr
	if numHexes < 1 {
		// We still need to init the graph, or calls to destroyVertexGraph will
		// fail
		XinitVertexGraph(tls, graph, 0, 0)
		return E_SUCCESS
	}
	var res int32 = int32(*(*TH3Index)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var minBuckets int32 = 6
	// TODO: Better way to calculate/guess?
	var numBuckets int32
	if numHexes > minBuckets {
		numBuckets = numHexes
	} else {
		numBuckets = minBuckets
	}
	XinitVertexGraph(tls, graph, numBuckets, res)
	// Iterate through every hexagon
	{
		var i int32 = 0
		for ; i < numHexes; i++ {
			var boundaryErr TH3Error = XcellToBoundary(tls, *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8)), bp)
			if boundaryErr != 0 {
				// Destroy vertex graph as caller will not know to do so.
				XdestroyVertexGraph(tls, graph)
				return boundaryErr
			}
			// iterate through every edge
			{
				var j int32 = 0
				for ; j < (*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts; j++ {
					fromVtx = bp + 8 + uintptr(j)*16
					toVtx = bp + 8 + uintptr((j+1)%(*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts)*16
					// If we've seen this edge already, it will be reversed
					edge = XfindNodeForEdge(tls, graph, toVtx, fromVtx)
					if edge != uintptr(0) {
						// If we've seen it, drop it. No edge is shared by more than 2
						// hexagons, so we'll never see it again.
						XremoveVertexNode(tls, graph, edge)
					} else {
						// Add a new node for this edge
						XaddVertexNode(tls, graph, fromVtx, toVtx)
					}
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Internal: Create a LinkedGeoPolygon from a vertex graph. It is the
// responsibility of the caller to call destroyLinkedMultiPolygon on the
// populated linked geo structure, or the memory for that structure will not be
// freed.
// @private
// @param graph Input graph
// @param out   Output polygon
func X_vertexGraphToLinkedGeo(tls *libc.TLS, graph uintptr, out uintptr) { /* algos.c:1128:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TLinkedGeoPolygon)(unsafe.Pointer(out)) = TLinkedGeoPolygon{}
	var loop uintptr
	var edge uintptr
	// var nextVtx TLatLng at bp, 16

	// Find the next unused entry point
	for libc.AssignUintptr(&edge, XfirstVertexNode(tls, graph)) != uintptr(0) {
		loop = XaddNewLinkedLoop(tls, out)
		// Walk the graph to get the outline
		for __ccgo := true; __ccgo; __ccgo = edge != 0 {
			XaddLinkedCoord(tls, loop, edge)
			*(*TLatLng)(unsafe.Pointer(bp /* nextVtx */)) = (*TVertexNode)(unsafe.Pointer(edge)).Fto
			// Remove frees the node, so we can't use edge after this
			XremoveVertexNode(tls, graph, edge)
			edge = XfindNodeForVertex(tls, graph, bp)
		}
	}
}

// *
// Create a LinkedGeoPolygon describing the outline(s) of a set of  hexagons.
// Polygon outlines will follow GeoJSON MultiPolygon order: Each polygon will
// have one outer loop, which is first in the list, followed by any holes.
//
// It is the responsibility of the caller to call destroyLinkedMultiPolygon on
// the populated linked geo structure, or the memory for that structure will not
// be freed.
//
// It is expected that all hexagons in the set have the same resolution and
// that the set contains no duplicates. Behavior is undefined if duplicates
// or multiple resolutions are present, and the algorithm may produce
// unexpected or invalid output.
//
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in set
// @param out      Output polygon
func XcellsToLinkedMultiPolygon(tls *libc.TLS, h3Set uintptr, numHexes int32, out uintptr) TH3Error { /* algos.c:1165:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var graph TVertexGraph at bp, 24

	var err TH3Error = Xh3SetToVertexGraph(tls, h3Set, numHexes, bp)
	if err != 0 {
		return err
	}
	X_vertexGraphToLinkedGeo(tls, bp, out)
	XdestroyVertexGraph(tls, bp)
	var normalizeResult TH3Error = XnormalizeMultiPolygon(tls, out)
	if normalizeResult != 0 {
		XdestroyLinkedMultiPolygon(tls, out)
	}
	return normalizeResult
}

//   - @struct BaseCellRotation
//     @brief base cell at a given ijk and required rotations into its system
type TBaseCellRotation = struct {
	FbaseCell int32
	FccwRot60 int32
} /* baseCells.c:31:3 */

// * @brief Neighboring base cell ID in each IJK direction.
//
// For each base cell, for each direction, the neighboring base
// cell ID is given. 127 indicates there is no neighbor in that direction.
var XbaseCellNeighbors = [122][7]int32{
	{0, 1, 5, 2, 4, 3, 8},                          // base cell 0
	{1, 7, 6, 9, 0, 3, 2},                          // base cell 1
	{2, 6, 10, 11, 0, 1, 5},                        // base cell 2
	{3, 13, 1, 7, 4, 12, 0},                        // base cell 3
	{4, DINVALID_BASE_CELL, 15, 8, 3, 0, 12},       // base cell 4 (pentagon)
	{5, 2, 18, 10, 8, 0, 16},                       // base cell 5
	{6, 14, 11, 17, 1, 9, 2},                       // base cell 6
	{7, 21, 9, 19, 3, 13, 1},                       // base cell 7
	{8, 5, 22, 16, 4, 0, 15},                       // base cell 8
	{9, 19, 14, 20, 1, 7, 6},                       // base cell 9
	{10, 11, 24, 23, 5, 2, 18},                     // base cell 10
	{11, 17, 23, 25, 2, 6, 10},                     // base cell 11
	{12, 28, 13, 26, 4, 15, 3},                     // base cell 12
	{13, 26, 21, 29, 3, 12, 7},                     // base cell 13
	{14, DINVALID_BASE_CELL, 17, 27, 9, 20, 6},     // base cell 14 (pentagon)
	{15, 22, 28, 31, 4, 8, 12},                     // base cell 15
	{16, 18, 33, 30, 8, 5, 22},                     // base cell 16
	{17, 11, 14, 6, 35, 25, 27},                    // base cell 17
	{18, 24, 30, 32, 5, 10, 16},                    // base cell 18
	{19, 34, 20, 36, 7, 21, 9},                     // base cell 19
	{20, 14, 19, 9, 40, 27, 36},                    // base cell 20
	{21, 38, 19, 34, 13, 29, 7},                    // base cell 21
	{22, 16, 41, 33, 15, 8, 31},                    // base cell 22
	{23, 24, 11, 10, 39, 37, 25},                   // base cell 23
	{24, DINVALID_BASE_CELL, 32, 37, 10, 23, 18},   // base cell 24 (pentagon)
	{25, 23, 17, 11, 45, 39, 35},                   // base cell 25
	{26, 42, 29, 43, 12, 28, 13},                   // base cell 26
	{27, 40, 35, 46, 14, 20, 17},                   // base cell 27
	{28, 31, 42, 44, 12, 15, 26},                   // base cell 28
	{29, 43, 38, 47, 13, 26, 21},                   // base cell 29
	{30, 32, 48, 50, 16, 18, 33},                   // base cell 30
	{31, 41, 44, 53, 15, 22, 28},                   // base cell 31
	{32, 30, 24, 18, 52, 50, 37},                   // base cell 32
	{33, 30, 49, 48, 22, 16, 41},                   // base cell 33
	{34, 19, 38, 21, 54, 36, 51},                   // base cell 34
	{35, 46, 45, 56, 17, 27, 25},                   // base cell 35
	{36, 20, 34, 19, 55, 40, 54},                   // base cell 36
	{37, 39, 52, 57, 24, 23, 32},                   // base cell 37
	{38, DINVALID_BASE_CELL, 34, 51, 29, 47, 21},   // base cell 38 (pentagon)
	{39, 37, 25, 23, 59, 57, 45},                   // base cell 39
	{40, 27, 36, 20, 60, 46, 55},                   // base cell 40
	{41, 49, 53, 61, 22, 33, 31},                   // base cell 41
	{42, 58, 43, 62, 28, 44, 26},                   // base cell 42
	{43, 62, 47, 64, 26, 42, 29},                   // base cell 43
	{44, 53, 58, 65, 28, 31, 42},                   // base cell 44
	{45, 39, 35, 25, 63, 59, 56},                   // base cell 45
	{46, 60, 56, 68, 27, 40, 35},                   // base cell 46
	{47, 38, 43, 29, 69, 51, 64},                   // base cell 47
	{48, 49, 30, 33, 67, 66, 50},                   // base cell 48
	{49, DINVALID_BASE_CELL, 61, 66, 33, 48, 41},   // base cell 49 (pentagon)
	{50, 48, 32, 30, 70, 67, 52},                   // base cell 50
	{51, 69, 54, 71, 38, 47, 34},                   // base cell 51
	{52, 57, 70, 74, 32, 37, 50},                   // base cell 52
	{53, 61, 65, 75, 31, 41, 44},                   // base cell 53
	{54, 71, 55, 73, 34, 51, 36},                   // base cell 54
	{55, 40, 54, 36, 72, 60, 73},                   // base cell 55
	{56, 68, 63, 77, 35, 46, 45},                   // base cell 56
	{57, 59, 74, 78, 37, 39, 52},                   // base cell 57
	{58, DINVALID_BASE_CELL, 62, 76, 44, 65, 42},   // base cell 58 (pentagon)
	{59, 63, 78, 79, 39, 45, 57},                   // base cell 59
	{60, 72, 68, 80, 40, 55, 46},                   // base cell 60
	{61, 53, 49, 41, 81, 75, 66},                   // base cell 61
	{62, 43, 58, 42, 82, 64, 76},                   // base cell 62
	{63, DINVALID_BASE_CELL, 56, 45, 79, 59, 77},   // base cell 63 (pentagon)
	{64, 47, 62, 43, 84, 69, 82},                   // base cell 64
	{65, 58, 53, 44, 86, 76, 75},                   // base cell 65
	{66, 67, 81, 85, 49, 48, 61},                   // base cell 66
	{67, 66, 50, 48, 87, 85, 70},                   // base cell 67
	{68, 56, 60, 46, 90, 77, 80},                   // base cell 68
	{69, 51, 64, 47, 89, 71, 84},                   // base cell 69
	{70, 67, 52, 50, 83, 87, 74},                   // base cell 70
	{71, 89, 73, 91, 51, 69, 54},                   // base cell 71
	{72, DINVALID_BASE_CELL, 73, 55, 80, 60, 88},   // base cell 72 (pentagon)
	{73, 91, 72, 88, 54, 71, 55},                   // base cell 73
	{74, 78, 83, 92, 52, 57, 70},                   // base cell 74
	{75, 65, 61, 53, 94, 86, 81},                   // base cell 75
	{76, 86, 82, 96, 58, 65, 62},                   // base cell 76
	{77, 63, 68, 56, 93, 79, 90},                   // base cell 77
	{78, 74, 59, 57, 95, 92, 79},                   // base cell 78
	{79, 78, 63, 59, 93, 95, 77},                   // base cell 79
	{80, 68, 72, 60, 99, 90, 88},                   // base cell 80
	{81, 85, 94, 101, 61, 66, 75},                  // base cell 81
	{82, 96, 84, 98, 62, 76, 64},                   // base cell 82
	{83, DINVALID_BASE_CELL, 74, 70, 100, 87, 92},  // base cell 83 (pentagon)
	{84, 69, 82, 64, 97, 89, 98},                   // base cell 84
	{85, 87, 101, 102, 66, 67, 81},                 // base cell 85
	{86, 76, 75, 65, 104, 96, 94},                  // base cell 86
	{87, 83, 102, 100, 67, 70, 85},                 // base cell 87
	{88, 72, 91, 73, 99, 80, 105},                  // base cell 88
	{89, 97, 91, 103, 69, 84, 71},                  // base cell 89
	{90, 77, 80, 68, 106, 93, 99},                  // base cell 90
	{91, 73, 89, 71, 105, 88, 103},                 // base cell 91
	{92, 83, 78, 74, 108, 100, 95},                 // base cell 92
	{93, 79, 90, 77, 109, 95, 106},                 // base cell 93
	{94, 86, 81, 75, 107, 104, 101},                // base cell 94
	{95, 92, 79, 78, 109, 108, 93},                 // base cell 95
	{96, 104, 98, 110, 76, 86, 82},                 // base cell 96
	{97, DINVALID_BASE_CELL, 98, 84, 103, 89, 111}, // base cell 97 (pentagon)
	{98, 110, 97, 111, 82, 96, 84},                 // base cell 98
	{99, 80, 105, 88, 106, 90, 113},                // base cell 99
	{100, 102, 83, 87, 108, 114, 92},               // base cell 100
	{101, 102, 107, 112, 81, 85, 94},               // base cell 101
	{102, 101, 87, 85, 114, 112, 100},              // base cell 102
	{103, 91, 97, 89, 116, 105, 111},               // base cell 103
	{104, 107, 110, 115, 86, 94, 96},               // base cell 104
	{105, 88, 103, 91, 113, 99, 116},               // base cell 105
	{106, 93, 99, 90, 117, 109, 113},               // base cell 106
	{107, DINVALID_BASE_CELL, 101, 94, 115, 104,
		112}, // base cell 107 (pentagon)
	{108, 100, 95, 92, 118, 114, 109},   // base cell 108
	{109, 108, 93, 95, 117, 118, 106},   // base cell 109
	{110, 98, 104, 96, 119, 111, 115},   // base cell 110
	{111, 97, 110, 98, 116, 103, 119},   // base cell 111
	{112, 107, 102, 101, 120, 115, 114}, // base cell 112
	{113, 99, 116, 105, 117, 106, 121},  // base cell 113
	{114, 112, 100, 102, 118, 120, 108}, // base cell 114
	{115, 110, 107, 104, 120, 119, 112}, // base cell 115
	{116, 103, 119, 111, 113, 105, 121}, // base cell 116
	{117, DINVALID_BASE_CELL, 109, 118, 113, 121,
		106}, // base cell 117 (pentagon)
	{118, 120, 108, 114, 117, 121, 109}, // base cell 118
	{119, 111, 115, 110, 121, 116, 120}, // base cell 119
	{120, 115, 114, 112, 121, 119, 118}, // base cell 120
	{121, 116, 120, 119, 117, 113, 118}, // base cell 121
} /* baseCells.c:38:11 */

// * @brief Neighboring base cell rotations in each IJK direction.
//
// For each base cell, for each direction, the number of 60 degree
// CCW rotations to the coordinate system of the neighbor is given.
// -1 indicates there is no neighbor in that direction.
var XbaseCellNeighbor60CCWRots = [122][7]int32{
	{0, 5, 0, 0, 1, 5, 1},  // base cell 0
	{0, 0, 1, 0, 1, 0, 1},  // base cell 1
	{0, 0, 0, 0, 0, 5, 0},  // base cell 2
	{0, 5, 0, 0, 2, 5, 1},  // base cell 3
	{0, -1, 1, 0, 3, 4, 2}, // base cell 4 (pentagon)
	{0, 0, 1, 0, 1, 0, 1},  // base cell 5
	{0, 0, 0, 3, 5, 5, 0},  // base cell 6
	{0, 0, 0, 0, 0, 5, 0},  // base cell 7
	{0, 5, 0, 0, 0, 5, 1},  // base cell 8
	{0, 0, 1, 3, 0, 0, 1},  // base cell 9
	{0, 0, 1, 3, 0, 0, 1},  // base cell 10
	{0, 3, 3, 3, 0, 0, 0},  // base cell 11
	{0, 5, 0, 0, 3, 5, 1},  // base cell 12
	{0, 0, 1, 0, 1, 0, 1},  // base cell 13
	{0, -1, 3, 0, 5, 2, 0}, // base cell 14 (pentagon)
	{0, 5, 0, 0, 4, 5, 1},  // base cell 15
	{0, 0, 0, 0, 0, 5, 0},  // base cell 16
	{0, 3, 3, 3, 3, 0, 3},  // base cell 17
	{0, 0, 0, 3, 5, 5, 0},  // base cell 18
	{0, 3, 3, 3, 0, 0, 0},  // base cell 19
	{0, 3, 3, 3, 0, 3, 0},  // base cell 20
	{0, 0, 0, 3, 5, 5, 0},  // base cell 21
	{0, 0, 1, 0, 1, 0, 1},  // base cell 22
	{0, 3, 3, 3, 0, 3, 0},  // base cell 23
	{0, -1, 3, 0, 5, 2, 0}, // base cell 24 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 25
	{0, 0, 0, 0, 0, 5, 0},  // base cell 26
	{0, 3, 0, 0, 0, 3, 3},  // base cell 27
	{0, 0, 1, 0, 1, 0, 1},  // base cell 28
	{0, 0, 1, 3, 0, 0, 1},  // base cell 29
	{0, 3, 3, 3, 0, 0, 0},  // base cell 30
	{0, 0, 0, 0, 0, 5, 0},  // base cell 31
	{0, 3, 3, 3, 3, 0, 3},  // base cell 32
	{0, 0, 1, 3, 0, 0, 1},  // base cell 33
	{0, 3, 3, 3, 3, 0, 3},  // base cell 34
	{0, 0, 3, 0, 3, 0, 3},  // base cell 35
	{0, 0, 0, 3, 0, 0, 3},  // base cell 36
	{0, 3, 0, 0, 0, 3, 3},  // base cell 37
	{0, -1, 3, 0, 5, 2, 0}, // base cell 38 (pentagon)
	{0, 3, 0, 0, 3, 3, 0},  // base cell 39
	{0, 3, 0, 0, 3, 3, 0},  // base cell 40
	{0, 0, 0, 3, 5, 5, 0},  // base cell 41
	{0, 0, 0, 3, 5, 5, 0},  // base cell 42
	{0, 3, 3, 3, 0, 0, 0},  // base cell 43
	{0, 0, 1, 3, 0, 0, 1},  // base cell 44
	{0, 0, 3, 0, 0, 3, 3},  // base cell 45
	{0, 0, 0, 3, 0, 3, 0},  // base cell 46
	{0, 3, 3, 3, 0, 3, 0},  // base cell 47
	{0, 3, 3, 3, 0, 3, 0},  // base cell 48
	{0, -1, 3, 0, 5, 2, 0}, // base cell 49 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 50
	{0, 3, 0, 0, 0, 3, 3},  // base cell 51
	{0, 0, 3, 0, 3, 0, 3},  // base cell 52
	{0, 3, 3, 3, 0, 0, 0},  // base cell 53
	{0, 0, 3, 0, 3, 0, 3},  // base cell 54
	{0, 0, 3, 0, 0, 3, 3},  // base cell 55
	{0, 3, 3, 3, 0, 0, 3},  // base cell 56
	{0, 0, 0, 3, 0, 3, 0},  // base cell 57
	{0, -1, 3, 0, 5, 2, 0}, // base cell 58 (pentagon)
	{0, 3, 3, 3, 3, 3, 0},  // base cell 59
	{0, 3, 3, 3, 3, 3, 0},  // base cell 60
	{0, 3, 3, 3, 3, 0, 3},  // base cell 61
	{0, 3, 3, 3, 3, 0, 3},  // base cell 62
	{0, -1, 3, 0, 5, 2, 0}, // base cell 63 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 64
	{0, 3, 3, 3, 0, 3, 0},  // base cell 65
	{0, 3, 0, 0, 0, 3, 3},  // base cell 66
	{0, 3, 0, 0, 3, 3, 0},  // base cell 67
	{0, 3, 3, 3, 0, 0, 0},  // base cell 68
	{0, 3, 0, 0, 3, 3, 0},  // base cell 69
	{0, 0, 3, 0, 0, 3, 3},  // base cell 70
	{0, 0, 0, 3, 0, 3, 0},  // base cell 71
	{0, -1, 3, 0, 5, 2, 0}, // base cell 72 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 73
	{0, 3, 3, 3, 0, 0, 3},  // base cell 74
	{0, 0, 0, 3, 0, 0, 3},  // base cell 75
	{0, 3, 0, 0, 0, 3, 3},  // base cell 76
	{0, 0, 0, 3, 0, 5, 0},  // base cell 77
	{0, 3, 3, 3, 0, 0, 0},  // base cell 78
	{0, 0, 1, 3, 1, 0, 1},  // base cell 79
	{0, 0, 1, 3, 1, 0, 1},  // base cell 80
	{0, 0, 3, 0, 3, 0, 3},  // base cell 81
	{0, 0, 3, 0, 3, 0, 3},  // base cell 82
	{0, -1, 3, 0, 5, 2, 0}, // base cell 83 (pentagon)
	{0, 0, 3, 0, 0, 3, 3},  // base cell 84
	{0, 0, 0, 3, 0, 3, 0},  // base cell 85
	{0, 3, 0, 0, 3, 3, 0},  // base cell 86
	{0, 3, 3, 3, 3, 3, 0},  // base cell 87
	{0, 0, 0, 3, 0, 5, 0},  // base cell 88
	{0, 3, 3, 3, 3, 3, 0},  // base cell 89
	{0, 0, 0, 0, 0, 0, 1},  // base cell 90
	{0, 3, 3, 3, 0, 0, 0},  // base cell 91
	{0, 0, 0, 3, 0, 5, 0},  // base cell 92
	{0, 5, 0, 0, 5, 5, 0},  // base cell 93
	{0, 0, 3, 0, 0, 3, 3},  // base cell 94
	{0, 0, 0, 0, 0, 0, 1},  // base cell 95
	{0, 0, 0, 3, 0, 3, 0},  // base cell 96
	{0, -1, 3, 0, 5, 2, 0}, // base cell 97 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 98
	{0, 5, 0, 0, 5, 5, 0},  // base cell 99
	{0, 0, 1, 3, 1, 0, 1},  // base cell 100
	{0, 3, 3, 3, 0, 0, 3},  // base cell 101
	{0, 3, 3, 3, 0, 0, 0},  // base cell 102
	{0, 0, 1, 3, 1, 0, 1},  // base cell 103
	{0, 3, 3, 3, 3, 3, 0},  // base cell 104
	{0, 0, 0, 0, 0, 0, 1},  // base cell 105
	{0, 0, 1, 0, 3, 5, 1},  // base cell 106
	{0, -1, 3, 0, 5, 2, 0}, // base cell 107 (pentagon)
	{0, 5, 0, 0, 5, 5, 0},  // base cell 108
	{0, 0, 1, 0, 4, 5, 1},  // base cell 109
	{0, 3, 3, 3, 0, 0, 0},  // base cell 110
	{0, 0, 0, 3, 0, 5, 0},  // base cell 111
	{0, 0, 0, 3, 0, 5, 0},  // base cell 112
	{0, 0, 1, 0, 2, 5, 1},  // base cell 113
	{0, 0, 0, 0, 0, 0, 1},  // base cell 114
	{0, 0, 1, 3, 1, 0, 1},  // base cell 115
	{0, 5, 0, 0, 5, 5, 0},  // base cell 116
	{0, -1, 1, 0, 3, 4, 2}, // base cell 117 (pentagon)
	{0, 0, 1, 0, 0, 5, 1},  // base cell 118
	{0, 0, 0, 0, 0, 0, 1},  // base cell 119
	{0, 5, 0, 0, 5, 5, 0},  // base cell 120
	{0, 0, 1, 0, 1, 5, 1},  // base cell 121
} /* baseCells.c:171:11 */

// * @brief Resolution 0 base cell lookup table for each face.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, gives the base cell located at that
// coordinate and the number of 60 ccw rotations to rotate into that base
// cell's orientation.
//
// Valid lookup coordinates are from (0, 0, 0) to (2, 2, 2).
//
// This table can be accessed using the functions `_faceIjkToBaseCell` and
// `_faceIjkToBaseCellCCWrot60`
var faceIjkBaseCells = [20][3][3][3]TBaseCellRotation{{
	{{{FbaseCell: 16}, {FbaseCell: 18}, {FbaseCell: 24}}, // j 0
		{{FbaseCell: 33}, {FbaseCell: 30}, {FbaseCell: 32, FccwRot60: 3}}, // j 1
		{{FbaseCell: 49, FccwRot60: 1}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}},
	{
		{
			// i 1
			{FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}, {FbaseCell: 10, FccwRot60: 5}}, // j 0
		{{FbaseCell: 22}, {FbaseCell: 16}, {FbaseCell: 18}}, // j 1
		{{FbaseCell: 41, FccwRot60: 1}, {FbaseCell: 33}, {FbaseCell: 30}}},
	{
		{
			// i 2
			{FbaseCell: 4}, {FccwRot60: 5}, {FbaseCell: 2, FccwRot60: 5}}, // j 0
		{{FbaseCell: 15, FccwRot60: 1}, {FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}}, // j 1
		{{FbaseCell: 31, FccwRot60: 1}, {FbaseCell: 22}, {FbaseCell: 16}}}},
	{
		{ // face 1
			{
				{FbaseCell: 2}, {FbaseCell: 6}, {FbaseCell: 14}}, // j 0
			{{FbaseCell: 10}, {FbaseCell: 11}, {FbaseCell: 17, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 1}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}},
		{
			{
				// i 1
				{}, {FbaseCell: 1, FccwRot60: 5}, {FbaseCell: 9, FccwRot60: 5}}, // j 0
			{{FbaseCell: 5}, {FbaseCell: 2}, {FbaseCell: 6}}, // j 1
			{{FbaseCell: 18, FccwRot60: 1}, {FbaseCell: 10}, {FbaseCell: 11}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 1}, {FbaseCell: 3, FccwRot60: 5}, {FbaseCell: 7, FccwRot60: 5}}, // j 0
			{{FbaseCell: 8, FccwRot60: 1}, {}, {FbaseCell: 1, FccwRot60: 5}}, // j 1
			{{FbaseCell: 16, FccwRot60: 1}, {FbaseCell: 5}, {FbaseCell: 2}}}},
	{
		{ // face 2
			{
				{FbaseCell: 7}, {FbaseCell: 21}, {FbaseCell: 38}}, // j 0
			{{FbaseCell: 9}, {FbaseCell: 19}, {FbaseCell: 34, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 1}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}, {FbaseCell: 29, FccwRot60: 5}}, // j 0
			{{FbaseCell: 1}, {FbaseCell: 7}, {FbaseCell: 21}}, // j 1
			{{FbaseCell: 6, FccwRot60: 1}, {FbaseCell: 9}, {FbaseCell: 19}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 2}, {FbaseCell: 12, FccwRot60: 5}, {FbaseCell: 26, FccwRot60: 5}}, // j 0
			{{FccwRot60: 1}, {FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}}, // j 1
			{{FbaseCell: 2, FccwRot60: 1}, {FbaseCell: 1}, {FbaseCell: 7}}}},
	{
		{ // face 3
			{
				{FbaseCell: 26}, {FbaseCell: 42}, {FbaseCell: 58}}, // j 0
			{{FbaseCell: 29}, {FbaseCell: 43}, {FbaseCell: 62, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 1}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}, {FbaseCell: 44, FccwRot60: 5}}, // j 0
			{{FbaseCell: 13}, {FbaseCell: 26}, {FbaseCell: 42}}, // j 1
			{{FbaseCell: 21, FccwRot60: 1}, {FbaseCell: 29}, {FbaseCell: 43}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 3}, {FbaseCell: 15, FccwRot60: 5}, {FbaseCell: 31, FccwRot60: 5}}, // j 0
			{{FbaseCell: 3, FccwRot60: 1}, {FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}}, // j 1
			{{FbaseCell: 7, FccwRot60: 1}, {FbaseCell: 13}, {FbaseCell: 26}}}},
	{
		{ // face 4
			{
				{FbaseCell: 31}, {FbaseCell: 41}, {FbaseCell: 49}}, // j 0
			{{FbaseCell: 44}, {FbaseCell: 53}, {FbaseCell: 61, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 1}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}, {FbaseCell: 33, FccwRot60: 5}}, // j 0
			{{FbaseCell: 28}, {FbaseCell: 31}, {FbaseCell: 41}}, // j 1
			{{FbaseCell: 42, FccwRot60: 1}, {FbaseCell: 44}, {FbaseCell: 53}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 4}, {FbaseCell: 8, FccwRot60: 5}, {FbaseCell: 16, FccwRot60: 5}}, // j 0
			{{FbaseCell: 12, FccwRot60: 1}, {FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}}, // j 1
			{{FbaseCell: 26, FccwRot60: 1}, {FbaseCell: 28}, {FbaseCell: 31}}}},
	{
		{ // face 5
			{
				{FbaseCell: 50}, {FbaseCell: 48}, {FbaseCell: 49, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}, {FbaseCell: 33, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 3}, {FbaseCell: 18, FccwRot60: 3}, {FbaseCell: 16, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 70}, {FbaseCell: 67}, {FbaseCell: 66, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}, {FbaseCell: 48}}, // j 1
			{{FbaseCell: 37, FccwRot60: 3}, {FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 83}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74, FccwRot60: 3}, {FbaseCell: 70}, {FbaseCell: 67}}, // j 1
			{{FbaseCell: 57, FccwRot60: 1}, {FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}}}},
	{
		{ // face 6
			{
				{FbaseCell: 25}, {FbaseCell: 23}, {FbaseCell: 24, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}, {FbaseCell: 10, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 3}, {FbaseCell: 6, FccwRot60: 3}, {FbaseCell: 2, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 45}, {FbaseCell: 39}, {FbaseCell: 37, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}, {FbaseCell: 23}}, // j 1
			{{FbaseCell: 27, FccwRot60: 3}, {FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 63}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56, FccwRot60: 3}, {FbaseCell: 45}, {FbaseCell: 39}}, // j 1
			{{FbaseCell: 46, FccwRot60: 3}, {FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}}}},
	{
		{ // face 7
			{
				{FbaseCell: 36}, {FbaseCell: 20}, {FbaseCell: 14, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}, {FbaseCell: 9, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 3}, {FbaseCell: 21, FccwRot60: 3}, {FbaseCell: 7, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 55}, {FbaseCell: 40}, {FbaseCell: 27, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}, {FbaseCell: 20}}, // j 1
			{{FbaseCell: 51, FccwRot60: 3}, {FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 72}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73, FccwRot60: 3}, {FbaseCell: 55}, {FbaseCell: 40}}, // j 1
			{{FbaseCell: 71, FccwRot60: 3}, {FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}}}},
	{
		{ // face 8
			{
				{FbaseCell: 64}, {FbaseCell: 47}, {FbaseCell: 38, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}, {FbaseCell: 29, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 3}, {FbaseCell: 42, FccwRot60: 3}, {FbaseCell: 26, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 84}, {FbaseCell: 69}, {FbaseCell: 51, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}, {FbaseCell: 47}}, // j 1
			{{FbaseCell: 76, FccwRot60: 3}, {FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 97}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98, FccwRot60: 3}, {FbaseCell: 84}, {FbaseCell: 69}}, // j 1
			{{FbaseCell: 96, FccwRot60: 3}, {FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}}}},
	{
		{ // face 9
			{
				{FbaseCell: 75}, {FbaseCell: 65}, {FbaseCell: 58, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}, {FbaseCell: 44, FccwRot60: 3}}, // j 1
			{{FbaseCell: 49, FccwRot60: 3}, {FbaseCell: 41, FccwRot60: 3}, {FbaseCell: 31, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 94}, {FbaseCell: 86}, {FbaseCell: 76, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}, {FbaseCell: 65}}, // j 1
			{{FbaseCell: 66, FccwRot60: 3}, {FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 107}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101, FccwRot60: 3}, {FbaseCell: 94}, {FbaseCell: 86}}, // j 1
			{{FbaseCell: 85, FccwRot60: 3}, {FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}}}},
	{
		{ // face 10
			{
				{FbaseCell: 57}, {FbaseCell: 59}, {FbaseCell: 63, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}, {FbaseCell: 79, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 3}, {FbaseCell: 92, FccwRot60: 3}, {FbaseCell: 95, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}, {FbaseCell: 45, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52}, {FbaseCell: 57}, {FbaseCell: 59}}, // j 1
			{{FbaseCell: 70, FccwRot60: 3}, {FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 24}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32, FccwRot60: 3}, {FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}}, // j 1
			{{FbaseCell: 50, FccwRot60: 3}, {FbaseCell: 52}, {FbaseCell: 57}}}},
	{
		{ // face 11
			{
				{FbaseCell: 46}, {FbaseCell: 60}, {FbaseCell: 72, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}, {FbaseCell: 80, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 3}, {FbaseCell: 77, FccwRot60: 3}, {FbaseCell: 90, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}, {FbaseCell: 55, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35}, {FbaseCell: 46}, {FbaseCell: 60}}, // j 1
			{{FbaseCell: 45, FccwRot60: 3}, {FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 14}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17, FccwRot60: 3}, {FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}}, // j 1
			{{FbaseCell: 25, FccwRot60: 3}, {FbaseCell: 35}, {FbaseCell: 46}}}},
	{
		{ // face 12
			{
				{FbaseCell: 71}, {FbaseCell: 89}, {FbaseCell: 97, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}, {FbaseCell: 103, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 3}, {FbaseCell: 88, FccwRot60: 3}, {FbaseCell: 105, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}, {FbaseCell: 84, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54}, {FbaseCell: 71}, {FbaseCell: 89}}, // j 1
			{{FbaseCell: 55, FccwRot60: 3}, {FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 38}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34, FccwRot60: 3}, {FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}}, // j 1
			{{FbaseCell: 36, FccwRot60: 3}, {FbaseCell: 54}, {FbaseCell: 71}}}},
	{
		{ // face 13
			{
				{FbaseCell: 96}, {FbaseCell: 104}, {FbaseCell: 107, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}, {FbaseCell: 115, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 3}, {FbaseCell: 111, FccwRot60: 3}, {FbaseCell: 119, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}, {FbaseCell: 94, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82}, {FbaseCell: 96}, {FbaseCell: 104}}, // j 1
			{{FbaseCell: 84, FccwRot60: 3}, {FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 58}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62, FccwRot60: 3}, {FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}}, // j 1
			{{FbaseCell: 64, FccwRot60: 3}, {FbaseCell: 82}, {FbaseCell: 96}}}},
	{
		{ // face 14
			{
				{FbaseCell: 85}, {FbaseCell: 87}, {FbaseCell: 83, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}, {FbaseCell: 100, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 3}, {FbaseCell: 112, FccwRot60: 3}, {FbaseCell: 114, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}, {FbaseCell: 70, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81}, {FbaseCell: 85}, {FbaseCell: 87}}, // j 1
			{{FbaseCell: 94, FccwRot60: 3}, {FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 49}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61, FccwRot60: 3}, {FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}}, // j 1
			{{FbaseCell: 75, FccwRot60: 3}, {FbaseCell: 81}, {FbaseCell: 85}}}},
	{
		{ // face 15
			{
				{FbaseCell: 95}, {FbaseCell: 92}, {FbaseCell: 83}}, // j 0
			{{FbaseCell: 79}, {FbaseCell: 78}, {FbaseCell: 74, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 1}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 109}, {FbaseCell: 108}, {FbaseCell: 100, FccwRot60: 5}}, // j 0
			{{FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}, {FbaseCell: 92}}, // j 1
			{{FbaseCell: 77, FccwRot60: 1}, {FbaseCell: 79}, {FbaseCell: 78}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 4}, {FbaseCell: 118, FccwRot60: 5}, {FbaseCell: 114, FccwRot60: 5}}, // j 0
			{{FbaseCell: 106, FccwRot60: 1}, {FbaseCell: 109}, {FbaseCell: 108}}, // j 1
			{{FbaseCell: 90, FccwRot60: 1}, {FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}}}},
	{
		{ // face 16
			{
				{FbaseCell: 90}, {FbaseCell: 77}, {FbaseCell: 63}}, // j 0
			{{FbaseCell: 80}, {FbaseCell: 68}, {FbaseCell: 56, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 1}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 106}, {FbaseCell: 93}, {FbaseCell: 79, FccwRot60: 5}}, // j 0
			{{FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}, {FbaseCell: 77}}, // j 1
			{{FbaseCell: 88, FccwRot60: 1}, {FbaseCell: 80}, {FbaseCell: 68}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 3}, {FbaseCell: 109, FccwRot60: 5}, {FbaseCell: 95, FccwRot60: 5}}, // j 0
			{{FbaseCell: 113, FccwRot60: 1}, {FbaseCell: 106}, {FbaseCell: 93}}, // j 1
			{{FbaseCell: 105, FccwRot60: 1}, {FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}}}},
	{
		{ // face 17
			{
				{FbaseCell: 105}, {FbaseCell: 88}, {FbaseCell: 72}}, // j 0
			{{FbaseCell: 103}, {FbaseCell: 91}, {FbaseCell: 73, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 1}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 113}, {FbaseCell: 99}, {FbaseCell: 80, FccwRot60: 5}}, // j 0
			{{FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}, {FbaseCell: 88}}, // j 1
			{{FbaseCell: 111, FccwRot60: 1}, {FbaseCell: 103}, {FbaseCell: 91}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 2}, {FbaseCell: 106, FccwRot60: 5}, {FbaseCell: 90, FccwRot60: 5}}, // j 0
			{{FbaseCell: 121, FccwRot60: 1}, {FbaseCell: 113}, {FbaseCell: 99}}, // j 1
			{{FbaseCell: 119, FccwRot60: 1}, {FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}}}},
	{
		{ // face 18
			{
				{FbaseCell: 119}, {FbaseCell: 111}, {FbaseCell: 97}}, // j 0
			{{FbaseCell: 115}, {FbaseCell: 110}, {FbaseCell: 98, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 1}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 121}, {FbaseCell: 116}, {FbaseCell: 103, FccwRot60: 5}}, // j 0
			{{FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}, {FbaseCell: 111}}, // j 1
			{{FbaseCell: 112, FccwRot60: 1}, {FbaseCell: 115}, {FbaseCell: 110}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 1}, {FbaseCell: 113, FccwRot60: 5}, {FbaseCell: 105, FccwRot60: 5}}, // j 0
			{{FbaseCell: 118, FccwRot60: 1}, {FbaseCell: 121}, {FbaseCell: 116}}, // j 1
			{{FbaseCell: 114, FccwRot60: 1}, {FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}}}},
	{
		{ // face 19
			{
				{FbaseCell: 114}, {FbaseCell: 112}, {FbaseCell: 107}}, // j 0
			{{FbaseCell: 100}, {FbaseCell: 102}, {FbaseCell: 101, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 1}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 118}, {FbaseCell: 120}, {FbaseCell: 115, FccwRot60: 5}}, // j 0
			{{FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}, {FbaseCell: 112}}, // j 1
			{{FbaseCell: 92, FccwRot60: 1}, {FbaseCell: 100}, {FbaseCell: 102}}},
		{
			{
				// i 2
				{FbaseCell: 117}, {FbaseCell: 121, FccwRot60: 5}, {FbaseCell: 119, FccwRot60: 5}}, // j 0
			{{FbaseCell: 109, FccwRot60: 1}, {FbaseCell: 118}, {FbaseCell: 120}},                // j 1
			{{FbaseCell: 95, FccwRot60: 1}, {FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}}}}} /* baseCells.c:308:31 */

// * @brief Resolution 0 base cell data table.
//
// For each base cell, gives the "home" face and ijk+ coordinates on that face,
// whether or not the base cell is a pentagon. Additionally, if the base cell
// is a pentagon, the two cw offset rotation adjacent faces are given (-1
// indicates that no cw offset rotation faces exist for this base cell).
var XbaseCellData = [122]TBaseCellData{{

	FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1}}}, // base cell 0
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 1
	{FhomeFijk: TFaceIJK{Fface: 1}},                                                                           // base cell 2
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 3
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}},          // base cell 4
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 5
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fk: 1}}},                                                 // base cell 6
	{FhomeFijk: TFaceIJK{Fface: 2}},                                                                           // base cell 7
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1}}},                                                           // base cell 8
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 9
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 10
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                          // base cell 11
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 12
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 13
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{2, 6}}, // base cell 14
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 15
	{}, // base cell 16
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 17
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fk: 1}}},                                                             // base cell 18
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 19
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 20
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 21
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                                      // base cell 22
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 23
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{1, 5}},   // base cell 24
	{FhomeFijk: TFaceIJK{Fface: 6}},                                                                             // base cell 25
	{FhomeFijk: TFaceIJK{Fface: 3}},                                                                             // base cell 26
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 27
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                            // base cell 28
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 29
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                                      // base cell 30
	{FhomeFijk: TFaceIJK{Fface: 4}},                                                                             // base cell 31
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 32
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1}}},                                                             // base cell 33
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 34
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 35
	{FhomeFijk: TFaceIJK{Fface: 7}},                                                                             // base cell 36
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 37
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{3, 7}},   // base cell 38
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 39
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 40
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 41
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 42
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 43
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 44
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 45
	{FhomeFijk: TFaceIJK{Fface: 11}},                                                                            // base cell 46
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 47
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 48
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{0, 9}},   // base cell 49
	{FhomeFijk: TFaceIJK{Fface: 5}},                                                                             // base cell 50
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 51
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 52
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 53
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 54
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 55
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 56
	{FhomeFijk: TFaceIJK{Fface: 10}},                                                                            // base cell 57
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{4, 8}},   // base cell 58
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 59
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 60
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 61
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 62
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{11, 15}},  // base cell 63
	{FhomeFijk: TFaceIJK{Fface: 8}},                                                                             // base cell 64
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 65
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 66
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 67
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 68
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 69
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 70
	{FhomeFijk: TFaceIJK{Fface: 12}},                                                                            // base cell 71
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{12, 16}},  // base cell 72
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 73
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 74
	{FhomeFijk: TFaceIJK{Fface: 9}},                                                                             // base cell 75
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 76
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 77
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 78
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 79
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 80
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 81
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 82
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{10, 19}},  // base cell 83
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 84
	{FhomeFijk: TFaceIJK{Fface: 14}},                                                                            // base cell 85
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 86
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 87
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 88
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 89
	{FhomeFijk: TFaceIJK{Fface: 16}},                                                                            // base cell 90
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 91
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 92
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 93
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 94
	{FhomeFijk: TFaceIJK{Fface: 15}},                                                                            // base cell 95
	{FhomeFijk: TFaceIJK{Fface: 13}},                                                                            // base cell 96
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{13, 17}},  // base cell 97
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 98
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 99
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 100
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 101
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 102
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 103
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 104
	{FhomeFijk: TFaceIJK{Fface: 17}},                                                                            // base cell 105
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 106
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{14, 18}},  // base cell 107
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 108
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 109
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 110
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 111
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 112
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 113
	{FhomeFijk: TFaceIJK{Fface: 19}},                                                                            // base cell 114
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 115
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 116
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}}, // base cell 117
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 118
	{FhomeFijk: TFaceIJK{Fface: 18}},                                                                            // base cell 119
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 120
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1}}}}                                                  /* baseCells.c:697:20 */

// * @brief Return whether or not the indicated base cell is a pentagon.
func X_isBaseCellPentagon(tls *libc.TLS, baseCell int32) int32 { /* baseCells.c:824:5: */
	if baseCell < 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return Dfalse
	}
	return XbaseCellData[baseCell].FisPentagon
}

// * @brief Return whether the indicated base cell is a pentagon where all
// neighbors are oriented towards it.
func X_isBaseCellPolarPentagon(tls *libc.TLS, baseCell int32) uint8 { /* baseCells.c:834:6: */
	return uint8(libc.Bool32(baseCell == 4 || baseCell == 117))
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the base cell located at that
// coordinate.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCell(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:846:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FbaseCell
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the number of 60' ccw rotations
// to rotate into the coordinate system of the base cell at that coordinates.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCellCCWrot60(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:859:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FccwRot60
}

// * @brief Find the FaceIJK given a base cell.
func X_baseCellToFaceIjk(tls *libc.TLS, baseCell int32, h uintptr) { /* baseCells.c:866:6: */
	*(*TFaceIJK)(unsafe.Pointer(h)) = XbaseCellData[baseCell].FhomeFijk
}

// *
// @brief Given a base cell and the face it appears on, return
//
//	the number of 60' ccw rotations for that base cell's
//	coordinate system.
//
// @returns The number of rotations, or INVALID_ROTATIONS if the base
//
//	cell is not found on the given face
func X_baseCellToCCWrot60(tls *libc.TLS, baseCell int32, face int32) int32 { /* baseCells.c:877:5: */
	if face < 0 || face > DNUM_ICOSA_FACES {
		return -1
	}
	{
		var i int32 = 0
		for ; i < 3; i++ {
			{
				var j int32 = 0
				for ; j < 3; j++ {
					{
						var k int32 = 0
						for ; k < 3; k++ {
							if (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells))+uintptr(face)*216+uintptr(i)*72+uintptr(j)*24+uintptr(k)*8)).FbaseCell == baseCell {
								return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr(face)*216 + uintptr(i)*72 + uintptr(j)*24 + uintptr(k)*8)).FccwRot60
							}
						}
					}
				}
			}
		}
	}
	return -1
}

// * @brief Return whether or not the tested face is a cw offset face.
func X_baseCellIsCwOffset(tls *libc.TLS, baseCell int32, testFace int32) uint8 { /* baseCells.c:893:6: */
	return uint8(libc.Bool32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20)) == testFace || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20 + 1*4)) == testFace))
}

// * @brief Return the neighboring base cell in the given direction.
func X_getBaseCellNeighbor(tls *libc.TLS, baseCell int32, dir TDirection) int32 { /* baseCells.c:900:5: */
	return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(baseCell)*28 + uintptr(dir)*4))
}

// * @brief Return the direction from the origin base cell to the neighbor.
// Returns INVALID_DIGIT if the base cells are not neighbors.
func X_getBaseCellDirection(tls *libc.TLS, originBaseCell int32, neighboringBaseCell int32) TDirection { /* baseCells.c:907:11: */
	{
		var dir TDirection = CENTER_DIGIT
		for ; dir < NUM_DIGITS; dir++ {
			var testBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
			if testBaseCell == neighboringBaseCell {
				return dir
			}
		}
	}
	return INVALID_DIGIT
}

// *
// res0CellCount returns the number of resolution 0 cells
//
// @return int count of resolution 0 cells
func Xres0CellCount(tls *libc.TLS) int32 { /* baseCells.c:922:5: */
	return DNUM_BASE_CELLS
}

// *
// getRes0Cells generates all base cells storing them into the provided
// memory pointer. Buffer must be of size NUM_BASE_CELLS * sizeof(H3Index).
//
// @param out H3Index* the memory to store the resulting base cells in
// @returns E_SUCCESS.
func XgetRes0Cells(tls *libc.TLS, out uintptr) TH3Error { /* baseCells.c:931:9: */
	{
		var bc int32 = 0
		for ; bc < DNUM_BASE_CELLS; bc++ {
			var baseCell TH3Index = 35184372088831
			baseCell = baseCell&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
			baseCell = baseCell&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(bc)<<DH3_BC_OFFSET
			*(*TH3Index)(unsafe.Pointer(out + uintptr(bc)*8)) = baseCell
		}
	}
	return E_SUCCESS
}

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// *
// Whether the given bounding box crosses the antimeridian
// @param  bbox Bounding box to inspect
// @return      is transmeridian
func XbboxIsTransmeridian(tls *libc.TLS, bbox uintptr) uint8 { /* bbox.c:35:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(bbox)).Feast < (*TBBox)(unsafe.Pointer(bbox)).Fwest))
}

// *
// Get the center of a bounding box
// @param bbox   Input bounding box
// @param center Output center coordinate
func XbboxCenter(tls *libc.TLS, bbox uintptr, center uintptr) { /* bbox.c:42:6: */
	(*TLatLng)(unsafe.Pointer(center)).Flat = ((*TBBox)(unsafe.Pointer(bbox)).Fnorth + (*TBBox)(unsafe.Pointer(bbox)).Fsouth) / 2.0
	// If the bbox crosses the antimeridian, shift east 360 degrees
	var east float64
	if XbboxIsTransmeridian(tls, bbox) != 0 {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast + 6.28318530717958647692528676655900576839433
	} else {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast
	}
	(*TLatLng)(unsafe.Pointer(center)).Flng = XconstrainLng(tls, (east+(*TBBox)(unsafe.Pointer(bbox)).Fwest)/2.0)
}

// *
// Whether the bounding box contains a given point
// @param  bbox  Bounding box
// @param  point Point to test
// @return       Whether the point is contained
func XbboxContains(tls *libc.TLS, bbox uintptr, point uintptr) uint8 { /* bbox.c:55:6: */
	return uint8(libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flat >= (*TBBox)(unsafe.Pointer(bbox)).Fsouth && (*TLatLng)(unsafe.Pointer(point)).Flat <= (*TBBox)(unsafe.Pointer(bbox)).Fnorth && func() int32 {
		if XbboxIsTransmeridian(tls, bbox) != 0 {
			return libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flng >= (*TBBox)(unsafe.Pointer(bbox)).Fwest || (*TLatLng)(unsafe.Pointer(point)).Flng <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
		}
		return libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flng >= (*TBBox)(unsafe.Pointer(bbox)).Fwest && (*TLatLng)(unsafe.Pointer(point)).Flng <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
	}() != 0))
}

// *
// Whether two bounding boxes are strictly equal
// @param  b1 Bounding box 1
// @param  b2 Bounding box 2
// @return    Whether the boxes are equal
func XbboxEquals(tls *libc.TLS, b1 uintptr, b2 uintptr) uint8 { /* bbox.c:71:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(b1)).Fnorth == (*TBBox)(unsafe.Pointer(b2)).Fnorth && (*TBBox)(unsafe.Pointer(b1)).Fsouth == (*TBBox)(unsafe.Pointer(b2)).Fsouth && (*TBBox)(unsafe.Pointer(b1)).Feast == (*TBBox)(unsafe.Pointer(b2)).Feast && (*TBBox)(unsafe.Pointer(b1)).Fwest == (*TBBox)(unsafe.Pointer(b2)).Fwest))
}

// *
// _hexRadiusKm returns the radius of a given hexagon in Km
//
// @param h3Index the index of the hexagon
// @return the radius of the hexagon in Km
func X_hexRadiusKm(tls *libc.TLS, h3Index TH3Index) float64 { /* bbox.c:82:8: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// There is probably a cheaper way to determine the radius of a
	// hexagon, but this way is conceptually simple
	// var h3Center TLatLng at bp, 16

	// var h3Boundary TCellBoundary at bp+16, 168

	XcellToLatLng(tls, h3Index, bp)
	XcellToBoundary(tls, h3Index, bp+16)
	return XgreatCircleDistanceKm(tls, bp, bp+16+8)
}

// *
// bboxHexEstimate returns an estimated number of hexagons that fit
//
//	within the cartesian-projected bounding box
//
// @param bbox the bounding box to estimate the hexagon fill level
// @param res the resolution of the H3 hexagons to fill the bounding box
// @param out the estimated number of hexagons to fill the bounding box
// @return E_SUCCESS (0) on success, or another value otherwise.
func XbboxHexEstimate(tls *libc.TLS, bbox uintptr, res int32, out uintptr) TH3Error { /* bbox.c:101:9: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]TH3Index)(unsafe.Pointer(bp /* pentagons */)) = [12]TH3Index{0: uint64(0)}
	var pentagonsErr TH3Error = XgetPentagons(tls, res, bp)
	if pentagonsErr != 0 {
		return pentagonsErr
	}
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*TH3Index)(unsafe.Pointer(bp)))
	// Area of a regular hexagon is 3/2*sqrt(3) * r * r
	// The pentagon has the most distortion (smallest edges) and shares its
	// edges with hexagons, so the most-distorted hexagons have this area,
	// shrunk by 20% off chance that the bounding box perfectly bounds a
	// pentagon.
	var pentagonAreaKm2 float64 = 0.8 * (2.59807621135 * pentagonRadiusKm * pentagonRadiusKm)

	// Then get the area of the bounding box of the geoloop in question
	// var p1 TLatLng at bp+96, 16

	// var p2 TLatLng at bp+112, 16

	(*TLatLng)(unsafe.Pointer(bp + 96 /* &p1 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fnorth
	(*TLatLng)(unsafe.Pointer(bp + 96 /* &p1 */)).Flng = (*TBBox)(unsafe.Pointer(bbox)).Feast
	(*TLatLng)(unsafe.Pointer(bp + 112 /* &p2 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fsouth
	(*TLatLng)(unsafe.Pointer(bp + 112 /* &p2 */)).Flng = (*TBBox)(unsafe.Pointer(bbox)).Fwest
	var d float64 = XgreatCircleDistanceKm(tls, bp+96, bp+112)
	var lngDiff float64 = libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(bp+96)).Flng-(*TLatLng)(unsafe.Pointer(bp+112)).Flng)
	var latDiff float64 = libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(bp+96)).Flat-(*TLatLng)(unsafe.Pointer(bp+112)).Flat)
	if lngDiff == float64(0) || latDiff == float64(0) {
		return E_FAILED
	}
	var length float64 = Xfmax(tls, lngDiff, latDiff)
	var width float64 = Xfmin(tls, lngDiff, latDiff)
	var ratio float64 = length / width
	// Derived constant based on: https://math.stackexchange.com/a/1921940
	// Clamped to 3 as higher values tend to rapidly drag the estimate to zero.
	var a float64 = d * d / Xfmin(tls, 3.0, ratio)

	// Divide the two to get an estimate of the number of hexagons needed
	var estimateDouble float64 = libc.Xceil(tls, a/pentagonAreaKm2)
	if !(XisXfinite(tls, estimateDouble) != 0) {
		return E_FAILED
	}
	var estimate Tint64_t = Tint64_t(estimateDouble)
	if estimate == int64(0) {
		estimate = int64(1)
	}
	*(*Tint64_t)(unsafe.Pointer(out)) = estimate
	return E_SUCCESS
}

// *
// lineHexEstimate returns an estimated number of hexagons that trace
//
//	the cartesian-projected line
//
// @param origin the origin coordinates
// @param destination the destination coordinates
// @param res the resolution of the H3 hexagons to trace the line
// @param out Out parameter for the estimated number of hexagons required to
// trace the line
// @return E_SUCCESS (0) on success or another value otherwise.
func XlineHexEstimate(tls *libc.TLS, origin uintptr, destination uintptr, res int32, out uintptr) TH3Error { /* bbox.c:158:9: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]TH3Index)(unsafe.Pointer(bp /* pentagons */)) = [12]TH3Index{0: uint64(0)}
	var pentagonsErr TH3Error = XgetPentagons(tls, res, bp)
	if pentagonsErr != 0 {
		return pentagonsErr
	}
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*TH3Index)(unsafe.Pointer(bp)))

	var dist float64 = XgreatCircleDistanceKm(tls, origin, destination)
	var distCeil float64 = libc.Xceil(tls, dist/(float64(2)*pentagonRadiusKm))
	if !(XisXfinite(tls, distCeil) != 0) {
		return E_FAILED
	}
	var estimate Tint64_t = Tint64_t(distCeil)
	if estimate == int64(0) {
		estimate = int64(1)
	}
	*(*Tint64_t)(unsafe.Pointer(out)) = estimate
	return E_SUCCESS
}

// * @brief CoordIJK unit vectors corresponding to the 7 H3 digits.
var sUNIT_VECS3 = [7]TCoordIJK{
	{},             // direction 0
	{Fk: 1},        // direction 1
	{Fj: 1},        // direction 2
	{Fj: 1, Fk: 1}, // direction 3
	{Fi: 1},        // direction 4
	{Fi: 1, Fk: 1}, // direction 5
	{Fi: 1, Fj: 1}, // direction 6
} /* coordijk.h:50:23 */

// *
// Sets an IJK coordinate to the specified component values.
//
// @param ijk The IJK coordinate to set.
// @param i The desired i component value.
// @param j The desired j component value.
// @param k The desired k component value.
func X_setIJK(tls *libc.TLS, ijk uintptr, i int32, j int32, k int32) { /* coordijk.c:43:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = i
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = j
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = k
}

// *
// Determine the containing hex in ijk+ coordinates for a 2D cartesian
// coordinate vector (from DGGRID).
//
// @param v The 2D cartesian coordinate vector.
// @param h The ijk+ coordinates of the containing hex.
func X_hex2dToCoordIJK(tls *libc.TLS, v uintptr, h uintptr) { /* coordijk.c:56:6: */
	var a1 float64
	var a2 float64
	var x1 float64
	var x2 float64
	var m1 int32
	var m2 int32
	var r1 float64
	var r2 float64

	// quantize into the ij system and then normalize
	(*TCoordIJK)(unsafe.Pointer(h)).Fk = 0

	a1 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fx)
	a2 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fy)

	// first do a reverse conversion
	x2 = a2 / 0.8660254037844386467637231707529361834714
	x1 = a1 + x2/2.0

	// check if we have the center of a hex
	m1 = int32(x1)
	m2 = int32(x2)

	// otherwise round correctly
	r1 = x1 - float64(m1)
	r2 = x2 - float64(m2)

	if r1 < 0.5 {
		if r1 < float64(1.0)/3.0 {
			if r2 < (1.0+r1)/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		} else {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 1.0-r1 <= r2 && r2 < 2.0*r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			}
		}
	} else {
		if r1 < float64(2.0)/3.0 {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 2.0*r1-1.0 < r2 && r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			}
		} else {
			if r2 < r1/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		}
	}

	// now fold across the axes if necessary

	if (*TVec2d)(unsafe.Pointer(v)).Fx < 0.0 {
		if (*TCoordIJK)(unsafe.Pointer(h)).Fj%2 == 0 {
			var axisi int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fj / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - 2.0*float64(diff))
		} else {
			var axisi int64 = int64(((*TCoordIJK)(unsafe.Pointer(h)).Fj + 1) / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - (2.0*float64(diff) + float64(1)))
		}
	}

	if (*TVec2d)(unsafe.Pointer(v)).Fy < 0.0 {
		(*TCoordIJK)(unsafe.Pointer(h)).Fi = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (2*(*TCoordIJK)(unsafe.Pointer(h)).Fj+1)/2
		(*TCoordIJK)(unsafe.Pointer(h)).Fj = -1 * (*TCoordIJK)(unsafe.Pointer(h)).Fj
	}

	X_ijkNormalize(tls, h)
}

// *
// Find the center point in 2D cartesian coordinates of a hex.
//
// @param h The ijk coordinates of the hex.
// @param v The 2D cartesian coordinates of the hex center point.
func X_ijkToHex2d(tls *libc.TLS, h uintptr, v uintptr) { /* coordijk.c:155:6: */
	var i int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (*TCoordIJK)(unsafe.Pointer(h)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fj - (*TCoordIJK)(unsafe.Pointer(h)).Fk

	(*TVec2d)(unsafe.Pointer(v)).Fx = float64(i) - 0.5*float64(j)
	(*TVec2d)(unsafe.Pointer(v)).Fy = float64(j) * 0.8660254037844386467637231707529361834714
}

// *
// Returns whether or not two ijk coordinates contain exactly the same
// component values.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
// @return 1 if the two addresses match, 0 if they do not.
func X_ijkMatches(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:171:5: */
	return libc.Bool32((*TCoordIJK)(unsafe.Pointer(c1)).Fi == (*TCoordIJK)(unsafe.Pointer(c2)).Fi && (*TCoordIJK)(unsafe.Pointer(c1)).Fj == (*TCoordIJK)(unsafe.Pointer(c2)).Fj && (*TCoordIJK)(unsafe.Pointer(c1)).Fk == (*TCoordIJK)(unsafe.Pointer(c2)).Fk)
}

// *
// Add two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param sum The sum of the two sets of ijk coordinates.
func X_ijkAdd(tls *libc.TLS, h1 uintptr, h2 uintptr, sum uintptr) { /* coordijk.c:182:6: */
	(*TCoordIJK)(unsafe.Pointer(sum)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi + (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(sum)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj + (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(sum)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk + (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Subtract two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param diff The difference of the two sets of ijk coordinates (h1 - h2).
func X_ijkSub(tls *libc.TLS, h1 uintptr, h2 uintptr, diff uintptr) { /* coordijk.c:195:6: */
	(*TCoordIJK)(unsafe.Pointer(diff)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi - (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(diff)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj - (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(diff)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk - (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Uniformly scale ijk coordinates by a scalar. Works in place.
//
// @param c The ijk coordinates to scale.
// @param factor The scaling factor.
func X_ijkScale(tls *libc.TLS, c uintptr, factor int32) { /* coordijk.c:207:6: */
	*(*int32)(unsafe.Pointer(c)) *= factor
	*(*int32)(unsafe.Pointer(c + 4)) *= factor
	*(*int32)(unsafe.Pointer(c + 8)) *= factor
}

// *
// Returns true if _ijkNormalize with the given input could have a signed
// integer overflow. Assumes k is set to 0.
func X_ijkNormalizeCouldOverflow(tls *libc.TLS, ijk uintptr) uint8 { /* coordijk.c:217:6: */
	// Check for the possibility of overflow
	var max int32
	var min int32
	if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi > (*TCoordIJK)(unsafe.Pointer(ijk)).Fj {
		max = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi
		min = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
	} else {
		max = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
		min = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi
	}
	if min < 0 {
		// Only if the min is less than 0 will the resulting number be larger
		// than max. If min is positive, then max is also positive, and a
		// positive signed integer minus another positive signed integer will
		// not overflow.
		if func() int32 {
			if max > 0 {
				return libc.Bool32(2147483647-max < min)
			}
			return libc.Bool32(-2147483647-1-max > min)
		}() != 0 {
			// max + min would overflow
			return uint8(Dtrue)
		}
		if func() int32 {
			if 0 >= 0 {
				return libc.Bool32(-2147483647-1+0 >= min)
			}
			return libc.Bool32(2147483647+0+libc.Int32(1) < min)
		}() != 0 {
			// 0 - INT32_MIN would overflow
			return uint8(Dtrue)
		}
		if func() int32 {
			if max >= 0 {
				return libc.Bool32(-2147483647-1+max >= min)
			}
			return libc.Bool32(2147483647+max+1 < min)
		}() != 0 {
			// max - min would overflow
			return uint8(Dtrue)
		}
	}
	return uint8(Dfalse)
}

// *
// Normalizes ijk coordinates by setting the components to the smallest possible
// values. Works in place.
//
// This function does not protect against signed integer overflow. The caller
// must ensure that none of (i - j), (i - k), (j - i), (j - k), (k - i), (k - j)
// will overflow. This function may be changed in the future to make that check
// itself and return an error code.
//
// @param c The ijk coordinates to normalize.
func X_ijkNormalize(tls *libc.TLS, c uintptr) { /* coordijk.c:259:6: */
	// remove any negative values
	if (*TCoordIJK)(unsafe.Pointer(c)).Fi < 0 {
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		(*TCoordIJK)(unsafe.Pointer(c)).Fi = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		(*TCoordIJK)(unsafe.Pointer(c)).Fj = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		(*TCoordIJK)(unsafe.Pointer(c)).Fk = 0
	}

	// remove the min value if needed
	var min int32 = (*TCoordIJK)(unsafe.Pointer(c)).Fi
	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fj
	}
	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fk
	}
	if min > 0 {
		*(*int32)(unsafe.Pointer(c)) -= min
		*(*int32)(unsafe.Pointer(c + 4)) -= min
		*(*int32)(unsafe.Pointer(c + 8)) -= min
	}
}

// *
// Determines the H3 digit corresponding to a unit vector or the zero vector
// in ijk coordinates.
//
// @param ijk The ijk coordinates; must be a unit vector or zero vector.
// @return The H3 digit (0-6) corresponding to the ijk unit vector, zero vector,
// or INVALID_DIGIT (7) on failure.
func X_unitIjkToDigit(tls *libc.TLS, ijk uintptr) TDirection { /* coordijk.c:298:11: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*TCoordIJK)(unsafe.Pointer(bp /* c */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
	X_ijkNormalize(tls, bp)

	var digit TDirection = INVALID_DIGIT
	{
		var i TDirection = CENTER_DIGIT
		for ; i < NUM_DIGITS; i++ {
			if X_ijkMatches(tls, bp, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(i)*12) != 0 {
				digit = i
				break
			}
		}
	}

	return digit
}

// *
// Returns non-zero if _upAp7 with the given input could have a signed integer
// overflow.
//
// Assumes ijk is IJK+ coordinates (no negative numbers).
func X_upAp7Checked(tls *libc.TLS, ijk uintptr) TH3Error { /* coordijk.c:319:9: */
	// Doesn't need to be checked because i, j, and k must all be non-negative
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	// <0 is checked because the input must all be non-negative, but some
	// negative inputs are used in unit tests to exercise the below.
	if i >= 2147483647/3 || j >= 2147483647/3 || i < 0 || j < 0 {
		if func() int32 {
			if i > 0 {
				return libc.Bool32(2147483647-i < i)
			}
			return libc.Bool32(-2147483647-1-i > i)
		}() != 0 {
			return E_FAILED
		}
		var i2 int32 = i + i
		if func() int32 {
			if i2 > 0 {
				return libc.Bool32(2147483647-i2 < i)
			}
			return libc.Bool32(-2147483647-1-i2 > i)
		}() != 0 {
			return E_FAILED
		}
		var i3 int32 = i2 + i
		if func() int32 {
			if j > 0 {
				return libc.Bool32(2147483647-j < j)
			}
			return libc.Bool32(-2147483647-1-j > j)
		}() != 0 {
			return E_FAILED
		}
		var j2 int32 = j + j

		if func() int32 {
			if i3 >= 0 {
				return libc.Bool32(-2147483647-1+i3 >= j)
			}
			return libc.Bool32(2147483647+i3+1 < j)
		}() != 0 {
			return E_FAILED
		}
		if func() int32 {
			if i > 0 {
				return libc.Bool32(2147483647-i < j2)
			}
			return libc.Bool32(-2147483647-1-i > j2)
		}() != 0 {
			return E_FAILED
		}
	}

	// TODO: Do the int math parts here in long double?
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(i*3-j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(i+j*2)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	// Expected not to be reachable, because max + min or max - min would need
	// to overflow.
	if func() int32 {
		if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+47, uint32(355), uintptr(unsafe.Pointer(&__func__1)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return E_FAILED
	}
	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

var __func__1 = *(*[14]int8)(unsafe.Pointer(ts + 75)) /* coordijk.c:319:38 */

// *
// Returns non-zero if _upAp7r with the given input could have a signed integer
// overflow.
//
// Assumes ijk is IJK+ coordinates (no negative numbers).
func X_upAp7rChecked(tls *libc.TLS, ijk uintptr) TH3Error { /* coordijk.c:368:9: */
	// Doesn't need to be checked because i, j, and k must all be non-negative
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	// <0 is checked because the input must all be non-negative, but some
	// negative inputs are used in unit tests to exercise the below.
	if i >= 2147483647/3 || j >= 2147483647/3 || i < 0 || j < 0 {
		if func() int32 {
			if i > 0 {
				return libc.Bool32(2147483647-i < i)
			}
			return libc.Bool32(-2147483647-1-i > i)
		}() != 0 {
			return E_FAILED
		}
		var i2 int32 = i + i
		if func() int32 {
			if j > 0 {
				return libc.Bool32(2147483647-j < j)
			}
			return libc.Bool32(-2147483647-1-j > j)
		}() != 0 {
			return E_FAILED
		}
		var j2 int32 = j + j
		if func() int32 {
			if j2 > 0 {
				return libc.Bool32(2147483647-j2 < j)
			}
			return libc.Bool32(-2147483647-1-j2 > j)
		}() != 0 {
			return E_FAILED
		}
		var j3 int32 = j2 + j

		if func() int32 {
			if i2 > 0 {
				return libc.Bool32(2147483647-i2 < j)
			}
			return libc.Bool32(-2147483647-1-i2 > j)
		}() != 0 {
			return E_FAILED
		}
		if func() int32 {
			if j3 >= 0 {
				return libc.Bool32(-2147483647-1+j3 >= i)
			}
			return libc.Bool32(2147483647+j3+1 < i)
		}() != 0 {
			return E_FAILED
		}
	}

	// TODO: Do the int math parts here in long double?
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(i*2+j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(j*3-i)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	// Expected not to be reachable, because max + min or max - min would need
	// to overflow.
	if func() int32 {
		if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+47, uint32(404), uintptr(unsafe.Pointer(&__func__2)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return E_FAILED
	}
	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

var __func__2 = *(*[15]int8)(unsafe.Pointer(ts + 89)) /* coordijk.c:368:39 */

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// counter-clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:417:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(3*i-j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(i+2*j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:434:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(2*i+j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(3*j-i)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:452:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 3}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:474:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex in the specified digit
// direction from the specified ijk coordinates. Works in place.
//
// @param ijk The ijk coordinates.
// @param digit The digit direction from the original ijk coordinates.
func X_neighbor(tls *libc.TLS, ijk uintptr, digit TDirection) { /* coordijk.c:497:6: */
	if digit > CENTER_DIGIT && digit < NUM_DIGITS {
		X_ijkAdd(tls, ijk, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(digit)*12, ijk)
		X_ijkNormalize(tls, ijk)
	}
}

// *
// Rotates ijk coordinates 60 degrees counter-clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60ccw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:509:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates ijk coordinates 60 degrees clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60cw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:530:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates indexing digit 60 degrees counter-clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60ccw(tls *libc.TLS, digit TDirection) TDirection { /* coordijk.c:551:11: */
	switch digit {
	case K_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return TDirection(0)
}

// *
// Rotates indexing digit 60 degrees clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60cw(tls *libc.TLS, digit TDirection) TDirection { /* coordijk.c:575:11: */
	switch digit {
	case K_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return TDirection(0)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp3(tls *libc.TLS, ijk uintptr) { /* coordijk.c:601:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 2}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp3r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:623:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Finds the distance between the two coordinates. Returns result.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
func XijkDistance(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:645:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var diff TCoordIJK at bp, 12

	X_ijkSub(tls, c1, c2, bp)
	X_ijkNormalize(tls, bp)
	var absDiff = TCoordIJK{Fi: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fi), Fj: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fj), Fk: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fk)}
	return func() int32 {
		if absDiff.Fi > func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}() {
			return absDiff.Fi
		}
		return func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}()
	}()
}

// *
// Transforms coordinates from the IJK+ coordinate system to the IJ coordinate
// system.
//
// @param ijk The input IJK+ coordinates
// @param ij The output IJ coordinates
func XijkToIj(tls *libc.TLS, ijk uintptr, ij uintptr) { /* coordijk.c:660:6: */
	(*TCoordIJ)(unsafe.Pointer(ij)).Fi = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJ)(unsafe.Pointer(ij)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
}

// *
// Transforms coordinates from the IJ coordinate system to the IJK+ coordinate
// system.
//
// @param ij The input IJ coordinates
// @param ijk The output IJK+ coordinates
// @returns E_SUCCESS on success, E_FAILED if signed integer overflow would have
// occurred.
func XijToIjk(tls *libc.TLS, ij uintptr, ijk uintptr) TH3Error { /* coordijk.c:674:9: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = (*TCoordIJ)(unsafe.Pointer(ij)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJ)(unsafe.Pointer(ij)).Fj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
		return E_FAILED
	}

	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

// *
// Convert IJK coordinates to cube coordinates, in place
// @param ijk Coordinate to convert
func XijkToCube(tls *libc.TLS, ijk uintptr) { /* coordijk.c:691:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi + (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
}

// *
// Convert cube coordinates to IJK coordinates, in place
// @param ijk Coordinate to convert
func XcubeToIjk(tls *libc.TLS, ijk uintptr) { /* coordijk.c:701:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = int32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:275:5 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file  vertex.h
//  @brief Functions for working with cell vertexes.

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lng.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

//   - @struct PentagonDirectionFaces
//     @brief  The faces in each axial direction of a given pentagon base cell
type TPentagonDirectionFaces = struct {
	FbaseCell int32
	Ffaces    [5]int32
} /* vertex.h:33:3 */

// *
// Returns whether or not the provided H3Indexes are neighbors.
// @param origin The origin H3 index.
// @param destination The destination H3 index.
// @param out Set to 1 if the indexes are neighbors, 0 otherwise
// @return Error code if the origin or destination are invalid or incomparable.
func XareNeighborCells(tls *libc.TLS, origin TH3Index, destination TH3Index, out uintptr) TH3Error { /* directedEdge.c:38:9: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Make sure they're hexagon indexes
	if int32(origin&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE || int32(destination&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE {
		return E_CELL_INVALID
	}

	// Hexagons cannot be neighbors with themselves
	if origin == destination {
		*(*int32)(unsafe.Pointer(out)) = 0
		return E_SUCCESS
	}

	// Only hexagons in the same resolution can be neighbors
	if int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) != int32(destination&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return E_RES_MISMATCH
	}

	// H3 Indexes that share the same parent are very likely to be neighbors
	// Child 0 is neighbor with all of its parent's 'offspring', the other
	// children are neighbors with 3 of the 7 children. So a simple comparison
	// of origin and destination parents and then a lookup table of the children
	// is a super-cheap way to possibly determine they are neighbors.
	var parentRes int32 = int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	if parentRes > 0 {
		// TODO: Return error codes here
		// var originParent TH3Index at bp, 8

		XcellToParent(tls, origin, parentRes, bp)
		// var destinationParent TH3Index at bp+8, 8

		XcellToParent(tls, destination, parentRes, bp+8)
		if *(*TH3Index)(unsafe.Pointer(bp)) == *(*TH3Index)(unsafe.Pointer(bp + 8)) {
			var originResDigit TDirection = TDirection(origin >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			var destinationResDigit TDirection = TDirection(destination >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			if originResDigit == CENTER_DIGIT || destinationResDigit == CENTER_DIGIT {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
			if originResDigit >= INVALID_DIGIT {
				// Prevent indexing off the end of the array below
				return E_CELL_INVALID
			}
			if (originResDigit == K_AXES_DIGIT || destinationResDigit == K_AXES_DIGIT) && XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp))) != 0 {
				// If these are invalid cells, fail rather than incorrectly
				// reporting neighbors. For pentagon cells that are actually
				// neighbors across the deleted subsequence, they will fail the
				// optimized check below, but they will be accepted by the
				// gridDisk check below that.
				return E_CELL_INVALID
			}
			// These sets are the relevant neighbors in the clockwise
			// and counter-clockwise
			*(*[7]TDirection)(unsafe.Pointer(bp + 16 /* neighborSetClockwise */)) = [7]TDirection{
				CENTER_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, J_AXES_DIGIT,
				IK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT}
			*(*[7]TDirection)(unsafe.Pointer(bp + 44 /* neighborSetCounterclockwise */)) = [7]TDirection{
				CENTER_DIGIT, IK_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT,
				IJ_AXES_DIGIT, I_AXES_DIGIT, J_AXES_DIGIT}
			if *(*TDirection)(unsafe.Pointer(bp + 16 + uintptr(originResDigit)*4)) == destinationResDigit || *(*TDirection)(unsafe.Pointer(bp + 44 + uintptr(originResDigit)*4)) == destinationResDigit {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
		}
	}

	// Otherwise, we have to determine the neighbor relationship the "hard" way.
	*(*[7]TH3Index)(unsafe.Pointer(bp + 72 /* neighborRing */)) = [7]TH3Index{0: uint64(0)}
	XgridDisk(tls, origin, 1, bp+72)
	{
		var i int32 = 0
		for ; i < 7; i++ {
			if *(*TH3Index)(unsafe.Pointer(bp + 72 + uintptr(i)*8)) == destination {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
		}
	}

	// Made it here, they definitely aren't neighbors
	*(*int32)(unsafe.Pointer(out)) = 0
	return E_SUCCESS
}

// *
// Returns a directed edge H3 index based on the provided origin and
// destination
// @param origin The origin H3 hexagon index
// @param destination The destination H3 hexagon index
// @return The directed edge H3Index, or H3_NULL on failure.
func XcellsToDirectedEdge(tls *libc.TLS, origin TH3Index, destination TH3Index, out uintptr) TH3Error { /* directedEdge.c:132:9: */
	// Determine the IJK direction from the origin to the destination
	var direction TDirection = XdirectionForNeighbor(tls, origin, destination)

	// The direction will be invalid if the cells are not neighbors
	if direction == INVALID_DIGIT {
		return E_NOT_NEIGHBORS
	}

	// Create the edge index for the neighbor direction
	var output TH3Index = origin
	output = output&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_DIRECTEDEDGE_MODE))<<DH3_MODE_OFFSET
	output = output&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(direction)<<DH3_RESERVED_OFFSET

	*(*TH3Index)(unsafe.Pointer(out)) = output
	return E_SUCCESS
}

// *
// Returns the origin hexagon from the directed edge H3Index
// @param edge The edge H3 index
// @return The origin H3 hexagon index, or H3_NULL on failure
func XgetDirectedEdgeOrigin(tls *libc.TLS, edge TH3Index, out uintptr) TH3Error { /* directedEdge.c:156:9: */
	if int32(edge&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_DIRECTEDEDGE_MODE {
		return E_DIR_EDGE_INVALID
	}
	var origin TH3Index = edge
	origin = origin&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	origin = origin&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(uint64(0))<<DH3_RESERVED_OFFSET
	*(*TH3Index)(unsafe.Pointer(out)) = origin
	return E_SUCCESS
}

// *
// Returns the destination hexagon from the directed edge H3Index
// @param edge The edge H3 index
// @return The destination H3 hexagon index, or H3_NULL on failure
func XgetDirectedEdgeDestination(tls *libc.TLS, edge TH3Index, out uintptr) TH3Error { /* directedEdge.c:172:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var direction TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	*(*int32)(unsafe.Pointer(bp + 8 /* rotations */)) = 0
	// var origin TH3Index at bp, 8

	// Note: This call is also checking for H3_DIRECTEDEDGE_MODE
	var originResult TH3Error = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return originResult
	}
	return Xh3NeighborRotations(tls, *(*TH3Index)(unsafe.Pointer(bp /* origin */)), direction, bp+8, out)
}

// *
// Determines if the provided H3Index is a valid directed edge index
// @param edge The directed edge H3Index
// @return 1 if it is a directed edge H3Index, otherwise 0.
func XisValidDirectedEdge(tls *libc.TLS, edge TH3Index) int32 { /* directedEdge.c:189:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var neighborDirection TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	if neighborDirection <= CENTER_DIGIT || neighborDirection >= NUM_DIGITS {
		return 0
	}
	// var origin TH3Index at bp, 8

	// Note: This call is also checking for H3_DIRECTEDEDGE_MODE
	var originResult TH3Error = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return 0
	}
	if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp))) != 0 && neighborDirection == K_AXES_DIGIT {
		return 0
	}

	return XisValidCell(tls, *(*TH3Index)(unsafe.Pointer(bp /* origin */)))
}

// *
// Returns the origin, destination pair of hexagon IDs for the given edge ID
// @param edge The directed edge H3Index
// @param originDestination Pointer to memory to store origin and destination
// IDs
func XdirectedEdgeToCells(tls *libc.TLS, edge TH3Index, originDestination uintptr) TH3Error { /* directedEdge.c:214:9: */
	var originResult TH3Error = XgetDirectedEdgeOrigin(tls, edge, originDestination)
	if originResult != 0 {
		return originResult
	}
	var destinationResult TH3Error = XgetDirectedEdgeDestination(tls, edge, originDestination+1*8)
	if destinationResult != 0 {
		return destinationResult
	}
	return E_SUCCESS
}

// *
// Provides all of the directed edges from the current H3Index.
// @param origin The origin hexagon H3Index to find edges for.
// @param edges The memory to store all of the edges inside.
func XoriginToDirectedEdges(tls *libc.TLS, origin TH3Index, edges uintptr) TH3Error { /* directedEdge.c:234:9: */
	// Determine if the origin is a pentagon and special treatment needed.
	var isPent int32 = XisPentagon(tls, origin)

	// This is actually quite simple. Just modify the bits of the origin
	// slightly for each direction, except the 'k' direction in pentagons,
	// which is zeroed.
	{
		var i int32 = 0
		for ; i < 6; i++ {
			if isPent != 0 && i == 0 {
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = uint64(DH3_NULL)
			} else {
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = origin
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_DIRECTEDEDGE_MODE))<<DH3_MODE_OFFSET
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(i+1)<<DH3_RESERVED_OFFSET
			}
		}
	}
	return E_SUCCESS
}

// *
// Provides the coordinates defining the directed edge.
// @param edge The directed edge H3Index
// @param cb The cellboundary object to store the edge coordinates.
func XdirectedEdgeToBoundary(tls *libc.TLS, edge TH3Index, cb uintptr) TH3Error { /* directedEdge.c:258:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// Get the origin and neighbor direction from the edge
	var direction TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	// var origin TH3Index at bp, 8

	var originResult TH3Error = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return originResult
	}

	// Get the start vertex for the edge
	var startVertex int32 = XvertexNumForDirection(tls, *(*TH3Index)(unsafe.Pointer(bp /* origin */)), direction)
	if startVertex == -1 {
		// This is not actually an edge (i.e. no valid direction),
		// so return no vertices.
		(*TCellBoundary)(unsafe.Pointer(cb)).FnumVerts = 0
		return E_DIR_EDGE_INVALID
	}

	// Get the geo boundary for the appropriate vertexes of the origin. Note
	// that while there are always 2 topological vertexes per edge, the
	// resulting edge boundary may have an additional distortion vertex if it
	// crosses an edge of the icosahedron.
	// var fijk TFaceIJK at bp+8, 16

	var fijkResult TH3Error = X_h3ToFaceIjk(tls, *(*TH3Index)(unsafe.Pointer(bp /* origin */)), bp+8)
	if func() int32 {
		if fijkResult != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+104, uint32(282), uintptr(unsafe.Pointer(&__func__3)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return fijkResult
	}
	var res int32 = int32(*(*TH3Index)(unsafe.Pointer(bp)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPent int32 = XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp /* origin */)))

	if isPent != 0 {
		X_faceIjkPentToCellBoundary(tls, bp+8, res, startVertex, 2, cb)
	} else {
		X_faceIjkToCellBoundary(tls, bp+8, res, startVertex, 2, cb)
	}
	return E_SUCCESS
}

var __func__3 = *(*[23]int8)(unsafe.Pointer(ts + 136)) /* directedEdge.c:258:75 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec3d.h
// @brief   3D floating point vector functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct Vec3D
//     @brief 3D floating point structure
type TVec3d = struct {
	Fx float64
	Fy float64
	Fz float64
} /* vec3d.h:32:3 */

//* square root of 7

// * @brief icosahedron face centers in lat/lng radians
var XfaceCenterGeo = [20]TLatLng{
	{Flat: 0.803582649718989942, Flng: 1.248397419617396099},   // face  0
	{Flat: 1.307747883455638156, Flng: 2.536945009877921159},   // face  1
	{Flat: 1.054751253523952054, Flng: -1.347517358900396623},  // face  2
	{Flat: 0.600191595538186799, Flng: -0.450603909469755746},  // face  3
	{Flat: 0.491715428198773866, Flng: 0.401988202911306943},   // face  4
	{Flat: 0.172745327415618701, Flng: 1.678146885280433686},   // face  5
	{Flat: 0.605929321571350690, Flng: 2.953923329812411617},   // face  6
	{Flat: 0.427370518328979641, Flng: -1.888876200336285401},  // face  7
	{Flat: -0.079066118549212831, Flng: -0.733429513380867741}, // face  8
	{Flat: -0.230961644455383637, Flng: 0.506495587332349035},  // face  9
	{Flat: 0.079066118549212831, Flng: 2.408163140208925497},   // face 10
	{Flat: 0.230961644455383637, Flng: -2.635097066257444203},  // face 11
	{Flat: -0.172745327415618701, Flng: -1.463445768309359553}, // face 12
	{Flat: -0.605929321571350690, Flng: -0.187669323777381622}, // face 13
	{Flat: -0.427370518328979641, Flng: 1.252716453253507838},  // face 14
	{Flat: -0.600191595538186799, Flng: 2.690988744120037492},  // face 15
	{Flat: -0.491715428198773866, Flng: -2.739604450678486295}, // face 16
	{Flat: -0.803582649718989942, Flng: -1.893195233972397139}, // face 17
	{Flat: -1.307747883455638156, Flng: -0.604647643711872080}, // face 18
	{Flat: -1.054751253523952054, Flng: 1.794075294689396615},  // face 19
} /* faceijk.c:39:14 */

// * @brief icosahedron face centers in x/y/z on the unit sphere
var faceCenterPoint = [20]TVec3d{
	{Fx: 0.2199307791404606, Fy: 0.6583691780274996, Fz: 0.7198475378926182},    // face  0
	{Fx: -0.2139234834501421, Fy: 0.1478171829550703, Fz: 0.9656017935214205},   // face  1
	{Fx: 0.1092625278784797, Fy: -0.4811951572873210, Fz: 0.8697775121287253},   // face  2
	{Fx: 0.7428567301586791, Fy: -0.3593941678278028, Fz: 0.5648005936517033},   // face  3
	{Fx: 0.8112534709140969, Fy: 0.3448953237639384, Fz: 0.4721387736413930},    // face  4
	{Fx: -0.1055498149613921, Fy: 0.9794457296411413, Fz: 0.1718874610009365},   // face  5
	{Fx: -0.8075407579970092, Fy: 0.1533552485898818, Fz: 0.5695261994882688},   // face  6
	{Fx: -0.2846148069787907, Fy: -0.8644080972654206, Fz: 0.4144792552473539},  // face  7
	{Fx: 0.7405621473854482, Fy: -0.6673299564565524, Fz: -0.0789837646326737},  // face  8
	{Fx: 0.8512303986474293, Fy: 0.4722343788582681, Fz: -0.2289137388687808},   // face  9
	{Fx: -0.7405621473854481, Fy: 0.6673299564565524, Fz: 0.0789837646326737},   // face 10
	{Fx: -0.8512303986474292, Fy: -0.4722343788582682, Fz: 0.2289137388687808},  // face 11
	{Fx: 0.1055498149613919, Fy: -0.9794457296411413, Fz: -0.1718874610009365},  // face 12
	{Fx: 0.8075407579970092, Fy: -0.1533552485898819, Fz: -0.5695261994882688},  // face 13
	{Fx: 0.2846148069787908, Fy: 0.8644080972654204, Fz: -0.4144792552473539},   // face 14
	{Fx: -0.7428567301586791, Fy: 0.3593941678278027, Fz: -0.5648005936517033},  // face 15
	{Fx: -0.8112534709140971, Fy: -0.3448953237639382, Fz: -0.4721387736413930}, // face 16
	{Fx: -0.2199307791404607, Fy: -0.6583691780274996, Fz: -0.7198475378926182}, // face 17
	{Fx: 0.2139234834501420, Fy: -0.1478171829550704, Fz: -0.9656017935214205},  // face 18
	{Fx: -0.1092625278784796, Fy: 0.4811951572873210, Fz: -0.8697775121287253},  // face 19
} /* faceijk.c:63:20 */

// * @brief icosahedron face ijk axes as azimuth in radians from face center to
// vertex 0/1/2 respectively
var faceAxesAzRadsCII = [20][3]float64{
	{5.619958268523939882, 3.525563166130744542,
		1.431168063737548730}, // face  0
	{5.760339081714187279, 3.665943979320991689,
		1.571548876927796127}, // face  1
	{0.780213654393430055, 4.969003859179821079,
		2.874608756786625655}, // face  2
	{0.430469363979999913, 4.619259568766391033,
		2.524864466373195467}, // face  3
	{6.130269123335111400, 4.035874020941915804,
		1.941478918548720291}, // face  4
	{2.692877706530642877, 0.598482604137447119,
		4.787272808923838195}, // face  5
	{2.982963003477243874, 0.888567901084048369,
		5.077358105870439581}, // face  6
	{3.532912002790141181, 1.438516900396945656,
		5.627307105183336758}, // face  7
	{3.494305004259568154, 1.399909901866372864,
		5.588700106652763840}, // face  8
	{3.003214169499538391, 0.908819067106342928,
		5.097609271892733906}, // face  9
	{5.930472956509811562, 3.836077854116615875,
		1.741682751723420374}, // face 10
	{0.138378484090254847, 4.327168688876645809,
		2.232773586483450311}, // face 11
	{0.448714947059150361, 4.637505151845541521,
		2.543110049452346120}, // face 12
	{0.158629650112549365, 4.347419854898940135,
		2.253024752505744869}, // face 13
	{5.891865957979238535, 3.797470855586042958,
		1.703075753192847583}, // face 14
	{2.711123289609793325, 0.616728187216597771,
		4.805518392002988683}, // face 15
	{3.294508837434268316, 1.200113735041072948,
		5.388903939827463911}, // face 16
	{3.804819692245439833, 1.710424589852244509,
		5.899214794638635174}, // face 17
	{3.664438879055192436, 1.570043776661997111,
		5.758833981448388027}, // face 18
	{2.361378999196363184, 0.266983896803167583,
		4.455774101589558636}, // face 19
} /* faceijk.c:89:21 */

// * @brief Definition of which faces neighbor each other.
var faceNeighbors = [20][4]TFaceOrientIJK{{
	{}, // central face
	{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
	{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
	{Fface: 5, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 1
		{Fface: 1}, // central face
		{Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},           // ij quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 2
		{Fface: 2}, // central face
		{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 3
		{Fface: 3}, // central face
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 4
		{Fface: 4}, // central face
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},           // ki quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 5
		{Fface: 5}, // central face
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 6
		{Fface: 6}, // central face
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 1, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 7
		{Fface: 7}, // central face
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 8
		{Fface: 8}, // central face
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 9
		{Fface: 9}, // central face
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 10
		{Fface: 10}, // central face
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 11
		{Fface: 11}, // central face
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 12
		{Fface: 12}, // central face
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 13
		{Fface: 13}, // central face
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 14
		{Fface: 14}, // central face
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 15
		{Fface: 15}, // central face
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 16
		{Fface: 16}, // central face
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 17
		{Fface: 17}, // central face
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 18
		{Fface: 18}, // central face
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 19
		{Fface: 19}, // central face
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},  // ij quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},  // ki quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}}} /* faceijk.c:133:28 */

// * @brief direction from the origin face to the destination face, relative to
// the origin face's coordinate system, or -1 if not adjacent.
var adjacentFaceDir = [20][20]int32{
	{0, DKI, -1, -1, DIJ, DJK, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 0
	{DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 1
	{-1, DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 2
	{-1, -1, DIJ, 0, DKI, -1, -1, -1, DJK, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 3
	{DKI, -1, -1, DIJ, 0, -1, -1, -1, -1, DJK,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 4
	{DJK, -1, -1, -1, -1, 0, -1, -1, -1, -1,
		DIJ, -1, -1, -1, DKI, -1, -1, -1, -1, -1}, // face 5
	{-1, DJK, -1, -1, -1, -1, 0, -1, -1, -1,
		DKI, DIJ, -1, -1, -1, -1, -1, -1, -1, -1}, // face 6
	{-1, -1, DJK, -1, -1, -1, -1, 0, -1, -1,
		-1, DKI, DIJ, -1, -1, -1, -1, -1, -1, -1}, // face 7
	{-1, -1, -1, DJK, -1, -1, -1, -1, 0, -1,
		-1, -1, DKI, DIJ, -1, -1, -1, -1, -1, -1}, // face 8
	{-1, -1, -1, -1, DJK, -1, -1, -1, -1, 0,
		-1, -1, -1, DKI, DIJ, -1, -1, -1, -1, -1}, // face 9
	{-1, -1, -1, -1, -1, DIJ, DKI, -1, -1, -1,
		0, -1, -1, -1, -1, DJK, -1, -1, -1, -1}, // face 10
	{-1, -1, -1, -1, -1, -1, DIJ, DKI, -1, -1,
		-1, 0, -1, -1, -1, -1, DJK, -1, -1, -1}, // face 11
	{-1, -1, -1, -1, -1, -1, -1, DIJ, DKI, -1,
		-1, -1, 0, -1, -1, -1, -1, DJK, -1, -1}, // face 12
	{-1, -1, -1, -1, -1, -1, -1, -1, DIJ, DKI,
		-1, -1, -1, 0, -1, -1, -1, -1, DJK, -1}, // face 13
	{-1, -1, -1, -1, -1, DKI, -1, -1, -1, DIJ,
		-1, -1, -1, -1, 0, -1, -1, -1, -1, DJK}, // face 14
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		DJK, -1, -1, -1, -1, 0, DIJ, -1, -1, DKI}, // face 15
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, DJK, -1, -1, -1, DKI, 0, DIJ, -1, -1}, // face 16
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, DJK, -1, -1, -1, DKI, 0, DIJ, -1}, // face 17
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, DJK, -1, -1, -1, DKI, 0, DIJ}, // face 18
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, DJK, DIJ, -1, -1, DKI, 0}, // face 19
} /* faceijk.c:278:18 */

// * @brief overage distance table
var maxDimByCIIres = [17]int32{
	2,        // res  0
	-1,       // res  1
	14,       // res  2
	-1,       // res  3
	98,       // res  4
	-1,       // res  5
	686,      // res  6
	-1,       // res  7
	4802,     // res  8
	-1,       // res  9
	33614,    // res 10
	-1,       // res 11
	235298,   // res 12
	-1,       // res 13
	1647086,  // res 14
	-1,       // res 15
	11529602, // res 16
} /* faceijk.c:322:18 */

// * @brief unit scale distance table
var unitScaleByCIIres = [17]int32{
	1,       // res  0
	-1,      // res  1
	7,       // res  2
	-1,      // res  3
	49,      // res  4
	-1,      // res  5
	343,     // res  6
	-1,      // res  7
	2401,    // res  8
	-1,      // res  9
	16807,   // res 10
	-1,      // res 11
	117649,  // res 12
	-1,      // res 13
	823543,  // res 14
	-1,      // res 15
	5764801, // res 16
} /* faceijk.c:343:18 */

// *
// Encodes a coordinate on the sphere to the FaceIJK address of the containing
// cell at the specified resolution.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param h The FaceIJK address of the containing cell at resolution res.
func X_geoToFaceIjk(tls *libc.TLS, g uintptr, res int32, h uintptr) { /* faceijk.c:371:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// first convert to hex2d
	// var v TVec2d at bp, 16

	X_geoToHex2d(tls, g, res, h, bp)

	// then convert to ijk+
	X_hex2dToCoordIJK(tls, bp, h+4)
}

// *
// Encodes a coordinate on the sphere to the corresponding icosahedral face and
// containing 2D hex coordinates relative to that face center.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param face The icosahedral face containing the spherical coordinates.
// @param v The 2D hex coordinates of the cell containing the point.
func X_geoToHex2d(tls *libc.TLS, g uintptr, res int32, face uintptr, v uintptr) { /* faceijk.c:389:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// determine the icosahedron face
	// var sqd float64 at bp, 8

	X_geoToClosestFace(tls, g, face, bp)

	// cos(r) = 1 - 2 * sin^2(r/2) = 1 - 2 * (sqd / 4) = 1 - sqd/2
	var r float64 = libc.Xacos(tls, float64(1)-*(*float64)(unsafe.Pointer(bp))/float64(2))

	if r < 0.0000000000000001 {
		(*TVec2d)(unsafe.Pointer(v)).Fx = libc.AssignPtrFloat64(v+8, 0.0)
		return
	}

	// now have face and r, now find CCW theta from CII i-axis
	var theta float64 = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(*(*int32)(unsafe.Pointer(face)))*24))-X_posAngleRads(tls, X_geoAzimuthRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(*(*int32)(unsafe.Pointer(face)))*16, g)))

	// adjust theta for Class III (odd resolutions)
	if XisResolutionClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta-0.333473172251832115336090755351601070065900389)
	}

	// perform gnomonic scaling of r
	r = libc.Xtan(tls, r)

	// scale for current resolution length u
	r = r / 0.38196601125010500003
	{
		var i int32 = 0
		for ; i < res; i++ {
			r = r * 2.6457513110645905905016157536392604257102
		}
	}

	// we now have (r, theta) in hex2d with theta ccw from x-axes

	// convert to local x,y
	(*TVec2d)(unsafe.Pointer(v)).Fx = r * libc.Xcos(tls, theta)
	(*TVec2d)(unsafe.Pointer(v)).Fy = r * libc.Xsin(tls, theta)
}

// *
// Determines the center point in spherical coordinates of a cell given by 2D
// hex coordinates on a particular icosahedral face.
//
// @param v The 2D hex coordinates of the cell.
// @param face The icosahedral face upon which the 2D hex coordinate system is
//
//	centered.
//
// @param res The H3 resolution of the cell.
// @param substrate Indicates whether or not this grid is actually a substrate
//
//	grid relative to the specified resolution.
//
// @param g The spherical coordinates of the cell center point.
func X_hex2dToGeo(tls *libc.TLS, v uintptr, face int32, res int32, substrate int32, g uintptr) { /* faceijk.c:437:6: */
	// calculate (r, theta) in hex2d
	var r float64 = X_v2dMag(tls, v)

	if r < 0.0000000000000001 {
		*(*TLatLng)(unsafe.Pointer(g)) = XfaceCenterGeo[face]
		return
	}

	var theta float64 = libc.Xatan2(tls, (*TVec2d)(unsafe.Pointer(v)).Fy, (*TVec2d)(unsafe.Pointer(v)).Fx)

	// scale for current resolution length u
	{
		var i int32 = 0
		for ; i < res; i++ {
			r = r / 2.6457513110645905905016157536392604257102
		}
	}

	// scale accordingly if this is a substrate grid
	if substrate != 0 {
		r = r / 3.0
		if XisResolutionClassIII(tls, res) != 0 {
			r = r / 2.6457513110645905905016157536392604257102
		}
	}

	r = r * 0.38196601125010500003

	// perform inverse gnomonic scaling of r
	r = libc.Xatan(tls, r)

	// adjust theta for Class III
	// if a substrate grid, then it's already been adjusted for Class III
	if !(substrate != 0) && XisResolutionClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta+0.333473172251832115336090755351601070065900389)
	}

	// find theta as an azimuth
	theta = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(face)*24))-theta)

	// now find the point at (r,theta) from the face center
	X_geoAzDistanceRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(face)*16, theta, r, g)
}

// *
// Determines the center point in spherical coordinates of a cell given by
// a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param g The spherical coordinates of the cell center point.
func X_faceIjkToGeo(tls *libc.TLS, h uintptr, res int32, g uintptr) { /* faceijk.c:482:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var v TVec2d at bp, 16

	X_ijkToHex2d(tls, h+4, bp)
	X_hex2dToGeo(tls, bp, (*TFaceIJK)(unsafe.Pointer(h)).Fface, res, 0, g)
}

// *
// Generates the cell boundary in spherical coordinates for a pentagonal cell
// given by a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the pentagonal cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkPentToCellBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:498:6: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [5]TFaceIJK at bp+20, 80

	X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_PENT_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lng
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	// var lastFijk TFaceIJK at bp+116, 16

	{
		var vert int32 = start
		for ; vert < start+length+additionalIteration; vert++ {
			var v int32 = vert % DNUM_PENT_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			X_adjustPentVertOverage(tls, bp+100, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)))

			// all Class III pentagon edges cross icosa edges
			// note that Class II pentagons have vertices on the edge,
			// not edge intersections
			if XisResolutionClassIII(tls, res) != 0 && vert > start {
				// find hex2d of the two vertexes on the last face

				*(*TFaceIJK)(unsafe.Pointer(bp + 152 /* tmpFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+116+4, bp+136)

				var currentToLastDir int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+116 /* &lastFijk */)).Fface)*4))

				var fijkOrient uintptr = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr(currentToLastDir)*20

				(*TFaceIJK)(unsafe.Pointer(bp + 152 /* &tmpFijk */)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface
				var ijk uintptr = bp + 152 + 4

				// rotate and translate for adjacent face
				{
					var i int32 = 0
					for ; i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60; i++ {
						X_ijkRotate60ccw(tls, ijk)
					}
				}

				*(*TCoordIJK)(unsafe.Pointer(bp + 168 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
				X_ijkScale(tls, bp+168, unitScaleByCIIres[*(*int32)(unsafe.Pointer(bp + 16))]*3)
				X_ijkAdd(tls, ijk, bp+168, ijk)
				X_ijkNormalize(tls, ijk)
				// var orig2d1 TVec2d at bp+184, 16

				X_ijkToHex2d(tls, ijk, bp+184)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 216 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 232 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface)*4)) {
				case DIJ:
					edge0 = bp + 200 /* &v0 */
					edge1 = bp + 216 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 216 /* &v1 */
					edge1 = bp + 232 /* &v2 */
					break
					fallthrough
				case DKI:
					fallthrough
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100)).Fface)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+159, ts+206, uint32(571), uintptr(unsafe.Pointer(&__func__4)))
					}
					edge0 = bp + 232 /* &v2 */
					edge1 = bp + 200 /* &v0 */
					break
				}

				// find the intersection and add the lat/lng point to the result
				// var inter TVec2d at bp+248, 16

				X_v2dIntersect(tls, bp+136, bp+184, edge0, edge1, bp+248)
				X_hex2dToGeo(tls, bp+248, (*TFaceIJK)(unsafe.Pointer(bp+152 /* &tmpFijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
					g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			// convert vertex to lat/lng and add to the result
			// vert == start + NUM_PENT_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_PENT_VERTS {
				// var vec TVec2d at bp+264, 16

				X_ijkToHex2d(tls, bp+100+4, bp+264)
				X_hex2dToGeo(tls, bp+264, (*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* lastFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))
		}
	}
}

var __func__4 = *(*[27]int8)(unsafe.Pointer(ts + 233)) /* faceijk.c:499:62 */

// *
// Get the vertices of a pentagon cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//
//	necessary for the substrate grid resolution.
//
// @param fijkVerts Output array for the vertices
func X_faceIjkPentToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:607:6: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// the vertexes of an origin-centered pentagon in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp + 60 /* vertsCII */)) = [5]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
	}

	// the vertexes of an origin-centered pentagon in a Class III resolution on
	// a substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II. vertices listed ccw from the
	// i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [5]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 60 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
		for ; v < DNUM_PENT_VERTS; v++ {
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)
		}
	}
}

// *
// Generates the cell boundary in spherical coordinates for a cell given by a
// FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkToCellBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:671:6: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	X_faceIjkToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_HEX_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lng
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	var lastFace int32 = -1
	var lastOverage TOverage = NO_OVERAGE
	{
		var vert int32 = start
		for ; vert < start+length+additionalIteration; vert++ {
			var v int32 = vert % DNUM_HEX_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			var pentLeading4 int32 = 0
			var overage TOverage = X_adjustOverageClassII(tls, bp+116, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), pentLeading4, 1)

			//
			//         Check for edge-crossing. Each face of the underlying icosahedron is a
			//         different projection plane. So if an edge of the hexagon crosses an
			//         icosahedron edge, an additional vertex must be introduced at that
			//         intersection point. Then each half of the cell edge can be projected
			//         to geographic coordinates using the appropriate icosahedron face
			//         projection. Note that Class II cell edges have vertices on the face
			//         edge, with no edge line intersections.
			//
			if XisResolutionClassIII(tls, res) != 0 && vert > start && (*TFaceIJK)(unsafe.Pointer(bp+116)).Fface != lastFace && lastOverage != FACE_EDGE {
				// find hex2d of the two vertexes on original face
				var lastV int32 = (v + 5) % DNUM_HEX_VERTS
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+20+uintptr(lastV)*16+4, bp+136)
				// var orig2d1 TVec2d at bp+152, 16

				X_ijkToHex2d(tls, bp+20+uintptr(v)*16+4, bp+152)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 168 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 184 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}

				var face2 int32 = func() int32 {
					if lastFace == (*TFaceIJK)(unsafe.Pointer(bp)).Fface {
						return (*TFaceIJK)(unsafe.Pointer(bp + 116)).Fface
					}
					return lastFace
				}()
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) {
				case DIJ:
					edge0 = bp + 168 /* &v0 */
					edge1 = bp + 184 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 184 /* &v1 */
					edge1 = bp + 200 /* &v2 */
					break
					fallthrough
				// case KI:
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+260, ts+206, uint32(736), uintptr(unsafe.Pointer(&__func__5)))
					}
					edge0 = bp + 200 /* &v2 */
					edge1 = bp + 168 /* &v0 */
					break
				}

				// find the intersection and add the lat/lng point to the result
				// var inter TVec2d at bp+216, 16

				X_v2dIntersect(tls, bp+136, bp+152, edge0, edge1, bp+216)
				//
				//             If a point of intersection occurs at a hexagon vertex, then each
				//             adjacent hexagon edge will lie completely on a single icosahedron
				//             face, and no additional vertex is required.
				//
				var isIntersectionAtVertex uint8 = uint8(libc.Bool32(X_v2dAlmostEquals(tls, bp+136, bp+216) != 0 || X_v2dAlmostEquals(tls, bp+152, bp+216) != 0))
				if !(isIntersectionAtVertex != 0) {
					X_hex2dToGeo(tls, bp+216, (*TFaceIJK)(unsafe.Pointer(bp /* &centerIJK */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
						g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
					(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
				}
			}

			// convert vertex to lat/lng and add to the result
			// vert == start + NUM_HEX_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_HEX_VERTS {
				// var vec TVec2d at bp+232, 16

				X_ijkToHex2d(tls, bp+116+4, bp+232)
				X_hex2dToGeo(tls, bp+232, (*TFaceIJK)(unsafe.Pointer(bp+116 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			lastFace = (*TFaceIJK)(unsafe.Pointer(bp + 116 /* &fijk */)).Fface
			lastOverage = overage
		}
	}
}

var __func__5 = *(*[23]int8)(unsafe.Pointer(ts + 305)) /* faceijk.c:672:46 */

// *
// Get the vertices of a cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//
//	necessary for the substrate grid resolution.
//
// @param fijkVerts Output array for the vertices
func X_faceIjkToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:782:6: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	// the vertexes of an origin-centered cell in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp + 72 /* vertsCII */)) = [6]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
		{Fi: 2, Fk: 1}, // 5
	}

	// the vertexes of an origin-centered cell in a Class III resolution on a
	// substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [6]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
		{Fi: 5, Fk: 1}, // 5
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 72 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
		for ; v < DNUM_HEX_VERTS; v++ {
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)
		}
	}
}

// *
// Adjusts a FaceIJK address in place so that the resulting cell address is
// relative to the correct icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param pentLeading4 Whether or not the cell is a pentagon with a leading
//
//	digit 4.
//
// @param substrate Whether or not the cell is in a substrate grid.
// @return 0 if on original face (no overage); 1 if on face edge (only occurs
//
//	on substrate grids); 2 if overage on new face interior
func X_adjustOverageClassII(tls *libc.TLS, fijk uintptr, res int32, pentLeading4 int32, substrate int32) TOverage { /* faceijk.c:850:9: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var overage TOverage = NO_OVERAGE

	var ijk uintptr = fijk + 4

	// get the maximum dimension value; scale if a substrate grid
	var maxDim int32 = maxDimByCIIres[res]
	if substrate != 0 {
		maxDim = maxDim * 3
	}

	// check for overage
	if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
		overage = FACE_EDGE
	} else if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk > maxDim {
		overage = NEW_FACE
		var fijkOrient uintptr
		if (*TCoordIJK)(unsafe.Pointer(ijk)).Fk > 0 {
			if (*TCoordIJK)(unsafe.Pointer(ijk)).Fj > 0 { // jk "quadrant"
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 3*20
			} else {
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 2*20

				// adjust for the pentagonal missing sequence
				if pentLeading4 != 0 {
					// translate origin to center of pentagon
					// var origin TCoordIJK at bp, 12

					X_setIJK(tls, bp, maxDim, 0, 0)
					// var tmp TCoordIJK at bp+12, 12

					X_ijkSub(tls, ijk, bp, bp+12)
					// rotate to adjust for the missing sequence
					X_ijkRotate60cw(tls, bp+12)
					// translate the origin back to the center of the triangle
					X_ijkAdd(tls, bp+12, bp, ijk)
				}
			}
		} else { // ij "quadrant"
			fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 1*20
		}

		(*TFaceIJK)(unsafe.Pointer(fijk)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface

		// rotate and translate for adjacent face
		{
			var i int32 = 0
			for ; i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60; i++ {
				X_ijkRotate60ccw(tls, ijk)
			}
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
		var unitScale int32 = unitScaleByCIIres[res]
		if substrate != 0 {
			unitScale = unitScale * 3
		}
		X_ijkScale(tls, bp+24, unitScale)
		X_ijkAdd(tls, ijk, bp+24, ijk)
		X_ijkNormalize(tls, ijk)

		// overage points on pentagon boundaries can end up on edges
		if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
			overage = FACE_EDGE
		}
	}

	return overage
}

// *
// Adjusts a FaceIJK address for a pentagon vertex in a substrate grid in
// place so that the resulting cell address is relative to the correct
// icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
func X_adjustPentVertOverage(tls *libc.TLS, fijk uintptr, res int32) TOverage { /* faceijk.c:919:9: */
	var pentLeading4 int32 = 0
	var overage TOverage
	for __ccgo := true; __ccgo; __ccgo = overage == NEW_FACE {
		overage = X_adjustOverageClassII(tls, fijk, res, pentLeading4, 1)
	}
	return overage
}

// *
// Encodes a coordinate on the sphere to the corresponding icosahedral face and
// containing the squared euclidean distance to that face center.
//
// @param g The spherical coordinates to encode.
// @param face The icosahedral face containing the spherical coordinates.
// @param sqd The squared euclidean distance to its icosahedral face center.
func X_geoToClosestFace(tls *libc.TLS, g uintptr, face uintptr, sqd uintptr) { /* faceijk.c:936:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var v3d TVec3d at bp, 24

	X_geoToVec3d(tls, g, bp)

	// determine the icosahedron face
	*(*int32)(unsafe.Pointer(face)) = 0
	// The distance between two farthest points is 2.0, therefore the square of
	// the distance between two points should always be less or equal than 4.0 .
	*(*float64)(unsafe.Pointer(sqd)) = 5.0
	{
		var f int32 = 0
		for ; f < DNUM_ICOSA_FACES; f++ {
			var sqdT float64 = X_pointSquareDist(tls, uintptr(unsafe.Pointer(&faceCenterPoint))+uintptr(f)*24, bp)
			if sqdT < *(*float64)(unsafe.Pointer(sqd)) {
				*(*int32)(unsafe.Pointer(face)) = f
				*(*float64)(unsafe.Pointer(sqd)) = sqdT
			}
		}
	}
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// Copyright 2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// * @file iterators.h
// @brief Iterator structs and functions for the children of a cell,
// or cells at a given resolution.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// *
// IterCellsChildren: struct for iterating through the descendants of
// a given cell.
//
// Constructors:
//
// Initialize with either `iterInitParent` or `iterInitBaseCellNum`.
// `iterInitParent` sets up an iterator for all the children of a given
// parent cell at a given resolution.
//
// `iterInitBaseCellNum` sets up an iterator for children cells, given
// a base cell number (0--121).
//
// Iteration:
//
// Step iterator with `iterStepChild`.
// During the lifetime of the `IterCellsChildren`, the current iterate
// is accessed via the `IterCellsChildren.h` member.
// When the iterator is exhausted or if there was an error in initialization,
// `IterCellsChildren.h` will be `H3_NULL` even after calling `iterStepChild`.
type TIterCellsChildren = struct {
	Fh          TH3Index
	F_parentRes int32
	F_skipDigit int32
} /* iterators.h:54:3 */

// *
// IterCellsResolution: struct for iterating through all cells at a given
// resolution
//
// Constructor:
//
// Initialize with `IterCellsResolution`.
//
// Iteration:
//
// Step iterator with `iterStepRes`.
// During the lifetime of the iterator the current iterate
// is accessed via the `IterCellsResolution.h` member.
// When the iterator is exhausted or if there was an error in initialization,
// `IterCellsResolution.h` will be `H3_NULL` even after calling `iterStepRes`.
type TIterCellsResolution = struct {
	Fh            TH3Index
	F_baseCellNum int32
	F_res         int32
	F_itC         TIterCellsChildren
} /* iterators.h:81:3 */

// *
// Returns the H3 resolution of an H3 index.
// @param h The H3 index.
// @return The resolution of the H3 index argument.
func XgetResolution(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:39:5: */
	return int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
}

// *
// Returns the H3 base cell "number" of an H3 cell (hexagon or pentagon).
//
// Note: Technically works on H3 edges, but will return base cell of the
// origin cell.
//
// @param h The H3 cell.
// @return The base cell "number" of the H3 cell argument.
func XgetBaseCellNumber(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:50:5: */
	return int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
}

// *
// Converts a string representation of an H3 index into an H3 index.
// @param str The string representation of an H3 index.
// @return The H3 index corresponding to the string argument, or H3_NULL if
// invalid.
func XstringToH3(tls *libc.TLS, str uintptr, out uintptr) TH3Error { /* h3Index.c:58:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TH3Index)(unsafe.Pointer(bp + 8 /* h */)) = uint64(DH3_NULL)
	// If failed, h will be unmodified and we should return H3_NULL anyways.
	var read int32 = libc.Xsscanf(tls, str, ts+328, libc.VaList(bp, bp+8))
	if read != 1 {
		return E_FAILED
	}
	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(bp + 8 /* h */))
	return E_SUCCESS
}

// *
// Converts an H3 index into a string representation.
// @param h The H3 index to convert.
// @param str The string representation of the H3 index.
// @param sz Size of the buffer `str`
func Xh3ToString(tls *libc.TLS, h TH3Index, str uintptr, sz Tsize_t) TH3Error { /* h3Index.c:75:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// An unsigned 64 bit integer will be expressed in at most
	// 16 digits plus 1 for the null terminator.
	if sz < uint64(17) {
		// Buffer is potentially not large enough.
		return E_MEMORY_BOUNDS
	}
	libc.Xsprintf(tls, str, ts+328, libc.VaList(bp, h))
	return E_SUCCESS
}

// *
// Returns whether or not an H3 index is a valid cell (hexagon or pentagon).
// @param h The H3 index to validate.
// @return 1 if the H3 index if valid, and 0 if it is not.
func XisValidCell(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:91:5: */
	if int32(h&(Tuint64_t(uint64(1))<<DH3_MAX_OFFSET)>>DH3_MAX_OFFSET) != 0 {
		return 0
	}

	if int32(h&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE {
		return 0
	}

	if int32(h&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) != 0 {
		return 0
	}

	var baseCell int32 = int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(99), uintptr(unsafe.Pointer(&__func__6)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return 0
	}

	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if func() int32 {
		if res < 0 || res > DMAX_H3_RES {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(105), uintptr(unsafe.Pointer(&__func__6)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Resolutions less than zero can not be represented in an index
		return 0
	}

	var foundFirstNonZeroDigit uint8 = uint8(Dfalse)
	{
		var r int32 = 1
		for ; r <= res; r++ {
			var digit TDirection = TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))

			if !(foundFirstNonZeroDigit != 0) && digit != CENTER_DIGIT {
				foundFirstNonZeroDigit = uint8(Dtrue)
				if X_isBaseCellPentagon(tls, baseCell) != 0 && digit == K_AXES_DIGIT {
					return 0
				}
			}

			if func() int32 {
				if digit < CENTER_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+332, uint32(121), uintptr(unsafe.Pointer(&__func__6)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 || digit >= NUM_DIGITS {
				return 0
			}
		}
	}

	{
		var r1 int32 = res + 1
		for ; r1 <= DMAX_H3_RES; r1++ {
			var digit TDirection = TDirection(h >> ((DMAX_H3_RES - r1) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			if digit != INVALID_DIGIT {
				return 0
			}
		}
	}

	return 1
}

var __func__6 = *(*[12]int8)(unsafe.Pointer(ts + 359)) /* h3Index.c:91:39 */

// *
// Initializes an H3 index.
// @param hp The H3 index to initialize.
// @param res The H3 resolution to initialize the index to.
// @param baseCell The H3 base cell to initialize the index to.
// @param initDigit The H3 digit (0-7) to initialize all of the index digits to.
func XsetH3Index(tls *libc.TLS, hp uintptr, res int32, baseCell int32, initDigit TDirection) { /* h3Index.c:139:6: */
	var h TH3Index = 35184372088831
	h = h&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET
	h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET
	{
		var r int32 = 1
		for ; r <= res; r++ {
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(initDigit)<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}
	*(*TH3Index)(unsafe.Pointer(hp)) = h
}

// *
// cellToParent produces the parent index for a given H3 index
//
// @param h H3Index to find parent of
// @param parentRes The resolution to switch to (parent, grandparent, etc)
//
// @return H3Index of the parent, or H3_NULL if you actually asked for a child
func XcellToParent(tls *libc.TLS, h TH3Index, parentRes int32, out uintptr) TH3Error { /* h3Index.c:156:9: */
	var childRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if parentRes < 0 || parentRes > DMAX_H3_RES {
		return E_RES_DOMAIN
	} else if parentRes > childRes {
		return E_RES_MISMATCH
	} else if parentRes == childRes {
		*(*TH3Index)(unsafe.Pointer(out)) = h
		return E_SUCCESS
	}
	var parentH TH3Index = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|Tuint64_t(parentRes)<<DH3_RES_OFFSET)
	{
		var i int32 = parentRes + 1
		for ; i <= childRes; i++ {
			parentH = parentH & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)
		}
	}
	*(*TH3Index)(unsafe.Pointer(out)) = parentH
	return E_SUCCESS
}

// *
// Determines whether one resolution is a valid child resolution for a cell.
// Each resolution is considered a valid child resolution of itself.
//
// @param h         h3Index  parent cell
// @param childRes  int      resolution of the child
//
// @return The validity of the child resolution
func _hasChildAtRes(tls *libc.TLS, h TH3Index, childRes int32) uint8 { /* h3Index.c:183:13: */
	var parentRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if childRes < parentRes || childRes > DMAX_H3_RES {
		return uint8(Dfalse)
	}
	return uint8(Dtrue)
}

// *
// cellToChildrenSize returns the exact number of children for a cell at a
// given child resolution.
//
// @param h         H3Index to find the number of children of
// @param childRes  The child resolution you're interested in
//
// @return int      Exact number of children (handles hexagons and pentagons
//
//	correctly)
func XcellToChildrenSize(tls *libc.TLS, h TH3Index, childRes int32, out uintptr) TH3Error { /* h3Index.c:201:9: */
	if !(_hasChildAtRes(tls, h, childRes) != 0) {
		return E_RES_DOMAIN
	}

	var n int32 = childRes - int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET)

	if XisPentagon(tls, h) != 0 {
		*(*Tint64_t)(unsafe.Pointer(out)) = int64(1) + int64(5)*(X_ipow(tls, int64(7), int64(n))-int64(1))/int64(6)
	} else {
		*(*Tint64_t)(unsafe.Pointer(out)) = X_ipow(tls, int64(7), int64(n))
	}
	return E_SUCCESS
}

// *
// makeDirectChild takes an index and immediately returns the immediate child
// index based on the specified cell number. Bit operations only, could generate
// invalid indexes if not careful (deleted cell under a pentagon).
//
// @param h H3Index to find the direct child of
// @param cellNumber int id of the direct child (0-6)
//
// @return The new H3Index for the child
func XmakeDirectChild(tls *libc.TLS, h TH3Index, cellNumber int32) TH3Index { /* h3Index.c:224:9: */
	var childRes int32 = int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) + 1
	var childH TH3Index = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|Tuint64_t(childRes)<<DH3_RES_OFFSET)
	childH = childH & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(cellNumber)<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)
	return childH
}

// *
// cellToChildren takes the given hexagon id and generates all of the children
// at the specified resolution storing them into the provided memory pointer.
// It's assumed that cellToChildrenSize was used to determine the allocation.
//
// @param h H3Index to find the children of
// @param childRes int the child level to produce
// @param children H3Index* the memory to store the resulting addresses in
func XcellToChildren(tls *libc.TLS, h TH3Index, childRes int32, children uintptr) TH3Error { /* h3Index.c:240:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i Tint64_t = int64(0)
	{
		*(*TIterCellsChildren)(unsafe.Pointer(bp /* iter */)) = XiterInitParent(tls, h, childRes)
		for ; (*TIterCellsChildren)(unsafe.Pointer(bp)).Fh != 0; XiterStepChild(tls, bp) {
			*(*TH3Index)(unsafe.Pointer(children + uintptr(i)*8)) = (*TIterCellsChildren)(unsafe.Pointer(bp /* &iter */)).Fh
			i++
		}
	}
	return E_SUCCESS
}

// *
// Zero out index digits from start to end, inclusive.
// No-op if start > end.
func X_zeroIndexDigits(tls *libc.TLS, h TH3Index, start int32, end int32) TH3Index { /* h3Index.c:254:9: */
	if start > end {
		return h
	}

	var m TH3Index = uint64(0)

	m = ^m
	m <<= DH3_PER_DIGIT_OFFSET * (end - start + 1)
	m = ^m
	m <<= DH3_PER_DIGIT_OFFSET * (DMAX_H3_RES - end)
	m = ^m

	return h & m
}

// *
// cellToCenterChild produces the center child index for a given H3 index at
// the specified resolution
//
// @param h H3Index to find center child of
// @param childRes The resolution to switch to
// @param child H3Index of the center child
// @return 0 (E_SUCCESS) on success
func XcellToCenterChild(tls *libc.TLS, h TH3Index, childRes int32, child uintptr) TH3Error { /* h3Index.c:277:9: */
	if !(_hasChildAtRes(tls, h, childRes) != 0) {
		return E_RES_DOMAIN
	}

	h = X_zeroIndexDigits(tls, h, int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET)+1, childRes)
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(childRes)<<DH3_RES_OFFSET
	*(*TH3Index)(unsafe.Pointer(child)) = h
	return E_SUCCESS
}

// *
// compactCells takes a set of hexagons all at the same resolution and
// compresses them by pruning full child branches to the parent level. This is
// also done for all parents recursively to get the minimum number of hex
// addresses that perfectly cover the defined space.
// @param h3Set Set of hexagons
// @param compactedSet The output array of compressed hexagons (preallocated)
// @param numHexes The size of the input and output arrays (possible that no
// contiguous regions exist in the set at all and no compression possible)
// @return an error code on bad input data
// todo: update internal implementation for int64_t
func XcompactCells(tls *libc.TLS, h3Set uintptr, compactedSet uintptr, numHexes Tint64_t) TH3Error { /* h3Index.c:298:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if numHexes == int64(0) {
		return E_SUCCESS
	}
	var res int32 = int32(*(*TH3Index)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if res == 0 {
		// No compaction possible, just copy the set to output
		{
			var i int32 = 0
			for ; Tint64_t(i) < numHexes; i++ {
				*(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8))
			}
		}
		return E_SUCCESS
	}
	var remainingHexes uintptr = libc.Xmalloc(tls, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
	if !(remainingHexes != 0) {
		return E_MEMORY_ALLOC
	}
	libc.Xmemcpy(tls, remainingHexes, h3Set, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
	var hashSetArray uintptr = libc.Xcalloc(tls, uint64(numHexes), uint64(unsafe.Sizeof(TH3Index(0))))
	if !(hashSetArray != 0) {
		libc.Xfree(tls, remainingHexes)
		return E_MEMORY_ALLOC
	}
	var compactedSetOffset uintptr = compactedSet
	var numRemainingHexes int32 = int32(numHexes)
	for numRemainingHexes != 0 {
		res = int32(*(*TH3Index)(unsafe.Pointer(remainingHexes)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		var parentRes int32 = res - 1

		// If parentRes is less than zero, we've compacted all the way up to the
		// base cells. Time to process the remaining cells.
		if parentRes >= 0 {
			// Put the parents of the hexagons into the temp array
			// via a hashing mechanism, and use the reserved bits
			// to track how many times a parent is duplicated
			{
				var i int32 = 0
				for ; i < numRemainingHexes; i++ {
					var currIndex TH3Index = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i)*8))
					// TODO: This case is coverable (reachable by fuzzer)
					if currIndex != uint64(0) {
						// If the reserved bits were set by the caller, the
						// algorithm below may encounter undefined behavior
						// because it expects to have set the reserved bits
						// itself.
						if int32(currIndex&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) != 0 {
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return E_CELL_INVALID
						}
						// var parent TH3Index at bp, 8

						var parentError TH3Error = XcellToParent(tls, currIndex, parentRes, bp)
						// Should never be reachable as a result of the compact
						// algorithm. Can happen if cellToParent errors e.g.
						// because of incompatible resolutions.
						if parentError != 0 {
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return parentError
						}
						// Modulus hash the parent into the temp array
						var loc int32 = int32(*(*TH3Index)(unsafe.Pointer(bp)) % TH3Index(numRemainingHexes))
						var loopCount int32 = 0
						for *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != uint64(0) {
							if func() int32 {
								if loopCount > numRemainingHexes {
									return func() int32 {
										if 0 != 0 {
										} else {
											libc.X__assert_fail(tls, ts, ts+332, uint32(362), uintptr(unsafe.Pointer(&__func__7)))
										}
										return 1
									}()
								}
								return 0
							}() != 0 {
								// This case should not be possible because at
								// most one index is placed into hashSetArray
								// per numRemainingHexes.
								libc.Xfree(tls, remainingHexes)
								libc.Xfree(tls, hashSetArray)
								return E_FAILED
							}
							var tempIndex TH3Index = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
							if tempIndex == *(*TH3Index)(unsafe.Pointer(bp)) {
								var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
								var limitCount int32 = 7
								if XisPentagon(tls,
									tempIndex&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
									limitCount--
								}
								// One is added to count for this check to match
								// one being added to count later in this
								// function when checking for all children being
								// present.
								if count+1 > limitCount {
									// Only possible on duplicate input
									libc.Xfree(tls, remainingHexes)
									libc.Xfree(tls, hashSetArray)
									return E_DUPLICATE_INPUT
								}
								*(*TH3Index)(unsafe.Pointer(bp)) = *(*TH3Index)(unsafe.Pointer(bp))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(count)<<DH3_RESERVED_OFFSET
								*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = uint64(DH3_NULL)
							} else {
								loc = (loc + 1) % numRemainingHexes
							}
							loopCount++
						}
						*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = *(*TH3Index)(unsafe.Pointer(bp /* parent */))
					}
				}
			}
		}

		// Determine which parent hexagons have a complete set
		// of children and put them in the compactableHexes array
		var compactableCount int32 = 0
		var maxCompactableCount int32 = numRemainingHexes / 6 // Somehow all pentagons; conservative
		if maxCompactableCount == 0 {
			libc.Xmemcpy(tls, compactedSetOffset, remainingHexes,
				uint64(numRemainingHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
			break
		}
		var compactableHexes uintptr = libc.Xcalloc(tls, uint64(maxCompactableCount), uint64(unsafe.Sizeof(TH3Index(0))))
		if !(compactableHexes != 0) {
			libc.Xfree(tls, remainingHexes)
			libc.Xfree(tls, hashSetArray)
			return E_MEMORY_ALLOC
		}
		{
			var i int32 = 0
			for ; i < numRemainingHexes; i++ {
				if *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) == uint64(0) {
					continue
				}
				var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
				// Include the deleted direction for pentagons as implicitly "there"
				if XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
					// We need this later on, no need to recalculate
					*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(count)<<DH3_RESERVED_OFFSET
					// Increment count after setting the reserved bits,
					// since count is already incremented above, so it
					// will be the expected value for a complete hexagon.
					count++
				}
				if count == 7 {
					// Bingo! Full set!
					*(*TH3Index)(unsafe.Pointer(compactableHexes + uintptr(compactableCount)*8)) = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
					compactableCount++
				}
			}
		}
		// Uncompactable hexes are immediately copied into the
		// output compactedSetOffset
		var uncompactableCount int32 = 0
		{
			var i1 int32 = 0
			for ; i1 < numRemainingHexes; i1++ {
				var currIndex TH3Index = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i1)*8))
				// TODO: This case is coverable (reachable by fuzzer)
				if currIndex != uint64(DH3_NULL) {
					// var parent TH3Index at bp+8, 8

					var parentError TH3Error = XcellToParent(tls, currIndex, parentRes, bp+8)
					if parentError != 0 {
						libc.Xfree(tls, compactableHexes)
						libc.Xfree(tls, remainingHexes)
						libc.Xfree(tls, hashSetArray)
						return parentError
					}
					// Modulus hash the parent into the temp array
					// to determine if this index was included in
					// the compactableHexes array
					var loc int32 = int32(*(*TH3Index)(unsafe.Pointer(bp + 8)) % TH3Index(numRemainingHexes))
					var loopCount int32 = 0
					var isUncompactable uint8 = uint8(Dtrue)
					for __ccgo := true; __ccgo; __ccgo = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != *(*TH3Index)(unsafe.Pointer(bp + 8)) {
						if func() int32 {
							if loopCount > numRemainingHexes {
								return func() int32 {
									if 0 != 0 {
									} else {
										libc.X__assert_fail(tls, ts, ts+332, uint32(462), uintptr(unsafe.Pointer(&__func__7)))
									}
									return 1
								}()
							}
							return 0
						}() != 0 {
							// This case should not be possible because at most one
							// index is placed into hashSetArray per input hexagon.
							libc.Xfree(tls, compactableHexes)
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return E_FAILED
						}
						var tempIndex TH3Index = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
						if tempIndex == *(*TH3Index)(unsafe.Pointer(bp + 8)) {
							var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
							if count == 7 {
								isUncompactable = uint8(Dfalse)
							}
							break
						} else {
							loc = (loc + 1) % numRemainingHexes
						}
						loopCount++
					}
					if isUncompactable != 0 {
						*(*TH3Index)(unsafe.Pointer(compactedSetOffset + uintptr(uncompactableCount)*8)) = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i1)*8))
						uncompactableCount++
					}
				}
			}
		}
		// Set up for the next loop
		libc.Xmemset(tls, hashSetArray, 0, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
		compactedSetOffset += 8 * uintptr(uncompactableCount)
		libc.Xmemcpy(tls, remainingHexes, compactableHexes,
			uint64(compactableCount)*uint64(unsafe.Sizeof(TH3Index(0))))
		numRemainingHexes = compactableCount
		libc.Xfree(tls, compactableHexes)
	}
	libc.Xfree(tls, remainingHexes)
	libc.Xfree(tls, hashSetArray)
	return E_SUCCESS
}

var __func__7 = *(*[13]int8)(unsafe.Pointer(ts + 371)) /* h3Index.c:299:57 */

// *
// uncompactCells takes a compressed set of cells and expands back to the
// original set of cells.
//
// Skips elements that are H3_NULL (i.e., 0).
//
// @param   compactSet  Set of compacted cells
// @param   numCompact  The number of cells in the input compacted set
// @param   outSet      Output array for decompressed cells (preallocated)
// @param   numOut      The size of the output array to bound check against
// @param   res         The H3 resolution to decompress to
// @return              An error code if output array is too small or any cell
//
//	is smaller than the output resolution.
func XuncompactCells(tls *libc.TLS, compactedSet uintptr, numCompacted Tint64_t, outSet uintptr, numOut Tint64_t, res int32) TH3Error { /* h3Index.c:516:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i Tint64_t = int64(0)

	{
		var j Tint64_t = int64(0)
		for ; j < numCompacted; j++ {
			if !(_hasChildAtRes(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(j)*8)), res) != 0) {
				return E_RES_MISMATCH
			}

			{
				*(*TIterCellsChildren)(unsafe.Pointer(bp /* iter */)) = XiterInitParent(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(j)*8)), res)
			__1:
				if !((*TIterCellsChildren)(unsafe.Pointer(bp)).Fh != 0) {
					goto __3
				}
				{
					if i >= numOut {
						return E_MEMORY_BOUNDS
					} // went too far; abort!
					*(*TH3Index)(unsafe.Pointer(outSet + uintptr(i)*8)) = (*TIterCellsChildren)(unsafe.Pointer(bp /* &iter */)).Fh

				}
				goto __2
			__2:
				i++
				XiterStepChild(tls, bp)
				goto __1
				goto __3
			__3:
			}
		}
	}
	return E_SUCCESS
}

// *
// uncompactCellsSize takes a compacted set of hexagons and provides
// the exact size of the uncompacted set of hexagons.
//
// @param   compactedSet  Set of hexagons
// @param   numHexes      The number of hexes in the input set
// @param   res           The hexagon resolution to decompress to
// @param   out           The number of hexagons to allocate memory for
// @returns E_SUCCESS on success, or another value on error
func XuncompactCellsSize(tls *libc.TLS, compactedSet uintptr, numCompacted Tint64_t, res int32, out uintptr) TH3Error { /* h3Index.c:543:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var numOut Tint64_t = int64(0)
	{
		var i Tint64_t = int64(0)
		for ; i < numCompacted; i++ {
			if *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) == uint64(DH3_NULL) {
				continue
			}
			// var childrenSize Tint64_t at bp, 8

			var childrenError TH3Error = XcellToChildrenSize(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)), res, bp)
			if childrenError != 0 {
				// The parent res does not contain `res`.
				return E_RES_MISMATCH
			}
			numOut = numOut + *(*Tint64_t)(unsafe.Pointer(bp))
		}
	}
	*(*Tint64_t)(unsafe.Pointer(out)) = numOut
	return E_SUCCESS
}

// *
// isResClassIII takes a hexagon ID and determines if it is in a
// Class III resolution (rotated versus the icosahedron and subject
// to shape distortion adding extra points on icosahedron edges, making
// them not true hexagons).
// @param h The H3Index to check.
// @return Returns 1 if the hexagon is class III, otherwise 0.
func XisResClassIII(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:571:5: */
	return int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) % 2
}

// *
// isPentagon takes an H3Index and determines if it is actually a pentagon.
// @param h The H3Index to check.
// @return Returns 1 if it is a pentagon, otherwise 0.
func XisPentagon(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:578:5: */
	return libc.Bool32(X_isBaseCellPentagon(tls, int32(h&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0 && !(X_h3LeadingNonZeroDigit(tls, h) != 0))
}

// *
// Returns the highest resolution non-zero digit in an H3Index.
// @param h The H3Index.
// @return The highest resolution non-zero digit in the H3Index.
func X_h3LeadingNonZeroDigit(tls *libc.TLS, h TH3Index) TDirection { /* h3Index.c:588:11: */
	{
		var r int32 = 1
		for ; r <= int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET); r++ {
			if TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != 0 {
				return TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			}
		}
	}

	// if we're here it's all 0's
	return CENTER_DIGIT
}

// *
// Rotate an H3Index 60 degrees counter-clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60ccw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:600:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			// rotate this digit
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60ccw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != TDirection(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60ccw(tls, h)
				}
			}
		}
	}
	return h
}

// *
// Rotate an H3Index 60 degrees clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60cw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:626:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			// rotate this digit
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60cw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != TDirection(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60cw(tls, h)
				}
			}
		}
	}
	return h
}

// *
// Rotate an H3Index 60 degrees counter-clockwise.
// @param h The H3Index.
func X_h3Rotate60ccw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:651:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			var oldDigit TDirection = TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60ccw(tls, oldDigit))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}

	return h
}

// *
// Rotate an H3Index 60 degrees clockwise.
// @param h The H3Index.
func X_h3Rotate60cw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:664:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60cw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}

	return h
}

// *
// Convert an FaceIJK address to the corresponding H3Index.
// @param fijk The FaceIJK address.
// @param res The cell resolution.
// @return The encoded H3Index (or H3_NULL on failure).
func X_faceIjkToH3(tls *libc.TLS, fijk uintptr, res int32) TH3Index { /* h3Index.c:678:9: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// initialize the index
	var h TH3Index = 35184372088831
	h = h&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		if (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk > DMAX_FACE_COORD {
			// out of range input
			return uint64(DH3_NULL)
		}

		h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(X_faceIjkToBaseCell(tls, fijk))<<DH3_BC_OFFSET
		return h
	}

	// we need to find the correct base cell FaceIJK for this H3 index;
	// start with the passed in face and resolution res ijk coordinates
	// in that face's coordinate system
	*(*TFaceIJK)(unsafe.Pointer(bp /* fijkBC */)) = *(*TFaceIJK)(unsafe.Pointer(fijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	var ijk uintptr = bp + 4
	{
		var r int32 = res - 1
		for ; r >= 0; r-- {
			*(*TCoordIJK)(unsafe.Pointer(bp + 28 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
			// var lastCenter TCoordIJK at bp+16, 12

			if XisResolutionClassIII(tls, r+1) != 0 {
				// rotate ccw
				X_upAp7(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7(tls, bp+16)
			} else {
				// rotate cw
				X_upAp7r(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7r(tls, bp+16)
			}
			// var diff TCoordIJK at bp+40, 12

			X_ijkSub(tls, bp+28, bp+16, bp+40)
			X_ijkNormalize(tls, bp+40)

			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_unitIjkToDigit(tls, bp+40))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
		}
	}

	// fijkBC should now hold the IJK of the base cell in the
	// coordinate system of the current face

	if (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fk > DMAX_FACE_COORD {
		// out of range input
		return uint64(DH3_NULL)
	}

	// lookup the correct base cell
	var baseCell int32 = X_faceIjkToBaseCell(tls, bp)
	h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET

	// rotate if necessary to get canonical base cell orientation
	// for this base cell
	var numRots int32 = X_faceIjkToBaseCellCCWrot60(tls, bp)
	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
			// check for a cw/ccw offset face; default is ccw
			if X_baseCellIsCwOffset(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp)).Fface) != 0 {
				h = X_h3Rotate60cw(tls, h)
			} else {
				h = X_h3Rotate60ccw(tls, h)
			}
		}

		{
			var i int32 = 0
			for ; i < numRots; i++ {
				h = X_h3RotatePent60ccw(tls, h)
			}
		}
	} else {
		{
			var i int32 = 0
			for ; i < numRots; i++ {
				h = X_h3Rotate60ccw(tls, h)
			}
		}
	}

	return h
}

func XisXfinite(tls *libc.TLS, f float64) uint8 { /* h3Index.c:764:6: */
	return libc.BoolUint8(!(libc.X__builtin_isnan(tls, f-f) != 0))
}

// *
// Encodes a coordinate on the sphere to the H3 index of the containing cell at
// the specified resolution.
//
// Returns 0 on invalid input.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param out The encoded H3Index.
// @returns E_SUCCESS (0) on success, another value otherwise
func XlatLngToCell(tls *libc.TLS, g uintptr, res int32, out uintptr) TH3Error { /* h3Index.c:777:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	if !(XisXfinite(tls, (*TLatLng)(unsafe.Pointer(g)).Flat) != 0) || !(XisXfinite(tls, (*TLatLng)(unsafe.Pointer(g)).Flng) != 0) {
		return E_LATLNG_DOMAIN
	}
	// var fijk TFaceIJK at bp, 16

	X_geoToFaceIjk(tls, g, res, bp)
	*(*TH3Index)(unsafe.Pointer(out)) = X_faceIjkToH3(tls, bp, res)
	if func() int32 {
		if *(*TH3Index)(unsafe.Pointer(out)) != 0 {
			return 1
		}
		return func() int32 {
			if 0 != 0 {
			} else {
				libc.X__assert_fail(tls, ts, ts+332, uint32(788), uintptr(unsafe.Pointer(&__func__8)))
			}
			return 0
		}()
	}() != 0 {
		return E_SUCCESS
	} else {
		return E_FAILED
	}
	return TH3Error(0)
}

var __func__8 = *(*[13]int8)(unsafe.Pointer(ts + 384)) /* h3Index.c:777:73 */

// *
// Convert an H3Index to the FaceIJK address on a specified icosahedral face.
// @param h The H3Index.
// @param fijk The FaceIJK address, initialized with the desired face
//
//	and normalized base cell coordinates.
//
// @return Returns 1 if the possibility of overage exists, otherwise 0.
func X_h3ToFaceIjkWithInitializedFijk(tls *libc.TLS, h TH3Index, fijk uintptr) int32 { /* h3Index.c:802:5: */
	var ijk uintptr = fijk + 4
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	// center base cell hierarchy is entirely on this face
	var possibleOverage int32 = 1
	if !(X_isBaseCellPentagon(tls, int32(h&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0) && (res == 0 || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk == 0) {
		possibleOverage = 0
	}

	{
		var r int32 = 1
		for ; r <= res; r++ {
			if XisResolutionClassIII(tls, r) != 0 {
				// Class III == rotate ccw
				X_downAp7(tls, ijk)
			} else {
				// Class II == rotate cw
				X_downAp7r(tls, ijk)
			}

			X_neighbor(tls, ijk, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)))
		}
	}

	return possibleOverage
}

// *
// Convert an H3Index to a FaceIJK address.
// @param h The H3Index.
// @param fijk The corresponding FaceIJK address.
func X_h3ToFaceIjk(tls *libc.TLS, h TH3Index, fijk uintptr) TH3Error { /* h3Index.c:833:9: */
	var baseCell int32 = int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(835), uintptr(unsafe.Pointer(&__func__9)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		// To prevent reading uninitialized memory, we zero the output.
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fface = 0
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi = libc.AssignPtrInt32(fijk+4+4, libc.AssignPtrInt32(fijk+4+8, 0))
		return E_CELL_INVALID
	}
	// adjust for the pentagonal missing sequence; all of sub-sequence 5 needs
	// to be adjusted (and some of sub-sequence 4 below)
	if X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == TDirection(5) {
		h = X_h3Rotate60cw(tls, h)
	}

	// start with the "home" face and ijk+ coordinates for the base cell of c
	*(*TFaceIJK)(unsafe.Pointer(fijk)) = XbaseCellData[baseCell].FhomeFijk
	if !(X_h3ToFaceIjkWithInitializedFijk(tls, h, fijk) != 0) {
		return E_SUCCESS
	} // no overage is possible; h lies on this face

	// if we're here we have the potential for an "overage"; i.e., it is
	// possible that c lies on an adjacent face

	var origIJK = (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord

	// if we're in Class III, drop into the next finer Class II grid
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if XisResolutionClassIII(tls, res) != 0 {
		// Class III
		X_downAp7r(tls, fijk+4)
		res++
	}

	// adjust for overage if needed
	// a pentagon base cell with a leading 4 digit requires special handling
	var pentLeading4 int32 = libc.Bool32(X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == TDirection(4))
	if X_adjustOverageClassII(tls, fijk, res, pentLeading4, 0) != NO_OVERAGE {
		// if the base cell is a pentagon we have the potential for secondary
		// overages
		if X_isBaseCellPentagon(tls, baseCell) != 0 {
			for X_adjustOverageClassII(tls, fijk, res, 0, 0) != NO_OVERAGE {
				continue
			}
		}

		if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
			X_upAp7r(tls, fijk+4)
		}
	} else if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord = origIJK
	}
	return E_SUCCESS
}

var __func__9 = *(*[13]int8)(unsafe.Pointer(ts + 397)) /* h3Index.c:833:48 */

// *
// Determines the spherical coordinates of the center point of an H3 index.
//
// @param h3 The H3 index.
// @param g The spherical coordinates of the H3 cell center.
func XcellToLatLng(tls *libc.TLS, h3 TH3Index, g uintptr) TH3Error { /* h3Index.c:890:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	var e TH3Error = X_h3ToFaceIjk(tls, h3, bp)
	if e != 0 {
		return e
	}
	X_faceIjkToGeo(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), g)
	return E_SUCCESS
}

// *
// Determines the cell boundary in spherical coordinates for an H3 index.
//
// @param h3 The H3 index.
// @param cb The boundary of the H3 cell in spherical coordinates.
func XcellToBoundary(tls *libc.TLS, h3 TH3Index, cb uintptr) TH3Error { /* h3Index.c:906:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	var e TH3Error = X_h3ToFaceIjk(tls, h3, bp)
	if e != 0 {
		return e
	}
	if XisPentagon(tls, h3) != 0 {
		X_faceIjkPentToCellBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0,
			DNUM_PENT_VERTS, cb)
	} else {
		X_faceIjkToCellBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0, DNUM_HEX_VERTS,
			cb)
	}
	return E_SUCCESS
}

// *
// Returns the max number of possible icosahedron faces an H3 index
// may intersect.
//
// @return int count of faces
func XmaxFaceCount(tls *libc.TLS, h3 TH3Index, out uintptr) TH3Error { /* h3Index.c:928:9: */
	// a pentagon always intersects 5 faces, a hexagon never intersects more
	// than 2 (but may only intersect 1)
	*(*int32)(unsafe.Pointer(out)) = func() int32 {
		if XisPentagon(tls, h3) != 0 {
			return 5
		}
		return 2
	}()
	return E_SUCCESS
}

// *
// Find all icosahedron faces intersected by a given H3 index, represented
// as integers from 0-19. The array is sparse; since 0 is a valid value,
// invalid array values are represented as -1. It is the responsibility of
// the caller to filter out invalid values.
//
// @param h3 The H3 index
// @param out Output array. Must be of size maxFaceCount(h3).
func XgetIcosahedronFaces(tls *libc.TLS, h3 TH3Index, out uintptr) TH3Error { /* h3Index.c:944:9: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*int32)(unsafe.Pointer(bp + 16 /* res */)) = int32(h3 & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPent int32 = XisPentagon(tls, h3)

	// We can't use the vertex-based approach here for class II pentagons,
	// because all their vertices are on the icosahedron edges. Their
	// direct child pentagons cross the same faces, so use those instead.
	if isPent != 0 && !(XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(bp + 16))) != 0) {
		// Note that this would not work for res 15, but this is only run on
		// Class II pentagons, it should never be invoked for a res 15 index.
		var childPentagon TH3Index = XmakeDirectChild(tls, h3, 0)
		return XgetIcosahedronFaces(tls, childPentagon, out)
	}

	// convert to FaceIJK
	// var fijk TFaceIJK at bp, 16

	var err TH3Error = X_h3ToFaceIjk(tls, h3, bp)
	if err != 0 {
		return err
	}

	// Get all vertices as FaceIJK addresses. For simplicity, always
	// initialize the array with 6 verts, ignoring the last one for pentagons
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	var vertexCount int32

	if isPent != 0 {
		vertexCount = DNUM_PENT_VERTS
		X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)
	} else {
		vertexCount = DNUM_HEX_VERTS
		X_faceIjkToVerts(tls, bp, bp+16, bp+20)
	}

	// We may not use all of the slots in the output array,
	// so fill with invalid values to indicate unused slots
	// var faceCount int32 at bp+116, 4

	var maxFaceCountError TH3Error = XmaxFaceCount(tls, h3, bp+116)
	if func() int32 {
		if maxFaceCountError != E_SUCCESS {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(982), uintptr(unsafe.Pointer(&__func__10)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return maxFaceCountError
	}
	{
		var i int32 = 0
		for ; i < *(*int32)(unsafe.Pointer(bp + 116)); i++ {
			*(*int32)(unsafe.Pointer(out + uintptr(i)*4)) = -1
		}
	}

	// add each vertex face, using the output array as a hash set
	{
		var i1 int32 = 0
		for ; i1 < vertexCount; i1++ {
			var vert uintptr = bp + 20 + uintptr(i1)*16

			// Adjust overage, determining whether this vertex is
			// on another face
			if isPent != 0 {
				X_adjustPentVertOverage(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)))
			} else {
				X_adjustOverageClassII(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)), 0, 1)
			}

			// Save the face to the output array
			var face int32 = (*TFaceIJK)(unsafe.Pointer(vert)).Fface
			var pos int32 = 0
			// Find the first empty output position, or the first position
			// matching the current face
			for *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != -1 && *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != face {
				pos++
				if pos >= *(*int32)(unsafe.Pointer(bp + 116)) {
					// Mismatch between the heuristic used in maxFaceCount and
					// calculation here - indicates an invalid index.
					return E_FAILED
				}
			}
			*(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) = face
		}
	}
	return E_SUCCESS
}

var __func__10 = *(*[20]int8)(unsafe.Pointer(ts + 410)) /* h3Index.c:944:62 */

// *
// pentagonCount returns the number of pentagons (same at any resolution)
//
// @return int count of pentagon indexes
func XpentagonCount(tls *libc.TLS) int32 { /* h3Index.c:1024:5: */
	return DNUM_PENTAGONS
}

// *
// Generates all pentagons at the specified resolution
//
// @param res The resolution to produce pentagons at.
// @param out Output array. Must be of size pentagonCount().
func XgetPentagons(tls *libc.TLS, res int32, out uintptr) TH3Error { /* h3Index.c:1032:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	var i int32 = 0
	{
		var bc int32 = 0
		for ; bc < DNUM_BASE_CELLS; bc++ {
			if X_isBaseCellPentagon(tls, bc) != 0 {
				// var pentagon TH3Index at bp, 8

				XsetH3Index(tls, bp, res, bc, uint32(0))
				*(*TH3Index)(unsafe.Pointer(out + uintptr(libc.PostIncInt32(&i, 1))*8)) = *(*TH3Index)(unsafe.Pointer(bp /* pentagon */))
			}
		}
	}
	return E_SUCCESS
}

// *
// Returns whether or not a resolution is a Class III grid. Note that odd
// resolutions are Class III and even resolutions are Class II.
// @param res The H3 resolution.
// @return 1 if the resolution is a Class III grid, and 0 if the resolution is
//
//	a Class II grid.
func XisResolutionClassIII(tls *libc.TLS, res int32) int32 { /* h3Index.c:1054:5: */
	return res % 2
}

// *
// Validate a child position in the context of a given parent, returning
// an error if validation fails.
func validateChildPos(tls *libc.TLS, childPos Tint64_t, parent TH3Index, childRes int32) TH3Error { /* h3Index.c:1060:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var maxChildCount Tint64_t at bp, 8

	var sizeError TH3Error = XcellToChildrenSize(tls, parent, childRes, bp)
	if func() int32 {
		if sizeError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(1065), uintptr(unsafe.Pointer(&__func__11)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return sizeError
	}
	if childPos < int64(0) || childPos >= *(*Tint64_t)(unsafe.Pointer(bp)) {
		return E_DOMAIN
	}
	return E_SUCCESS
}

var __func__11 = *(*[17]int8)(unsafe.Pointer(ts + 430)) /* h3Index.c:1061:47 */

// *
// Returns the position of the cell within an ordered list of all children of
// the cell's parent at the specified resolution
func XcellToChildPos(tls *libc.TLS, child TH3Index, parentRes int32, out uintptr) TH3Error { /* h3Index.c:1078:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var childRes int32 = int32(child & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	// Get the parent at res. This will catch any resolution errors
	// var originalParent TH3Index at bp, 8

	var parentError TH3Error = XcellToParent(tls, child, parentRes, bp)
	if parentError != 0 {
		return parentError
	}

	// Define the initial parent. Note that these variables are reassigned
	// within the loop.
	*(*TH3Index)(unsafe.Pointer(bp + 8 /* parent */)) = *(*TH3Index)(unsafe.Pointer(bp /* originalParent */))
	var parentIsPentagon int32 = XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8 /* parent */)))

	// Walk up the resolution digits, incrementing the index
	*(*Tint64_t)(unsafe.Pointer(out)) = int64(0)
	if parentIsPentagon != 0 {
		// Pentagon logic. Pentagon parents skip the 1 digit, so the offsets are
		// different from hexagons
		{
			var res int32 = childRes
			for ; res > parentRes; res-- {
				var parentError TH3Error = XcellToParent(tls, child, res-1, bp+8)
				if func() int32 {
					if parentError != 0 {
						return func() int32 {
							if 0 != 0 {
							} else {
								libc.X__assert_fail(tls, ts, ts+332, uint32(1101), uintptr(unsafe.Pointer(&__func__12)))
							}
							return 1
						}()
					}
					return 0
				}() != 0 {
					return parentError
				}

				parentIsPentagon = XisPentagon(tls, *(*TH3Index)(unsafe.Pointer(bp + 8 /* parent */)))
				var rawDigit int32 = int32(TDirection(child >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
				// Validate the digit before proceeding
				if rawDigit == INVALID_DIGIT || parentIsPentagon != 0 && rawDigit == K_AXES_DIGIT {
					return E_CELL_INVALID
				}
				var digit int32
				if parentIsPentagon != 0 && rawDigit > 0 {
					digit = rawDigit - 1
				} else {
					digit = rawDigit
				}
				if digit != CENTER_DIGIT {
					var hexChildCount Tint64_t = X_ipow(tls, int64(7), int64(childRes-res))
					// The offset for the 0-digit slot depends on whether the
					// current index is the child of a pentagon. If so, the offset
					// is based on the count of pentagon children, otherwise,
					// hexagon children.
					*(*Tint64_t)(unsafe.Pointer(out)) += func() int64 {
						if parentIsPentagon != 0 {
							return int64(1) + int64(5)*(hexChildCount-int64(1))/int64(6)
						}
						return hexChildCount
					}() + Tint64_t(digit-1)*hexChildCount
				}
			}
		}
	} else {
		// Hexagon logic. Offsets are simple powers of 7
		{
			var res int32 = childRes
			for ; res > parentRes; res-- {
				var digit int32 = int32(TDirection(child >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
				if digit == INVALID_DIGIT {
					return E_CELL_INVALID
				}
				*(*Tint64_t)(unsafe.Pointer(out)) += Tint64_t(digit) * X_ipow(tls, int64(7), int64(childRes-res))
			}
		}
	}

	if func() int32 {
		if validateChildPos(tls, *(*Tint64_t)(unsafe.Pointer(out)), *(*TH3Index)(unsafe.Pointer(bp)), childRes) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+332, uint32(1141), uintptr(unsafe.Pointer(&__func__12)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// This is the result of an internal error, so return E_FAILED
		// instead of the validation error
		return E_FAILED
	}

	return E_SUCCESS
}

var __func__12 = *(*[15]int8)(unsafe.Pointer(ts + 447)) /* h3Index.c:1078:79 */

// *
// Returns the child cell at a given position within an ordered list of all
// children at the specified resolution
func XchildPosToCell(tls *libc.TLS, childPos Tint64_t, parent TH3Index, childRes int32, child uintptr) TH3Error { /* h3Index.c:1153:9: */
	// Validate resolution
	if childRes < 0 || childRes > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	// Validate parent resolution
	var parentRes int32 = int32(parent & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if childRes < parentRes {
		return E_RES_MISMATCH
	}
	// Validate child pos
	var childPosErr TH3Error = validateChildPos(tls, childPos, parent, childRes)
	if childPosErr != 0 {
		return childPosErr
	}

	var resOffset int32 = childRes - parentRes

	*(*TH3Index)(unsafe.Pointer(child)) = parent
	var idx Tint64_t = childPos

	*(*TH3Index)(unsafe.Pointer(child)) = *(*TH3Index)(unsafe.Pointer(child))&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(childRes)<<DH3_RES_OFFSET

	if XisPentagon(tls, parent) != 0 {
		// Pentagon tile logic. Pentagon tiles skip the 1 digit, so the offsets
		// are different
		var inPent uint8 = uint8(Dtrue)
		{
			var res int32 = 1
			for ; res <= resOffset; res++ {
				var resWidth Tint64_t = X_ipow(tls, int64(7), int64(resOffset-res))
				if inPent != 0 {
					// While we are inside a parent pentagon, we need to check if
					// this cell is a pentagon, and if not, we need to offset its
					// digit to account for the skipped direction
					var pentWidth Tint64_t = int64(1) + int64(5)*(resWidth-int64(1))/int64(6)
					if idx < pentWidth {
						*(*TH3Index)(unsafe.Pointer(child)) = *(*TH3Index)(unsafe.Pointer(child)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(uint64(0))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
					} else {
						idx = idx - pentWidth
						inPent = uint8(Dfalse)
						*(*TH3Index)(unsafe.Pointer(child)) = *(*TH3Index)(unsafe.Pointer(child)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(idx/resWidth+int64(2))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
						idx = idx % resWidth
					}
				} else {
					// We're no longer inside a pentagon, continue as for hex
					*(*TH3Index)(unsafe.Pointer(child)) = *(*TH3Index)(unsafe.Pointer(child)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(idx/resWidth)<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
					idx = idx % resWidth
				}
			}
		}
	} else {
		// Hexagon tile logic. Offsets are simple powers of 7
		{
			var res int32 = 1
			for ; res <= resOffset; res++ {
				var resWidth Tint64_t = X_ipow(tls, int64(7), int64(resOffset-res))
				*(*TH3Index)(unsafe.Pointer(child)) = *(*TH3Index)(unsafe.Pointer(child)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(idx/resWidth)<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
				idx = idx % resWidth
			}
		}
	}

	return E_SUCCESS
}

// extract the `res` digit (0--7) of the current cell
func _getResDigit(tls *libc.TLS, it uintptr, res int32) int32 { /* iterators.c:27:12: */
	return int32(TDirection((*TIterCellsChildren)(unsafe.Pointer(it)).Fh >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
}

// increment the digit (0--7) at location `res`
// H3_PER_DIGIT_OFFSET == 3
func _incrementResDigit(tls *libc.TLS, it uintptr, res int32) { /* iterators.c:33:13: */
	var val TH3Index = uint64(1)
	val <<= DH3_PER_DIGIT_OFFSET * (DMAX_H3_RES - res)
	*(*TH3Index)(unsafe.Pointer(it)) += val
}

// *
// Create a fully nulled-out child iterator for when an iterator is exhausted.
// This helps minimize the chance that a user will depend on the iterator
// internal state after it's exhausted, like the child resolution, for
// example.
func _null_iter(tls *libc.TLS) TIterCellsChildren { /* iterators.c:45:26: */
	return TIterCellsChildren{F_parentRes: -1, F_skipDigit: -1}
}

//*
//
// ## Logic for iterating through the children of a cell
//
// We'll describe the logic for ....
//
// - normal (non pentagon iteration)
// - pentagon iteration. define "pentagon digit"
//
//
// ### Cell Index Component Diagrams
//
// The lower 56 bits of an H3 Cell Index describe the following index components:
//
// - the cell resolution (4 bits)
// - the base cell number (7 bits)
// - the child cell digit for each resolution from 1 to 15 (3*15 = 45 bits)
//
// These are the bits we'll be focused on when iterating through child cells.
// To help describe the iteration logic, we'll use diagrams displaying the
// (decimal) values for each component like:
//
//                             child digit for resolution 2
//                            /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | ... |
// |-----|-------------|---|---|---|---|---|---|-----|
// |   9 |          17 | 5 | 3 | 0 | 6 | 2 | 1 | ... |
//
//
// ### Iteration through children of a hexagon (but not a pentagon)
//
// Iteration through the children of a *hexagon* (but not a pentagon)
// simply involves iterating through all the children values (0--6)
// for each child digit (up to the child's resolution).
//
// For example, suppose a resolution 3 hexagon index has the following
// components:
//                                 parent resolution
//                                /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | ... |
// |-----|-------------|---|---|---|---|---|---|-----|
// |   3 |          17 | 3 | 5 | 1 | 7 | 7 | 7 | ... |
//
// The iteration through all children of resolution 6 would look like:
//
//
//                                 parent res  child res
//                                /           /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ... |
// |-----|-------------|---|---|---|---|---|---|---|---|-----|
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 0 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 1 | 7 | 7 | ... |
// | ... |             |   |   |   |   |   |   |   |   |     |
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 6 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 1 | 0 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 1 | 1 | 7 | 7 | ... |
// | ... |             |   |   |   |   |   |   |   |   |     |
// | 6   |          17 | 3 | 5 | 1 | 6 | 6 | 6 | 7 | 7 | ... |
//
//
// ### Step sequence on a *pentagon* cell
//
// Pentagon cells have a base cell number (e.g., 97) corresponding to a
// resolution 0 pentagon, and have all zeros from digit 1 to the digit
// corresponding to the cell's resolution.
// (We'll drop the ellipses from now on, knowing that digits should contain
// 7's beyond the cell resolution.)
//
//                             parent res      child res
//                            /               /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 0 |
//
// Iteration through children of a *pentagon* is almost the same
// as *hexagon* iteration, except that we skip the *first* 1 value
// that appears in the "skip digit". This corresponds to the fact
// that a pentagon only has 6 children, which are denoted with
// the numbers {0,2,3,4,5,6}.
//
// The skip digit starts at the child resolution position.
// When iterating through children more than one resolution below
// the parent, we move the skip digit to the left
// (up to the next coarser resolution) each time we skip the 1 value
// in that digit.
//
// Iteration would start like:
//
//                             parent res      child res
//                            /               /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 0 |
//                                                                                        skip digit
//
// Noticing we skip the 1 value and move the skip digit,
// the next iterate would be:
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 2 |
//                                                                                skip digit
//
// Iteration continues normally until we get to:
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 6 |
//                                                                                skip digit
//
// which is followed by (skipping the 1):
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 2 | 0 |
//                                                                        skip digit
//
// For the next iterate, we won't skip the `1` in the previous digit
// because it is no longer the skip digit:
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 2 | 1 |
//                                                                        skip digit
//
// Iteration continues normally until we're right before the next skip
// digit:
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 6 | 6 |
//                                                                        skip digit
//
// Which is followed by
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 2 | 0 | 0 |
//                                                                skip digit
//
// and so on.
//
//

// *
// Initialize a IterCellsChildren struct representing the sequence giving
// the children of cell `h` at resolution `childRes`.
//
// At any point in the iteration, starting once
// the struct is initialized, IterCellsChildren.h gives the current child.
//
// Also, IterCellsChildren.h == H3_NULL when all the children have been iterated
// through, or if the input to `iterInitParent` was invalid.
func XiterInitParent(tls *libc.TLS, h TH3Index, childRes int32) TIterCellsChildren { /* iterators.c:214:19: */
	var it TIterCellsChildren

	it.F_parentRes = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if childRes < it.F_parentRes || childRes > DMAX_H3_RES || h == uint64(DH3_NULL) {
		return _null_iter(tls)
	}

	it.Fh = X_zeroIndexDigits(tls, h, it.F_parentRes+1, childRes)
	it.Fh = it.Fh&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(childRes)<<DH3_RES_OFFSET

	if XisPentagon(tls, it.Fh) != 0 {
		// The skip digit skips `1` for pentagons.
		// The "_skipDigit" moves to the left as we count up from the
		// child resolution to the parent resolution.
		it.F_skipDigit = childRes
	} else {
		// if not a pentagon, we can ignore "skip digit" logic
		it.F_skipDigit = -1
	}

	return it
}

// *
// Step a IterCellsChildren to the next child cell.
// When the iteration is over, IterCellsChildren.h will be H3_NULL.
// Handles iterating through hexagon and pentagon cells.
func XiterStepChild(tls *libc.TLS, it uintptr) { /* iterators.c:244:6: */
	// once h == H3_NULL, the iterator returns an infinite sequence of H3_NULL
	if (*TIterCellsChildren)(unsafe.Pointer(it)).Fh == uint64(DH3_NULL) {
		return
	}

	var childRes int32 = int32((*TIterCellsChildren)(unsafe.Pointer(it)).Fh & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	_incrementResDigit(tls, it, childRes)

	{
		var i int32 = childRes
		for ; i >= (*TIterCellsChildren)(unsafe.Pointer(it)).F_parentRes; i-- {
			if i == (*TIterCellsChildren)(unsafe.Pointer(it)).F_parentRes {
				// if we're modifying the parent resolution digit, then we're done
				*(*TIterCellsChildren)(unsafe.Pointer(it)) = _null_iter(tls)
				return
			}

			// PENTAGON_SKIPPED_DIGIT == 1
			if i == (*TIterCellsChildren)(unsafe.Pointer(it)).F_skipDigit && _getResDigit(tls, it, i) == PENTAGON_SKIPPED_DIGIT {
				// Then we are iterating through the children of a pentagon cell.
				// All children of a pentagon have the property that the first
				// nonzero digit between the parent and child resolutions is
				// not 1.
				// I.e., we never see a sequence like 00001.
				// Thus, we skip the `1` in this digit.
				_incrementResDigit(tls, it, i)
				*(*int32)(unsafe.Pointer(it + 12)) -= 1
				return
			}

			// INVALID_DIGIT == 7
			if _getResDigit(tls, it, i) == INVALID_DIGIT {
				_incrementResDigit(tls,
					it, i) // zeros out it[i] and increments it[i-1] by 1
			} else {
				break
			}
		}
	}
}

// create iterator for children of base cell at given resolution
func XiterInitBaseCellNum(tls *libc.TLS, baseCellNum int32, childRes int32) TIterCellsChildren { /* iterators.c:284:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if baseCellNum < 0 || baseCellNum >= DNUM_BASE_CELLS || childRes < 0 || childRes > DMAX_H3_RES {
		return _null_iter(tls)
	}
	// var baseCell TH3Index at bp, 8

	XsetH3Index(tls, bp, 0, baseCellNum, uint32(0))

	return XiterInitParent(tls, *(*TH3Index)(unsafe.Pointer(bp /* baseCell */)), childRes)
}

// create iterator for all cells at given resolution
func XiterInitRes(tls *libc.TLS, res int32) TIterCellsResolution { /* iterators.c:297:21: */
	var itC = XiterInitBaseCellNum(tls, 0, res)

	var itR = TIterCellsResolution{Fh: itC.Fh, F_res: res, F_itC: itC}

	return itR
}

func XiterStepRes(tls *libc.TLS, itR uintptr) { /* iterators.c:306:6: */
	// reached the end of over iterator; emits H3_NULL from now on
	if (*TIterCellsResolution)(unsafe.Pointer(itR)).Fh == uint64(DH3_NULL) {
		return
	}

	// step child iterator
	XiterStepChild(tls, itR+16)

	// If the child iterator is exhausted and there are still
	// base cells remaining, we initialize the next base cell child iterator
	if (*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC.Fh == uint64(DH3_NULL) && (*TIterCellsResolution)(unsafe.Pointer(itR)).F_baseCellNum+1 < DNUM_BASE_CELLS {
		*(*int32)(unsafe.Pointer(itR + 8)) += 1
		(*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC = XiterInitBaseCellNum(tls, (*TIterCellsResolution)(unsafe.Pointer(itR)).F_baseCellNum, (*TIterCellsResolution)(unsafe.Pointer(itR)).F_res)
	}

	// This overall iterator reflects the next cell in the child iterator.
	// Note: This sets itR->h = H3_NULL if the base cells were
	// exhausted in the check above.
	(*TIterCellsResolution)(unsafe.Pointer(itR)).Fh = (*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC.Fh
}

// *
// Normalizes radians to a value between 0.0 and two PI.
//
// @param rads The input radians value.
// @return The normalized radians value.
func X_posAngleRads(tls *libc.TLS, rads float64) float64 { /* latLng.c:36:8: */
	var tmp float64 = func() float64 {
		if rads < 0.0 {
			return rads + 6.28318530717958647692528676655900576839433
		}
		return rads
	}()
	if rads >= 6.28318530717958647692528676655900576839433 {
		tmp = tmp - 6.28318530717958647692528676655900576839433
	}
	return tmp
}

// *
// Determines if the components of two spherical coordinates are within some
// threshold distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @param threshold The threshold distance.
// @return Whether or not the two coordinates are within the threshold distance
//
//	of each other.
func XgeoAlmostEqualThreshold(tls *libc.TLS, p1 uintptr, p2 uintptr, threshold float64) uint8 { /* latLng.c:52:6: */
	return uint8(libc.Bool32(libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat-(*TLatLng)(unsafe.Pointer(p2)).Flat) < threshold && libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng-(*TLatLng)(unsafe.Pointer(p2)).Flng) < threshold))
}

// *
// Determines if the components of two spherical coordinates are within our
// standard epsilon distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return Whether or not the two coordinates are within the epsilon distance
//
//	of each other.
func XgeoAlmostEqual(tls *libc.TLS, p1 uintptr, p2 uintptr) uint8 { /* latLng.c:67:6: */
	return XgeoAlmostEqualThreshold(tls, p1, p2, float64(.000000001)*0.0174532925199432957692369076848861271111)
}

// *
// Set the components of spherical coordinates in decimal degrees.
//
// @param p The spherical coordinates.
// @param latDegs The desired latitude in decimal degrees.
// @param lngDegs The desired longitude in decimal degrees.
func XsetGeoDegs(tls *libc.TLS, p uintptr, latDegs float64, lngDegs float64) { /* latLng.c:78:6: */
	X_setGeoRads(tls, p, XdegsToRads(tls, latDegs),
		XdegsToRads(tls, lngDegs))
}

// *
// Set the components of spherical coordinates in radians.
//
// @param p The spherical coordinates.
// @param latRads The desired latitude in decimal radians.
// @param lngRads The desired longitude in decimal radians.
func X_setGeoRads(tls *libc.TLS, p uintptr, latRads float64, lngRads float64) { /* latLng.c:90:6: */
	(*TLatLng)(unsafe.Pointer(p)).Flat = latRads
	(*TLatLng)(unsafe.Pointer(p)).Flng = lngRads
}

// *
// Convert from decimal degrees to radians.
//
// @param degrees The decimal degrees.
// @return The corresponding radians.
func XdegsToRads(tls *libc.TLS, degrees float64) float64 { /* latLng.c:101:8: */
	return degrees * 0.0174532925199432957692369076848861271111
}

// *
// Convert from radians to decimal degrees.
//
// @param radians The radians.
// @return The corresponding decimal degrees.
func XradsToDegs(tls *libc.TLS, radians float64) float64 { /* latLng.c:109:8: */
	return radians * 57.29577951308232087679815481410517033240547
}

// *
// constrainLat makes sure latitudes are in the proper bounds
//
// @param lat The original lat value
// @return The corrected lat value
func XconstrainLat(tls *libc.TLS, lat float64) float64 { /* latLng.c:117:8: */
	for lat > 1.57079632679489661923 {
		lat = lat - 3.14159265358979323846
	}
	return lat
}

// *
// constrainLng makes sure longitudes are in the proper bounds
//
// @param lng The origin lng value
// @return The corrected lng value
func XconstrainLng(tls *libc.TLS, lng float64) float64 { /* latLng.c:130:8: */
	for lng > 3.14159265358979323846 {
		lng = lng - float64(float64(2))*3.14159265358979323846
	}
	for lng < -3.14159265358979323846 {
		lng = lng + float64(float64(2))*3.14159265358979323846
	}
	return lng
}

// *
// The great circle distance in radians between two spherical coordinates.
//
// This function uses the Haversine formula.
// For math details, see:
//
//	https://en.wikipedia.org/wiki/Haversine_formula
//	https://www.movable-type.co.uk/scripts/latlong.html
//
// @param  a  the first lat/lng pair (in radians)
// @param  b  the second lat/lng pair (in radians)
//
// @return    the great circle distance in radians between a and b
func XgreatCircleDistanceRads(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:153:8: */
	var sinLat float64 = libc.Xsin(tls, ((*TLatLng)(unsafe.Pointer(b)).Flat-(*TLatLng)(unsafe.Pointer(a)).Flat)/2.0)
	var sinLng float64 = libc.Xsin(tls, ((*TLatLng)(unsafe.Pointer(b)).Flng-(*TLatLng)(unsafe.Pointer(a)).Flng)/2.0)

	var A float64 = sinLat*sinLat + libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(a)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(b)).Flat)*sinLng*sinLng

	return float64(2) * libc.Xatan2(tls, libc.Xsqrt(tls, A), libc.Xsqrt(tls, float64(1)-A))
}

// *
// The great circle distance in kilometers between two spherical coordinates.
func XgreatCircleDistanceKm(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:165:8: */
	return XgreatCircleDistanceRads(tls, a, b) * 6371.007180918475
}

// *
// The great circle distance in meters between two spherical coordinates.
func XgreatCircleDistanceM(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:172:8: */
	return XgreatCircleDistanceKm(tls, a, b) * float64(1000)
}

// *
// Determines the azimuth to p2 from p1 in radians.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return The azimuth in radians from p1 to p2.
func X_geoAzimuthRads(tls *libc.TLS, p1 uintptr, p2 uintptr) float64 { /* latLng.c:183:8: */
	return libc.Xatan2(tls, libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flng-(*TLatLng)(unsafe.Pointer(p1)).Flng),
		libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)-libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flng-(*TLatLng)(unsafe.Pointer(p1)).Flng))
}

// *
// Computes the point on the sphere a specified azimuth and distance from
// another point.
//
// @param p1 The first spherical coordinates.
// @param az The desired azimuth from p1.
// @param distance The desired distance from p1, must be non-negative.
// @param p2 The spherical coordinates at the desired azimuth and distance from
// p1.
func X_geoAzDistanceRads(tls *libc.TLS, p1 uintptr, az float64, distance float64, p2 uintptr) { /* latLng.c:199:6: */
	if distance < 0.0000000000000001 {
		*(*TLatLng)(unsafe.Pointer(p2)) = *(*TLatLng)(unsafe.Pointer(p1))
		return
	}
	var sinlat float64
	var sinlng float64
	var coslng float64

	az = X_posAngleRads(tls, az)

	// check for due north/south azimuth
	if az < 0.0000000000000001 || libc.Xfabs(tls, az-3.14159265358979323846) < 0.0000000000000001 {
		if az < 0.0000000000000001 { // due north
			(*TLatLng)(unsafe.Pointer(p2)).Flat = (*TLatLng)(unsafe.Pointer(p1)).Flat + distance
		} else { // due south
			(*TLatLng)(unsafe.Pointer(p2)).Flat = (*TLatLng)(unsafe.Pointer(p1)).Flat - distance
		}

		if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else {
			(*TLatLng)(unsafe.Pointer(p2)).Flng = XconstrainLng(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng)
		}
	} else {
		sinlat = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, distance) + libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, distance)*libc.Xcos(tls, az)
		if sinlat > 1.0 {
			sinlat = 1.0
		}
		if sinlat < -1.0 {
			sinlat = -1.0
		}
		(*TLatLng)(unsafe.Pointer(p2)).Flat = libc.Xasin(tls, sinlat)
		if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else {
			sinlng = libc.Xsin(tls, az) * libc.Xsin(tls, distance) / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)
			coslng = (libc.Xcos(tls, distance) - libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)) / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat) / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)
			if sinlng > 1.0 {
				sinlng = 1.0
			}
			if sinlng < -1.0 {
				sinlng = -1.0
			}
			if coslng > 1.0 {
				coslng = 1.0
			}
			if coslng < -1.0 {
				coslng = -1.0
			}
			(*TLatLng)(unsafe.Pointer(p2)).Flng = XconstrainLng(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng+libc.Xatan2(tls, sinlng, coslng))
		}
	}
}

// The following functions provide meta information about the H3 hexagons at
// each zoom level. Since there are only 16 total levels, these are current
// handled with hardwired static values, but it may be worthwhile to put these
// static values into another file that can be autogenerated by source code in
// the future.

func XgetHexagonAreaAvgKm2(tls *libc.TLS, res int32, out uintptr) TH3Error { /* latLng.c:263:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = areas[res]
	return E_SUCCESS
}

var areas = [16]float64{
	4.357449416078383e+06, 6.097884417941332e+05, 8.680178039899720e+04,
	1.239343465508816e+04, 1.770347654491307e+03, 2.529038581819449e+02,
	3.612906216441245e+01, 5.161293359717191e+00, 7.373275975944177e-01,
	1.053325134272067e-01, 1.504750190766435e-02, 2.149643129451879e-03,
	3.070918756316060e-04, 4.387026794728296e-05, 6.267181135324313e-06,
	8.953115907605790e-07} /* latLng.c:264:25 */

func XgetHexagonAreaAvgM2(tls *libc.TLS, res int32, out uintptr) TH3Error { /* latLng.c:278:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = areas1[res]
	return E_SUCCESS
}

var areas1 = [16]float64{
	4.357449416078390e+12, 6.097884417941339e+11, 8.680178039899731e+10,
	1.239343465508818e+10, 1.770347654491309e+09, 2.529038581819452e+08,
	3.612906216441250e+07, 5.161293359717198e+06, 7.373275975944188e+05,
	1.053325134272069e+05, 1.504750190766437e+04, 2.149643129451882e+03,
	3.070918756316063e+02, 4.387026794728301e+01, 6.267181135324322e+00,
	8.953115907605802e-01} /* latLng.c:279:25 */

func XgetHexagonEdgeLengthAvgKm(tls *libc.TLS, res int32, out uintptr) TH3Error { /* latLng.c:293:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = lens[res]
	return E_SUCCESS
}

var lens = [16]float64{
	1107.712591, 418.6760055, 158.2446558, 59.81085794,
	22.6063794, 8.544408276, 3.229482772, 1.220629759,
	0.461354684, 0.174375668, 0.065907807, 0.024910561,
	0.009415526, 0.003559893, 0.001348575, 0.000509713} /* latLng.c:294:25 */

func XgetHexagonEdgeLengthAvgM(tls *libc.TLS, res int32, out uintptr) TH3Error { /* latLng.c:306:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = lens1[res]
	return E_SUCCESS
}

var lens1 = [16]float64{
	1107712.591, 418676.0055, 158244.6558, 59810.85794,
	22606.3794, 8544.408276, 3229.482772, 1220.629759,
	461.3546837, 174.3756681, 65.90780749, 24.9105614,
	9.415526211, 3.559893033, 1.348574562, 0.509713273} /* latLng.c:307:25 */

func XgetNumCells(tls *libc.TLS, res int32, out uintptr) TH3Error { /* latLng.c:319:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*Tint64_t)(unsafe.Pointer(out)) = int64(2) + int64(120)*X_ipow(tls, int64(7), int64(res))
	return E_SUCCESS
}

// *
// Surface area in radians^2 of spherical triangle on unit sphere.
//
// For the math, see:
// https://en.wikipedia.org/wiki/Spherical_trigonometry#Area_and_spherical_excess
//
// @param   a  length of triangle side A in radians
// @param   b  length of triangle side B in radians
// @param   c  length of triangle side C in radians
//
// @return     area in radians^2 of triangle on unit sphere
func XtriangleEdgeLengthsToArea(tls *libc.TLS, a float64, b float64, c float64) float64 { /* latLng.c:339:8: */
	var s float64 = (a + b + c) / float64(2)

	a = (s - a) / float64(2)
	b = (s - b) / float64(2)
	c = (s - c) / float64(2)
	s = s / float64(2)

	return float64(4) * libc.Xatan(tls, libc.Xsqrt(tls, libc.Xtan(tls, s)*libc.Xtan(tls, a)*libc.Xtan(tls, b)*libc.Xtan(tls, c)))
}

// *
// Compute area in radians^2 of a spherical triangle, given its vertices.
//
// @param   a  vertex lat/lng in radians
// @param   b  vertex lat/lng in radians
// @param   c  vertex lat/lng in radians
//
// @return     area of triangle on unit sphere, in radians^2
func XtriangleArea(tls *libc.TLS, a uintptr, b uintptr, c uintptr) float64 { /* latLng.c:359:8: */
	return XtriangleEdgeLengthsToArea(tls, XgreatCircleDistanceRads(tls, a, b),
		XgreatCircleDistanceRads(tls, b, c),
		XgreatCircleDistanceRads(tls, c, a))
}

// *
// Area of H3 cell in radians^2.
//
// The area is calculated by breaking the cell into spherical triangles and
// summing up their areas. Note that some H3 cells (hexagons and pentagons)
// are irregular, and have more than 6 or 5 sides.
//
// todo: optimize the computation by re-using the edges shared between triangles
//
// @param   cell  H3 cell
// @param    out  cell area in radians^2
// @return        E_SUCCESS on success, or an error code otherwise
func XcellAreaRads2(tls *libc.TLS, cell TH3Index, out uintptr) TH3Error { /* latLng.c:378:9: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var c TLatLng at bp, 16

	// var cb TCellBoundary at bp+16, 168

	var err TH3Error = XcellToLatLng(tls, cell, bp)
	if err != 0 {
		return err
	}
	err = XcellToBoundary(tls, cell, bp+16)
	if func() int32 {
		if err != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+462, uint32(386), uintptr(unsafe.Pointer(&__func__13)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Uncoverable because cellToLatLng will have returned an error already
		return err
	}

	var area float64 = 0.0
	{
		var i int32 = 0
		for ; i < (*TCellBoundary)(unsafe.Pointer(bp+16)).FnumVerts; i++ {
			var j int32 = (i + 1) % (*TCellBoundary)(unsafe.Pointer(bp+16)).FnumVerts
			area = area + XtriangleArea(tls, bp+16+8+uintptr(i)*16, bp+16+8+uintptr(j)*16, bp)
		}
	}

	*(*float64)(unsafe.Pointer(out)) = area
	return E_SUCCESS
}

var __func__13 = *(*[14]int8)(unsafe.Pointer(ts + 488)) /* latLng.c:378:61 */

// *
// Area of H3 cell in kilometers^2.
func XcellAreaKm2(tls *libc.TLS, cell TH3Index, out uintptr) TH3Error { /* latLng.c:404:9: */
	var err TH3Error = XcellAreaRads2(tls, cell, out)
	if !(err != 0) {
		*(*float64)(unsafe.Pointer(out)) = *(*float64)(unsafe.Pointer(out)) * 6371.007180918475 * 6371.007180918475
	}
	return err
}

// *
// Area of H3 cell in meters^2.
func XcellAreaM2(tls *libc.TLS, cell TH3Index, out uintptr) TH3Error { /* latLng.c:415:9: */
	var err TH3Error = XcellAreaKm2(tls, cell, out)
	if !(err != 0) {
		*(*float64)(unsafe.Pointer(out)) = *(*float64)(unsafe.Pointer(out)) * float64(1000) * float64(1000)
	}
	return err
}

// *
// Length of a directed edge in radians.
//
// @param   edge  H3 directed edge
//
// @return        length in radians
func XedgeLengthRads(tls *libc.TLS, edge TH3Index, length uintptr) TH3Error { /* latLng.c:430:9: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var cb TCellBoundary at bp, 168

	var err TH3Error = XdirectedEdgeToBoundary(tls, edge, bp)
	if err != 0 {
		return err
	}

	*(*float64)(unsafe.Pointer(length)) = 0.0
	{
		var i int32 = 0
		for ; i < (*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts-1; i++ {
			*(*float64)(unsafe.Pointer(length)) += XgreatCircleDistanceRads(tls, bp+8+uintptr(i)*16, bp+8+uintptr(i+1)*16)
		}
	}

	return E_SUCCESS
}

// *
// Length of a directed edge in kilometers.
func XedgeLengthKm(tls *libc.TLS, edge TH3Index, length uintptr) TH3Error { /* latLng.c:450:9: */
	var err TH3Error = XedgeLengthRads(tls, edge, length)
	*(*float64)(unsafe.Pointer(length)) = *(*float64)(unsafe.Pointer(length)) * 6371.007180918475
	return err
}

// *
// Length of a directed edge in meters.
func XedgeLengthM(tls *libc.TLS, edge TH3Index, length uintptr) TH3Error { /* latLng.c:459:9: */
	var err TH3Error = XedgeLengthKm(tls, edge, length)
	*(*float64)(unsafe.Pointer(length)) = *(*float64)(unsafe.Pointer(length)) * float64(1000)
	return err
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// *
// Add a linked polygon to the current polygon
// @param  polygon Polygon to add link to
// @return         Pointer to new polygon
func XaddNewLinkedPolygon(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:34:18: */
	if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext == uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+502, ts+524, uint32(35), uintptr(unsafe.Pointer(&__func__14)))
	}
	var next uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoPolygon{})))
	if next != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+553, ts+524, uint32(37), uintptr(unsafe.Pointer(&__func__14)))
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext = next
	return next
}

var __func__14 = *(*[20]int8)(unsafe.Pointer(ts + 566)) /* linkedGeo.c:34:66 */

// *
// Add a new linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddNewLinkedLoop(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:47:15: */
	var loop uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoLoop{})))
	if loop != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+586, ts+524, uint32(49), uintptr(unsafe.Pointer(&__func__15)))
	}
	return XaddLinkedLoop(tls, polygon, loop)
}

var __func__15 = *(*[17]int8)(unsafe.Pointer(ts + 599)) /* linkedGeo.c:47:60 */

// *
// Add an existing linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddLinkedLoop(tls *libc.TLS, polygon uintptr, loop uintptr) uintptr { /* linkedGeo.c:58:15: */
	var last uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+616, ts+524, uint32(61), uintptr(unsafe.Pointer(&__func__16)))
		}
		(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst = loop
	} else {
		(*TLinkedGeoLoop)(unsafe.Pointer(last)).Fnext = loop
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast = loop
	return loop
}

var __func__16 = *(*[14]int8)(unsafe.Pointer(ts + 639)) /* linkedGeo.c:58:78 */

// *
// Add a new linked coordinate to the current loop
// @param  loop   Loop to add coordinate to
// @param  vertex Coordinate to add
// @return        Pointer to the coordinate
func XaddLinkedCoord(tls *libc.TLS, loop uintptr, vertex uintptr) uintptr { /* linkedGeo.c:76:14: */
	var coord uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TLinkedLatLng{})))
	if coord != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+653, ts+524, uint32(78), uintptr(unsafe.Pointer(&__func__17)))
	}
	*(*TLinkedLatLng)(unsafe.Pointer(coord)) = TLinkedLatLng{Fvertex: *(*TLatLng)(unsafe.Pointer(vertex))}
	var last uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+667, ts+524, uint32(82), uintptr(unsafe.Pointer(&__func__17)))
		}
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst = coord
	} else {
		(*TLinkedLatLng)(unsafe.Pointer(last)).Fnext = coord
	}
	(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast = coord
	return coord
}

var __func__17 = *(*[15]int8)(unsafe.Pointer(ts + 687)) /* linkedGeo.c:76:73 */

// *
// Free all allocated memory for a linked geo loop. The caller is
// responsible for freeing memory allocated to input loop struct.
// @param loop Loop to free
func XdestroyLinkedGeoLoop(tls *libc.TLS, loop uintptr) { /* linkedGeo.c:96:6: */
	var nextCoord uintptr
	{
		var currentCoord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		for ; currentCoord != uintptr(0); currentCoord = nextCoord {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
			libc.Xfree(tls, currentCoord)
		}
	}
}

// *
// Free all allocated memory for a linked geo structure. The caller is
// responsible for freeing memory allocated to input polygon struct.
// @param polygon Pointer to the first polygon in the structure
func XdestroyLinkedMultiPolygon(tls *libc.TLS, polygon uintptr) { /* linkedGeo.c:110:6: */
	// flag to skip the input polygon
	var skip uint8 = uint8(Dtrue)
	var nextPolygon uintptr
	var nextLoop uintptr
	{
		var currentPolygon uintptr = polygon
		for ; currentPolygon != uintptr(0); currentPolygon = nextPolygon {
			{
				var currentLoop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Ffirst
				for ; currentLoop != uintptr(0); currentLoop = nextLoop {
					XdestroyLinkedGeoLoop(tls, currentLoop)
					nextLoop = (*TLinkedGeoLoop)(unsafe.Pointer(currentLoop)).Fnext
					libc.Xfree(tls, currentLoop)
				}
			}
			nextPolygon = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Fnext
			if skip != 0 {
				// do not free the input polygon
				skip = uint8(Dfalse)
			} else {
				libc.Xfree(tls, currentPolygon)
			}
		}
	}
}

// *
// Count the number of polygons in a linked list
// @param  polygon Starting polygon
// @return         Count
func XcountLinkedPolygons(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:138:5: */
	var count int32 = 0
	for polygon != uintptr(0) {
		count++
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
	}
	return count
}

// *
// Count the number of linked loops in a polygon
// @param  polygon Polygon to count loops for
// @return         Count
func XcountLinkedLoops(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:152:5: */
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst
	var count int32 = 0
	for loop != uintptr(0) {
		count++
		loop = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
	}
	return count
}

// *
// Count the number of coordinates in a loop
// @param  loop Loop to count coordinates for
// @return      Count
func XcountLinkedCoords(tls *libc.TLS, loop uintptr) int32 { /* linkedGeo.c:167:5: */
	var coord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
	var count int32 = 0
	for coord != uintptr(0) {
		count++
		coord = (*TLinkedLatLng)(unsafe.Pointer(coord)).Fnext
	}
	return count
}

// *
// Count the number of polygons containing a given loop.
// @param  loop         Loop to count containers for
// @param  polygons     Polygons to test
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the test array
// @return              Number of polygons containing the loop
func countContainers(tls *libc.TLS, loop uintptr, polygons uintptr, bboxes uintptr, polygonCount int32) int32 { /* linkedGeo.c:185:12: */
	var containerCount int32 = 0
	{
		var i int32 = 0
		for ; i < polygonCount; i++ {
			if loop != (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst && XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, *(*uintptr)(unsafe.Pointer(bboxes + uintptr(i)*8)),
				(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
				containerCount++
			}
		}
	}
	return containerCount
}

// *
// Given a list of nested containers, find the one most deeply nested.
// @param  polygons     Polygon containers to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the list
// @return              Deepest container, or null if list is empty
func findDeepestContainer(tls *libc.TLS, polygons uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:206:31: */
	// Set the initial return value to the first candidate
	var parent uintptr
	if polygonCount > 0 {
		parent = *(*uintptr)(unsafe.Pointer(polygons))
	} else {
		parent = uintptr(0)
	}

	// If we have multiple polygons, they must be nested inside each other.
	// Find the innermost polygon by taking the one with the most containers
	// in the list.
	if polygonCount > 1 {
		var max int32 = -1
		{
			var i int32 = 0
			for ; i < polygonCount; i++ {
				var count int32 = countContainers(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, polygons, bboxes,
					polygonCount)
				if count > max {
					parent = *(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8))
					max = count
				}
			}
		}
	}

	return parent
}

// *
// Find the polygon to which a given hole should be allocated. Note that this
// function will return null if no parent is found.
// @param  loop         Inner loop describing a hole
// @param  polygon      Head of a linked list of polygons to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons to check
// @return              Pointer to parent polygon, or null if not found
func findPolygonForHole(tls *libc.TLS, loop uintptr, polygon uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:239:31: */
	// Early exit with no polygons
	if polygonCount == 0 {
		return uintptr(0)
	}
	// Initialize arrays for candidate loops and their bounding boxes
	var candidates uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidates != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+702, ts+524, uint32(249), uintptr(unsafe.Pointer(&__func__18)))
	}
	var candidateBBoxes uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidateBBoxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+721, ts+524, uint32(252), uintptr(unsafe.Pointer(&__func__18)))
	}

	// Find all polygons that contain the loop
	var candidateCount int32 = 0
	var index int32 = 0
	for polygon != 0 {
		// We are guaranteed not to overlap, so just test the first point
		if XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst, bboxes+uintptr(index)*32,
			(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
			*(*uintptr)(unsafe.Pointer(candidates + uintptr(candidateCount)*8)) = polygon
			*(*uintptr)(unsafe.Pointer(candidateBBoxes + uintptr(candidateCount)*8)) = bboxes + uintptr(index)*32
			candidateCount++
		}
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
		index++
	}

	// The most deeply nested container is the immediate parent
	var parent uintptr = findDeepestContainer(tls, candidates, candidateBBoxes, candidateCount)

	// Free allocated memory
	libc.Xfree(tls, candidates)
	libc.Xfree(tls, candidateBBoxes)

	return parent
}

var __func__18 = *(*[19]int8)(unsafe.Pointer(ts + 745)) /* linkedGeo.c:241:49 */

// *
// Normalize a LinkedGeoPolygon in-place into a structure following GeoJSON
// MultiPolygon rules: Each polygon must have exactly one outer loop, which
// must be first in the list, followed by any holes. Holes in this algorithm
// are identified by winding order (holes are clockwise), which is guaranteed
// by the h3SetToVertexGraph algorithm.
//
// Input to this function is assumed to be a single polygon including all
// loops to normalize. It's assumed that a valid arrangement is possible.
//
// @param root Root polygon including all loops
// @return     0 on success, or an error code > 0 for invalid input
func XnormalizeMultiPolygon(tls *libc.TLS, root uintptr) TH3Error { /* linkedGeo.c:293:9: */
	// We assume that the input is a single polygon with loops;
	// if it has multiple polygons, don't touch it
	if (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Fnext != 0 {
		return E_FAILED
	}

	// Count loops, exiting early if there's only one
	var loopCount int32 = XcountLinkedLoops(tls, root)
	if loopCount <= 1 {
		return E_SUCCESS
	}

	var resultCode TH3Error = E_SUCCESS
	var polygon uintptr = uintptr(0)
	var next uintptr
	var innerCount int32 = 0
	var outerCount int32 = 0

	// Create an array to hold all of the inner loops. Note that
	// this array will never be full, as there will always be fewer
	// inner loops than outer loops.
	var innerLoops uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if innerLoops != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+764, ts+524, uint32(317), uintptr(unsafe.Pointer(&__func__19)))
	}

	// Create an array to hold the bounding boxes for the outer loops
	var bboxes uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(TBBox{})))
	if bboxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+783, ts+524, uint32(321), uintptr(unsafe.Pointer(&__func__19)))
	}

	// Get the first loop and unlink it from root
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Ffirst
	*(*TLinkedGeoPolygon)(unsafe.Pointer(root)) = TLinkedGeoPolygon{}

	// Iterate over all loops, moving inner loops into an array and
	// assigning outer loops to new polygons
	for loop != 0 {
		if XisClockwiseLinkedGeoLoop(tls, loop) != 0 {
			*(*uintptr)(unsafe.Pointer(innerLoops + uintptr(innerCount)*8)) = loop
			innerCount++
		} else {
			if polygon == uintptr(0) {
				polygon = root
			} else {
				polygon = XaddNewLinkedPolygon(tls, polygon)
			}
			XaddLinkedLoop(tls, polygon, loop)
			XbboxFromLinkedGeoLoop(tls, loop, bboxes+uintptr(outerCount)*32)
			outerCount++
		}
		// get the next loop and unlink it from this one
		next = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext = uintptr(0)
		loop = next
	}

	// Find polygon for each inner loop and assign the hole to it
	{
		var i int32 = 0
		for ; i < innerCount; i++ {
			polygon = findPolygonForHole(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)), root,
				bboxes, outerCount)
			if polygon != 0 {
				XaddLinkedLoop(tls, polygon, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
			} else {
				// If we can't find a polygon (possible with invalid input), then
				// we need to release the memory for the hole, because the loop has
				// been unlinked from the root and the caller will no longer have
				// a way to destroy it with destroyLinkedMultiPolygon.
				XdestroyLinkedGeoLoop(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				resultCode = E_FAILED
			}
		}
	}

	// Free allocated memory
	libc.Xfree(tls, innerLoops)
	libc.Xfree(tls, bboxes)

	return resultCode
}

var __func__19 = *(*[22]int8)(unsafe.Pointer(ts + 798)) /* linkedGeo.c:293:55 */

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TLatLng)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TLatLng)(unsafe.Pointer(coord)).Flng < float64(0) {
			return (*TLatLng)(unsafe.Pointer(coord)).Flng + 6.28318530717958647692528676655900576839433
		}
		return (*TLatLng)(unsafe.Pointer(coord)).Flng
	}()
	var a TLatLng
	var b TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If the latitude matches exactly, we'll hit an edge case where
		// the ray passes through the vertex twice on successive segment
		// checks. To avoid this, adjust the latiude northward if needed.
		//
		// NOTE: This currently means that a point at the north pole cannot
		// be contained in any polygon. This is acceptable in current usage,
		// because the point we test in this function at present is always
		// a cell center or vertex, and no cell has a center or vertex on the
		// north pole. If we need to expand this algo to more generic uses we
		// might need to handle this edge case.
		if lat == a.Flat || lat == b.Flat {
			lat = lat + 2.22044604925031308084726333618164062e-16
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
//   - Does not support polygons with two adjacent points > 180 degrees of
//     longitude apart. These will be interpreted as crossing the antimeridian.
//   - Does not currently support polygons containing a pole.
//
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:151:6: */
	// Early exit if there are no vertices
	if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLng float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLng float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lng float64
	var coord TLatLng
	var next TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		coord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		next = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex

		lat = coord.Flat
		lng = coord.Flng
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lng < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lng
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lng > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lng
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lng > float64(0) && lng < minPosLng {
			minPosLng = lng
		}
		if lng < float64(0) && lng > maxNegLng {
			maxNegLng = lng
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lng-next.Flng) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLng
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLng
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedLinkedGeoLoop(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:205:13: */
	var sum float64 = float64(0)
	var a TLatLng
	var b TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)
	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flng-b.Flng) > 3.14159265358979323846 {
			return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseLinkedGeoLoop(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:233:6: */
	return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dfalse))
}

// *
// Origin leading digit -> index leading digit -> rotations 60 cw
// Either being 1 (K axis) is invalid.
// No good default at 0.
var XPENTAGON_ROTATIONS = [7][7]int32{
	{0, -1, 0, 0, 0, 0, 0},       // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, -1, 0, 0, 0, 1, 0},       // 2
	{0, -1, 0, 0, 1, 1, 0},       // 3
	{0, -1, 0, 5, 0, 0, 0},       // 4
	{0, -1, 5, 5, 0, 0, 0},       // 5
	{0, -1, 0, 0, 0, 0, 0},       // 6
} /* localij.c:39:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when
// the origin is on a pentagon (regardless of the base cell of the index.)
var XPENTAGON_ROTATIONS_REVERSE = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 5, 0, 5, 0, 0, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:53:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_NONPOLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:67:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a polar pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_POLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 1, 1, 1, 1, 1},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 1, 0, 0, 1, 1, 1},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 1, 1, 0, 1, 1, 1},        // 6
} /* localij.c:81:11 */

// *
// Prohibited directions when unfolding a pentagon.
//
// Indexes by two directions, both relative to the pentagon base cell. The first
// is the direction of the origin index and the second is the direction of the
// index to unfold. Direction refers to the direction from base cell to base
// cell if the indexes are on different base cells, or the leading digit if
// within the pentagon base cell.
//
// This previously included a Class II/Class III check but these were removed
// due to failure cases. It's possible this could be restricted to a narrower
// set of a failure cases. Currently, the logic is any unfolding across more
// than one icosahedron face is not permitted.
var XFAILED_DIRECTIONS = [7][7]uint8{
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 0
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 1
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse)},   // 2
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue)},   // 3
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)},   // 4
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue)},   // 5
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse)},   // 6
} /* localij.c:105:12 */

// *
// Produces ijk+ coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param index Index to find the coordinates of
// @param out ijk+ coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func XcellToLocalIjk(tls *libc.TLS, origin TH3Index, h3 TH3Index, out uintptr) TH3Error { /* localij.c:132:9: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if res != int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return E_RES_MISMATCH
	}

	var originBaseCell int32 = int32(origin & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	var baseCell int32 = int32(h3 & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)

	if func() int32 {
		if originBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+820, uint32(142), uintptr(unsafe.Pointer(&__func__20)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || originBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+820, uint32(146), uintptr(unsafe.Pointer(&__func__20)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}

	// Direction from origin base cell to index base cell
	var dir TDirection = CENTER_DIGIT
	var revDir TDirection = CENTER_DIGIT
	if originBaseCell != baseCell {
		dir = X_getBaseCellDirection(tls, originBaseCell, baseCell)
		if dir == INVALID_DIGIT {
			// Base cells are not neighbors, can't unfold.
			return E_FAILED
		}
		revDir = X_getBaseCellDirection(tls, baseCell, originBaseCell)
		if revDir != INVALID_DIGIT {
		} else {
			libc.X__assert_fail(tls, ts+847, ts+820, uint32(161), uintptr(unsafe.Pointer(&__func__20)))
		}
	}

	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)
	var indexOnPent int32 = X_isBaseCellPentagon(tls, baseCell)

	*(*TFaceIJK)(unsafe.Pointer(bp /* indexFijk */)) = TFaceIJK{}
	if dir != CENTER_DIGIT {
		// Rotate index into the orientation of the origin base cell.
		// cw because we are undoing the rotation into that base cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if indexOnPent != 0 {
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					h3 = X_h3RotatePent60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)
					if revDir == K_AXES_DIGIT {
						revDir = X_rotate60cw(tls, revDir)
					}
				}
			}
		} else {
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					h3 = X_h3Rotate60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)
				}
			}
		}
	}
	// Face is unused. This produces coordinates in base cell coordinate space.
	X_h3ToFaceIjkWithInitializedFijk(tls, h3, bp)

	if dir != CENTER_DIGIT {
		if baseCell != originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+871, ts+820, uint32(191), uintptr(unsafe.Pointer(&__func__20)))
		}
		if !(originOnPent != 0 && indexOnPent != 0) {
		} else {
			libc.X__assert_fail(tls, ts+898, ts+820, uint32(192), uintptr(unsafe.Pointer(&__func__20)))
		}

		var pentagonRotations int32 = 0
		var directionRotations int32 = 0

		if originOnPent != 0 {
			var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))

			if originLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(dir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return E_FAILED
			}

			directionRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			pentagonRotations = directionRotations
		} else if indexOnPent != 0 {
			var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

			if indexLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(indexLeadingDigit)*7 + uintptr(revDir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return E_FAILED
			}

			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
		}

		if pentagonRotations < 0 || directionRotations < 0 {
			// This occurs when an invalid K axis digit is present
			return E_CELL_INVALID
		}

		{
			var i int32 = 0
			for ; i < pentagonRotations; i++ {
				X_ijkRotate60cw(tls, bp+4)
			}
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* offset */)) = TCoordIJK{}
		X_neighbor(tls, bp+16, dir)
		// Scale offset based on resolution
		{
			var r int32 = res - 1
			for ; r >= 0; r-- {
				if XisResolutionClassIII(tls, r+1) != 0 {
					// rotate ccw
					X_downAp7(tls, bp+16)
				} else {
					// rotate cw
					X_downAp7r(tls, bp+16)
				}
			}
		}

		{
			var i1 int32 = 0
			for ; i1 < directionRotations; i1++ {
				X_ijkRotate60cw(tls, bp+16)
			}
		}

		// Perform necessary translation
		X_ijkAdd(tls, bp+4, bp+16, bp+4)
		X_ijkNormalize(tls, bp+4)
	} else if originOnPent != 0 && indexOnPent != 0 {
		// If the origin and index are on pentagon, and we checked that the base
		// cells are the same or neighboring, then they must be the same base
		// cell.
		if baseCell == originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+929, ts+820, uint32(261), uintptr(unsafe.Pointer(&__func__20)))
		}

		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

		if originLeadingDigit == INVALID_DIGIT || indexLeadingDigit == INVALID_DIGIT {
			return E_CELL_INVALID
		}
		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(indexLeadingDigit))) != 0 {
			// TODO: We may be unfolding the pentagon incorrectly in this case;
			// return an error code until this is guaranteed to be correct.
			return E_FAILED
		}

		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))

		{
			var i int32 = 0
			for ; i < withinPentagonRotations; i++ {
				X_ijkRotate60cw(tls, bp+4)
			}
		}
	}

	*(*TCoordIJK)(unsafe.Pointer(out)) = (*TFaceIJK)(unsafe.Pointer(bp /* &indexFijk */)).Fcoord
	return E_SUCCESS
}

var __func__20 = *(*[15]int8)(unsafe.Pointer(ts + 956)) /* localij.c:132:67 */

// *
// Produces an index for ijk+ coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the coordinates are too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param ijk IJK+ Coordinates to find the index of
// @param out The index will be placed here on success
// @return 0 on success, or another value on failure.
func XlocalIjkToCell(tls *libc.TLS, origin TH3Index, ijk uintptr, out uintptr) TH3Error { /* localij.c:302:9: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var originBaseCell int32 = int32(origin & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if originBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+820, uint32(305), uintptr(unsafe.Pointer(&__func__21)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || originBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)

	// This logic is very similar to faceIjkToH3
	// initialize the index
	*(*TH3Index)(unsafe.Pointer(out)) = 35184372088831
	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		var dir TDirection = X_unitIjkToDigit(tls, ijk)
		if dir == INVALID_DIGIT {
			// out of range input - not a unit vector or zero vector
			return E_FAILED
		}

		var newBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
		if newBaseCell == DINVALID_BASE_CELL {
			// Moving in an invalid direction off a pentagon.
			return E_FAILED
		}
		*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(newBaseCell)<<DH3_BC_OFFSET
		return E_SUCCESS
	}

	// we need to find the correct base cell offset (if any) for this H3 index;
	// start with the passed in base cell and resolution res ijk coordinates
	// in that base cell's coordinate system
	*(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	{
		var r int32 = res - 1
		for ; r >= 0; r-- {
			*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
			// var lastCenter TCoordIJK at bp+12, 12

			if XisResolutionClassIII(tls, r+1) != 0 {
				// rotate ccw
				var upAp7Error TH3Error = X_upAp7Checked(tls, bp)
				if upAp7Error != 0 {
					return upAp7Error
				}
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7(tls, bp+12)
			} else {
				// rotate cw
				var upAp7rError TH3Error = X_upAp7rChecked(tls, bp)
				if upAp7rError != 0 {
					return upAp7rError
				}
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7r(tls, bp+12)
			}
			// var diff TCoordIJK at bp+36, 12

			X_ijkSub(tls, bp+24, bp+12, bp+36)
			X_ijkNormalize(tls, bp+36)

			*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_unitIjkToDigit(tls, bp+36))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
		}
	}

	// ijkCopy should now hold the IJK of the base cell in the
	// coordinate system of the current base cell

	if (*TCoordIJK)(unsafe.Pointer(bp)).Fi > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fj > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fk > 1 {
		// out of range input
		return E_FAILED
	}

	// lookup the correct base cell
	var dir TDirection = X_unitIjkToDigit(tls, bp)
	var baseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
	// If baseCell is invalid, it must be because the origin base cell is a
	// pentagon, and because pentagon base cells do not border each other,
	// baseCell must not be a pentagon.
	var indexOnPent int32 = func() int32 {
		if baseCell == DINVALID_BASE_CELL {
			return 0
		}
		return X_isBaseCellPentagon(tls, baseCell)
	}()

	if dir != CENTER_DIGIT {
		// If the index is in a warped direction, we need to unwarp the base
		// cell direction. There may be further need to rotate the index digits.
		var pentagonRotations int32 = 0
		if originOnPent != 0 {
			var originLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, origin)
			if originLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			{
				var i int32 = 0
				for ; i < pentagonRotations; i++ {
					dir = X_rotate60ccw(tls, dir)
				}
			}
			// The pentagon rotations are being chosen so that dir is not the
			// deleted direction. If it still happens, it means we're moving
			// into a deleted subsequence, so there is no index here.
			if dir == K_AXES_DIGIT {
				return E_PENTAGON
			}
			baseCell = X_getBaseCellNeighbor(tls, originBaseCell, dir)

			// indexOnPent does not need to be checked again since no pentagon
			// base cells border each other.
			if baseCell != DINVALID_BASE_CELL {
			} else {
				libc.X__assert_fail(tls, ts+971, ts+820, uint32(411), uintptr(unsafe.Pointer(&__func__21)))
			}
			if !(X_isBaseCellPentagon(tls, baseCell) != 0) {
			} else {
				libc.X__assert_fail(tls, ts+1001, ts+820, uint32(412), uintptr(unsafe.Pointer(&__func__21)))
			}
		}

		// Now we can determine the relation between the origin and target base
		// cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if baseCellRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+1032, ts+820, uint32(419), uintptr(unsafe.Pointer(&__func__21)))
		}

		// Adjust for pentagon warping within the base cell. The base cell
		// should be in the right location, so now we need to rotate the index
		// back. We might not need to check for errors since we would just be
		// double mapping.
		if indexOnPent != 0 {
			var revDir TDirection = X_getBaseCellDirection(tls, baseCell, originBaseCell)
			if revDir != INVALID_DIGIT {
			} else {
				libc.X__assert_fail(tls, ts+847, ts+820, uint32(428), uintptr(unsafe.Pointer(&__func__21)))
			}

			// Adjust for the different coordinate space in the two base cells.
			// This is done first because we need to do the pentagon rotations
			// based on the leading digit in the pentagon's coordinate system.
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))
				}
			}

			var indexLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out)))
			// This case should be unreachable because this function is building
			// *out, and should never generate an invalid digit, above.
			if func() int32 {
				if indexLeadingDigit == INVALID_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+820, uint32(440), uintptr(unsafe.Pointer(&__func__21)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_CELL_INVALID
			}
			if X_isBaseCellPolarPentagon(tls, baseCell) != 0 {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_POLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			} else {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_NONPOLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			}
			// For this to occur, revDir would need to be 1. Since revDir is
			// from the index base cell (which is a pentagon) towards the
			// origin, this should never be the case.
			if func() int32 {
				if pentagonRotations < 0 {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+820, uint32(454), uintptr(unsafe.Pointer(&__func__21)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_CELL_INVALID
			}

			{
				var i1 int32 = 0
				for ; i1 < pentagonRotations; i1++ {
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3RotatePent60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))
				}
			}
		} else {
			if pentagonRotations < 0 {
				return E_CELL_INVALID
			}
			{
				var i int32 = 0
				for ; i < pentagonRotations; i++ {
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))
				}
			}

			// Adjust for the different coordinate space in the two base cells.
			{
				var i1 int32 = 0
				for ; i1 < baseCellRotations; i1++ {
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))
				}
			}
		}
	} else if originOnPent != 0 && indexOnPent != 0 {
		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out))))

		if originLeadingDigit == INVALID_DIGIT || indexLeadingDigit == INVALID_DIGIT {
			return E_CELL_INVALID
		}
		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))
		if withinPentagonRotations < 0 {
			// This occurs when an invalid K axis digit is present
			return E_CELL_INVALID
		}

		{
			var i int32 = 0
			for ; i < withinPentagonRotations; i++ {
				*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))
			}
		}
	}

	if indexOnPent != 0 {
		// TODO: There are cases in cellToLocalIjk which are failed but not
		// accounted for here - instead just fail if the recovered index is
		// invalid.
		if X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out))) == K_AXES_DIGIT {
			return E_PENTAGON
		}
	}

	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET
	return E_SUCCESS
}

var __func__21 = *(*[15]int8)(unsafe.Pointer(ts + 1055)) /* localij.c:302:75 */

// *
// Produces ij coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function's output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param index Index to find the coordinates of
// @param mode Mode, must be 0
// @param out ij coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func XcellToLocalIj(tls *libc.TLS, origin TH3Index, h3 TH3Index, mode Tuint32_t, out uintptr) TH3Error { /* localij.c:528:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if mode != Tuint32_t(0) {
		return E_OPTION_INVALID
	}
	// var ijk TCoordIJK at bp, 12

	var failed TH3Error = XcellToLocalIjk(tls, origin, h3, bp)
	if failed != 0 {
		return failed
	}

	XijkToIj(tls, bp, out)

	return E_SUCCESS
}

// *
// Produces an index for ij coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function's output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param out ij coordinates to index.
// @param mode Mode, must be 0
// @param index Index will be placed here on success.
// @return 0 on success, or another value on failure.
func XlocalIjToCell(tls *libc.TLS, origin TH3Index, ij uintptr, mode Tuint32_t, out uintptr) TH3Error { /* localij.c:562:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if mode != Tuint32_t(0) {
		return E_OPTION_INVALID
	}
	// var ijk TCoordIJK at bp, 12

	var ijToIjkError TH3Error = XijToIjk(tls, ij, bp)
	if ijToIjkError != 0 {
		return ijToIjkError
	}

	return XlocalIjkToCell(tls, origin, bp, out)
}

// *
// Produces the grid distance between the two indexes.
//
// This function may fail to find the distance between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// @param origin Index to find the distance from.
// @param index Index to find the distance to.
// @return The distance, or a negative number if the library could not
// compute the distance.
func XgridDistance(tls *libc.TLS, origin TH3Index, h3 TH3Index, out uintptr) TH3Error { /* localij.c:588:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var originIjk TCoordIJK at bp, 12

	// var h3Ijk TCoordIJK at bp+12, 12

	var originError TH3Error = XcellToLocalIjk(tls, origin, origin, bp)
	if originError != 0 {
		return originError
	}
	var destError TH3Error = XcellToLocalIjk(tls, origin, h3, bp+12)
	if destError != 0 {
		return destError
	}

	*(*Tint64_t)(unsafe.Pointer(out)) = Tint64_t(XijkDistance(tls, bp, bp+12))
	return E_SUCCESS
}

// *
// Number of indexes in a line from the start index to the end index,
// to be used for allocating memory. Returns a negative number if the
// line cannot be computed.
//
// @param start Start index of the line
// @param end End index of the line
// @param size Size of the line
// @returns 0 on success, or another value on error
func XgridPathCellsSize(tls *libc.TLS, start TH3Index, end TH3Index, size uintptr) TH3Error { /* localij.c:613:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var distance Tint64_t at bp, 8

	var distanceError TH3Error = XgridDistance(tls, start, end, bp)
	if distanceError != 0 {
		return distanceError
	}
	*(*Tint64_t)(unsafe.Pointer(size)) = *(*Tint64_t)(unsafe.Pointer(bp)) + int64(1)
	return E_SUCCESS
}

// *
// Given cube coords as doubles, round to valid integer coordinates. Algorithm
// from https://www.redblobgames.com/grids/hexagons/#rounding
// @param i   Floating-point I coord
// @param j   Floating-point J coord
// @param k   Floating-point K coord
// @param ijk IJK coord struct, modified in place
func cubeRound(tls *libc.TLS, i float64, j float64, k float64, ijk uintptr) { /* localij.c:632:13: */
	var ri int32 = libc.Int32FromFloat64(libc.Xround(tls, i))
	var rj int32 = libc.Int32FromFloat64(libc.Xround(tls, j))
	var rk int32 = libc.Int32FromFloat64(libc.Xround(tls, k))

	var iDiff float64 = libc.Xfabs(tls, float64(ri)-i)
	var jDiff float64 = libc.Xfabs(tls, float64(rj)-j)
	var kDiff float64 = libc.Xfabs(tls, float64(rk)-k)

	// Round, maintaining valid cube coords
	if iDiff > jDiff && iDiff > kDiff {
		ri = -rj - rk
	} else if jDiff > kDiff {
		rj = -ri - rk
	} else {
		rk = -ri - rj
	}

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = ri
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = rj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = rk
}

// *
// Given two H3 indexes, return the line of indexes between them (inclusive).
//
// This function may fail to find the line between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// Notes:
//
//   - The specific output of this function should not be considered stable
//     across library versions. The only guarantees the library provides are
//     that the line length will be `gridDistance(start, end) + 1` and that
//     every index in the line will be a neighbor of the preceding index.
//   - Lines are drawn in grid space, and may not correspond exactly to either
//     Cartesian lines or great arcs.
//
// @param start Start index of the line
// @param end End index of the line
// @param out Output array, which must be of size gridPathCellsSize(start, end)
// @return 0 on success, or another value on failure.
func XgridPathCells(tls *libc.TLS, start TH3Index, end TH3Index, out uintptr) TH3Error { /* localij.c:676:9: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var distance Tint64_t at bp, 8

	var distanceError TH3Error = XgridDistance(tls, start, end, bp)
	// Early exit if we can't calculate the line
	if distanceError != 0 {
		return distanceError
	}

	// Get IJK coords for the start and end. We've already confirmed
	// that these can be calculated with the distance check above.
	*(*TCoordIJK)(unsafe.Pointer(bp + 8 /* startIjk */)) = TCoordIJK{}
	*(*TCoordIJK)(unsafe.Pointer(bp + 20 /* endIjk */)) = TCoordIJK{}

	// Convert H3 addresses to IJK coords
	var startError TH3Error = XcellToLocalIjk(tls, start, start, bp+8)
	if func() int32 {
		if startError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+820, uint32(691), uintptr(unsafe.Pointer(&__func__22)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Unreachable because this was called as part of gridDistance
		return startError
	}
	var endError TH3Error = XcellToLocalIjk(tls, start, end, bp+20)
	if func() int32 {
		if endError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+820, uint32(696), uintptr(unsafe.Pointer(&__func__22)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Unreachable because this was called as part of gridDistance
		return endError
	}

	// Convert IJK to cube coordinates suitable for linear interpolation
	XijkToCube(tls, bp+8)
	XijkToCube(tls, bp+20)

	var iStep float64
	if *(*Tint64_t)(unsafe.Pointer(bp)) != 0 {
		iStep = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fi-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fi) / float64(*(*Tint64_t)(unsafe.Pointer(bp)))
	} else {
		iStep = float64(0)
	}
	var jStep float64
	if *(*Tint64_t)(unsafe.Pointer(bp)) != 0 {
		jStep = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fj-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fj) / float64(*(*Tint64_t)(unsafe.Pointer(bp)))
	} else {
		jStep = float64(0)
	}
	var kStep float64
	if *(*Tint64_t)(unsafe.Pointer(bp)) != 0 {
		kStep = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fk-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fk) / float64(*(*Tint64_t)(unsafe.Pointer(bp)))
	} else {
		kStep = float64(0)
	}

	*(*TCoordIJK)(unsafe.Pointer(bp + 32 /* currentIjk */)) = TCoordIJK{Fi: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fi, Fj: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fj, Fk: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fk}
	{
		var n Tint64_t = int64(0)
		for ; n <= *(*Tint64_t)(unsafe.Pointer(bp)); n++ {
			cubeRound(tls, float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fi)+iStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fj)+jStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fk)+kStep*float64(n), bp+32)
			// Convert cube -> ijk -> h3 index
			XcubeToIjk(tls, bp+32)
			var currentError TH3Error = XlocalIjkToCell(tls, start, bp+32, out+uintptr(n)*8)
			if currentError != 0 {
				// The cells between `start` and `end` may fall in pentagon
				// distortion.
				return currentError
			}
		}
	}

	return E_SUCCESS
}

var __func__22 = *(*[14]int8)(unsafe.Pointer(ts + 1070)) /* localij.c:676:76 */

// *
// _ipow does integer exponentiation efficiently. Taken from StackOverflow.
//
// @param base the integer base (can be positive or negative)
// @param exp the integer exponent (should be nonnegative)
//
// @return the exponentiated value
func X_ipow(tls *libc.TLS, base Tint64_t, exp Tint64_t) Tint64_t { /* mathExtensions.c:30:9: */
	var result Tint64_t = int64(1)
	for exp != 0 {
		if exp&int64(1) != 0 {
			result = result * base
		}
		exp >>= 1
		base = base * base
	}

	return result
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Define macros used in polygon algos for GeoLoop

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file
// @brief Include file for poylgon algorithms. This includes the core
//        logic for algorithms acting over loops of coordinates,
//        allowing them to be reused for both GeoLoop and
//        LinkegGeoLoop structures. This file is intended to be
//        included inline in a file that defines the type-specific
//        macros required for iteration.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Declarations for math functions.
//    Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file polygon.h
// @brief Polygon algorithms

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TLatLng)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TLatLng)(unsafe.Pointer(coord)).Flng < float64(0) {
			return (*TLatLng)(unsafe.Pointer(coord)).Flng + 6.28318530717958647692528676655900576839433
		}
		return (*TLatLng)(unsafe.Pointer(coord)).Flng
	}()
	var a TLatLng
	var b TLatLng

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If the latitude matches exactly, we'll hit an edge case where
		// the ray passes through the vertex twice on successive segment
		// checks. To avoid this, adjust the latiude northward if needed.
		//
		// NOTE: This currently means that a point at the north pole cannot
		// be contained in any polygon. This is acceptable in current usage,
		// because the point we test in this function at present is always
		// a cell center or vertex, and no cell has a center or vertex on the
		// north pole. If we need to expand this algo to more generic uses we
		// might need to handle this edge case.
		if lat == a.Flat || lat == b.Flat {
			lat = lat + 2.22044604925031308084726333618164062e-16
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
//   - Does not support polygons with two adjacent points > 180 degrees of
//     longitude apart. These will be interpreted as crossing the antimeridian.
//   - Does not currently support polygons containing a pole.
//
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:151:6: */
	// Early exit if there are no vertices
	if (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts == 0 {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLng float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLng float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lng float64
	var coord TLatLng
	var next TLatLng

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		coord = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		next = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))

		lat = coord.Flat
		lng = coord.Flng
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lng < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lng
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lng > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lng
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lng > float64(0) && lng < minPosLng {
			minPosLng = lng
		}
		if lng < float64(0) && lng > maxNegLng {
			maxNegLng = lng
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lng-next.Flng) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLng
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLng
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedGeoLoop(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:205:13: */
	var sum float64 = float64(0)
	var a TLatLng
	var b TLatLng

	var loopIndex int32 = -1
	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flng-b.Flng) > 3.14159265358979323846 {
			return isClockwiseNormalizedGeoLoop(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseGeoLoop(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:233:6: */
	return isClockwiseNormalizedGeoLoop(tls, loop, uint8(Dfalse))
}

// *
// Create a bounding box from a GeoPolygon
// @param polygon Input GeoPolygon
// @param bboxes  Output bboxes, one for the outer loop and one for each hole
func XbboxesFromGeoPolygon(tls *libc.TLS, polygon uintptr, bboxes uintptr) { /* polygon.c:50:6: */
	XbboxFromGeoLoop(tls, polygon, bboxes)
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(polygon)).FnumHoles; i++ {
			XbboxFromGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(polygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32)
		}
	}
}

// *
// pointInsidePolygon takes a given GeoPolygon data structure and
// checks if it contains a given geo coordinate.
//
// @param geoPolygon The geoloop and holes defining the relevant area
// @param bboxes     The bboxes for the main geoloop and each of its holes
// @param coord      The coordinate to check
// @return           Whether the point is contained
func XpointInsidePolygon(tls *libc.TLS, geoPolygon uintptr, bboxes uintptr, coord uintptr) uint8 { /* polygon.c:66:6: */
	// Start with contains state of primary geoloop
	var contains uint8 = XpointInsideGeoLoop(tls, geoPolygon, bboxes, coord)

	// If the point is contained in the primary geoloop, but there are holes in
	// the geoloop iterate through all holes and return false if the point is
	// contained in any hole
	if contains != 0 && (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles > 0 {
		{
			var i int32 = 0
			for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
				if XpointInsideGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32,
					coord) != 0 {
					return uint8(Dfalse)
				}
			}
		}
	}

	return contains
}

// The following headers provide asm redirections.  These redirections must
//    appear before the first usage of these functions, e.g. in bits/stdio.h.

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// *
// Calculates the magnitude of a 2D cartesian vector.
// @param v The 2D cartesian vector.
// @return The magnitude of the vector.
func X_v2dMag(tls *libc.TLS, v uintptr) float64 { /* vec2d.c:31:8: */
	return libc.Xsqrt(tls, (*TVec2d)(unsafe.Pointer(v)).Fx*(*TVec2d)(unsafe.Pointer(v)).Fx+(*TVec2d)(unsafe.Pointer(v)).Fy*(*TVec2d)(unsafe.Pointer(v)).Fy)
}

// *
// Finds the intersection between two lines. Assumes that the lines intersect
// and that the intersection is not at an endpoint of either line.
// @param p0 The first endpoint of the first line.
// @param p1 The second endpoint of the first line.
// @param p2 The first endpoint of the second line.
// @param p3 The second endpoint of the second line.
// @param inter The intersection point.
func X_v2dIntersect(tls *libc.TLS, p0 uintptr, p1 uintptr, p2 uintptr, p3 uintptr, inter uintptr) { /* vec2d.c:42:6: */
	var s1 TVec2d
	var s2 TVec2d
	s1.Fx = (*TVec2d)(unsafe.Pointer(p1)).Fx - (*TVec2d)(unsafe.Pointer(p0)).Fx
	s1.Fy = (*TVec2d)(unsafe.Pointer(p1)).Fy - (*TVec2d)(unsafe.Pointer(p0)).Fy
	s2.Fx = (*TVec2d)(unsafe.Pointer(p3)).Fx - (*TVec2d)(unsafe.Pointer(p2)).Fx
	s2.Fy = (*TVec2d)(unsafe.Pointer(p3)).Fy - (*TVec2d)(unsafe.Pointer(p2)).Fy
	var t float64
	t = (s2.Fx*((*TVec2d)(unsafe.Pointer(p0)).Fy-(*TVec2d)(unsafe.Pointer(p2)).Fy) - s2.Fy*((*TVec2d)(unsafe.Pointer(p0)).Fx-(*TVec2d)(unsafe.Pointer(p2)).Fx)) / (-s2.Fx*s1.Fy + s1.Fx*s2.Fy)

	(*TVec2d)(unsafe.Pointer(inter)).Fx = (*TVec2d)(unsafe.Pointer(p0)).Fx + t*s1.Fx
	(*TVec2d)(unsafe.Pointer(inter)).Fy = (*TVec2d)(unsafe.Pointer(p0)).Fy + t*s1.Fy
}

// *
// Whether two 2D vectors are almost equal, within some threshold
// @param v1 First vector to compare
// @param v2 Second vector to compare
// @return Whether the vectors are almost equal
func X_v2dAlmostEquals(tls *libc.TLS, v1 uintptr, v2 uintptr) uint8 { /* vec2d.c:64:6: */
	return uint8(libc.Bool32(libc.Xfabs(tls, (*TVec2d)(unsafe.Pointer(v1)).Fx-(*TVec2d)(unsafe.Pointer(v2)).Fx) < 1.19209289550781250000000000000000000e-7 && libc.Xfabs(tls, (*TVec2d)(unsafe.Pointer(v1)).Fy-(*TVec2d)(unsafe.Pointer(v2)).Fy) < 1.19209289550781250000000000000000000e-7))
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// *
// Square of a number
//
// @param x The input number.
// @return The square of the input number.
func X_square(tls *libc.TLS, x float64) float64 { /* vec3d.c:30:8: */
	return x * x
}

// *
// Calculate the square of the distance between two 3D coordinates.
//
// @param v1 The first 3D coordinate.
// @param v2 The second 3D coordinate.
// @return The square of the distance between the given points.
func X_pointSquareDist(tls *libc.TLS, v1 uintptr, v2 uintptr) float64 { /* vec3d.c:39:8: */
	return X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fx-(*TVec3d)(unsafe.Pointer(v2)).Fx) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fy-(*TVec3d)(unsafe.Pointer(v2)).Fy) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fz-(*TVec3d)(unsafe.Pointer(v2)).Fz)
}

// *
// Calculate the 3D coordinate on unit sphere from the latitude and longitude.
//
// @param geo The latitude and longitude of the point.
// @param v The 3D coordinate of the point.
func X_geoToVec3d(tls *libc.TLS, geo uintptr, v uintptr) { /* vec3d.c:50:6: */
	var r float64 = libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(geo)).Flat)

	(*TVec3d)(unsafe.Pointer(v)).Fz = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(geo)).Flat)
	(*TVec3d)(unsafe.Pointer(v)).Fx = libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(geo)).Flng) * r
	(*TVec3d)(unsafe.Pointer(v)).Fy = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(geo)).Flng) * r
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// * @brief Table of direction-to-face mapping for each pentagon
//
// Note that faces are in directional order, starting at J_AXES_DIGIT.
// This table is generated by the generatePentagonDirectionFaces script.
var pentagonDirectionFaces = [12]TPentagonDirectionFaces{
	{FbaseCell: 4, Ffaces: [5]int32{4, 0, 2, 1, 3}}, {FbaseCell: 14, Ffaces: [5]int32{6, 11, 2, 7, 1}},
	{FbaseCell: 24, Ffaces: [5]int32{5, 10, 1, 6, 0}}, {FbaseCell: 38, Ffaces: [5]int32{7, 12, 3, 8, 2}},
	{FbaseCell: 49, Ffaces: [5]int32{9, 14, 0, 5, 4}}, {FbaseCell: 58, Ffaces: [5]int32{8, 13, 4, 9, 3}},
	{FbaseCell: 63, Ffaces: [5]int32{11, 6, 15, 10, 16}}, {FbaseCell: 72, Ffaces: [5]int32{12, 7, 16, 11, 17}},
	{FbaseCell: 83, Ffaces: [5]int32{10, 5, 19, 14, 15}}, {FbaseCell: 97, Ffaces: [5]int32{13, 8, 17, 12, 18}},
	{FbaseCell: 107, Ffaces: [5]int32{14, 9, 18, 13, 19}}, {FbaseCell: 117, Ffaces: [5]int32{15, 19, 17, 18, 16}},
} /* vertex.c:39:37 */

// *
// Get the number of CCW rotations of the cell's vertex numbers
// compared to the directional layout of its neighbors.
// @param out Number of CCW rotations for the cell
func vertexRotations(tls *libc.TLS, cell TH3Index, out uintptr) TH3Error { /* vertex.c:53:16: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// Get the face and other info for the origin
	// var fijk TFaceIJK at bp, 16

	var err TH3Error = X_h3ToFaceIjk(tls, cell, bp)
	if err != 0 {
		return err
	}
	var baseCell int32 = XgetBaseCellNumber(tls, cell)
	var cellLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, cell))

	// get the base cell face
	// var baseFijk TFaceIJK at bp+16, 16

	X_baseCellToFaceIjk(tls, baseCell, bp+16)

	var ccwRot60 int32 = X_baseCellToCCWrot60(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp /* &fijk */)).Fface)

	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// Find the appropriate direction-to-face mapping
		// var dirFaces TPentagonDirectionFaces at bp+32, 24

		// We never hit the end condition
		var p int32 = 0
		for ; p < DNUM_PENTAGONS; p++ {
			if pentagonDirectionFaces[p].FbaseCell == baseCell {
				*(*TPentagonDirectionFaces)(unsafe.Pointer(bp + 32 /* dirFaces */)) = pentagonDirectionFaces[p]
				break
			}
		}
		if p == DNUM_PENTAGONS {
			return E_FAILED
		}

		// additional CCW rotation for polar neighbors or IK neighbors
		if (*TFaceIJK)(unsafe.Pointer(bp)).Fface != (*TFaceIJK)(unsafe.Pointer(bp+16)).Fface && (X_isBaseCellPolarPentagon(tls, baseCell) != 0 || (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4))) {
			ccwRot60 = (ccwRot60 + 1) % 6
		}

		// Check whether the cell crosses a deleted pentagon subsequence
		if cellLeadingDigit == JK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4)) {
			// Crosses from JK to IK: Rotate CW
			ccwRot60 = (ccwRot60 + 5) % 6
		} else if cellLeadingDigit == IK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 1*4)) {
			// Crosses from IK to JK: Rotate CCW
			ccwRot60 = (ccwRot60 + 1) % 6
		}
	}
	*(*int32)(unsafe.Pointer(out)) = ccwRot60
	return E_SUCCESS
}

//   - @brief Hexagon direction to vertex number relationships (same face).
//     Note that we don't use direction 0 (center).
var directionToVertexNumHex = [7]int32{
	INVALID_DIGIT, 3, 1, 2, 5, 4, 0} /* vertex.c:112:18 */

//   - @brief Pentagon direction to vertex number relationships (same face).
//     Note that we don't use directions 0 (center) or 1 (deleted K axis).
var directionToVertexNumPent = [7]int32{
	INVALID_DIGIT, INVALID_DIGIT, 1, 2, 4, 3, 0} /* vertex.c:118:18 */

// *
// Get the first vertex number for a given direction. The neighbor in this
// direction is located between this vertex number and the next number in
// sequence.
// @returns The number for the first topological vertex, or INVALID_VERTEX_NUM
//
//	if the direction is not valid for this cell
func XvertexNumForDirection(tls *libc.TLS, origin TH3Index, direction TDirection) int32 { /* vertex.c:128:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var isPent int32 = XisPentagon(tls, origin)
	// Check for invalid directions
	if direction == CENTER_DIGIT || direction >= INVALID_DIGIT || isPent != 0 && direction == K_AXES_DIGIT {
		return -1
	}

	// Determine the vertex rotations for this cell
	// var rotations int32 at bp, 4

	var err TH3Error = vertexRotations(tls, origin, bp)
	if err != 0 {
		return -1
	}

	// Find the appropriate vertex, rotating CCW if necessary
	if isPent != 0 {
		return (directionToVertexNumPent[direction] + DNUM_PENT_VERTS - *(*int32)(unsafe.Pointer(bp))) % DNUM_PENT_VERTS
	} else {
		return (directionToVertexNumHex[direction] + DNUM_HEX_VERTS - *(*int32)(unsafe.Pointer(bp))) % DNUM_HEX_VERTS
	}
	return int32(0)
}

// * @brief Vertex number to hexagon direction relationships (same face).
var vertexNumToDirectionHex = [6]TDirection{
	IJ_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT,
	K_AXES_DIGIT, IK_AXES_DIGIT, I_AXES_DIGIT} /* vertex.c:156:24 */

// * @brief Vertex number to pentagon direction relationships (same face).
var vertexNumToDirectionPent = [5]TDirection{
	IJ_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, IK_AXES_DIGIT, I_AXES_DIGIT} /* vertex.c:162:24 */

// *
// Get the direction for a given vertex number. This returns the direction for
// the neighbor between the given vertex number and the next number in sequence.
// @returns The direction for this vertex, or INVALID_DIGIT if the vertex
// number is invalid.
func XdirectionForVertexNum(tls *libc.TLS, origin TH3Index, vertexNum int32) TDirection { /* vertex.c:171:11: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var isPent int32 = XisPentagon(tls, origin)
	// Check for invalid vertexes
	if vertexNum < 0 || vertexNum > func() int32 {
		if isPent != 0 {
			return DNUM_PENT_VERTS
		}
		return DNUM_HEX_VERTS
	}()-1 {
		return INVALID_DIGIT
	}

	// Determine the vertex rotations for this cell
	// var rotations int32 at bp, 4

	var err TH3Error = vertexRotations(tls, origin, bp)
	if err != 0 {
		return INVALID_DIGIT
	}

	// Find the appropriate direction, rotating CW if necessary
	if isPent != 0 {
		return vertexNumToDirectionPent[(vertexNum+*(*int32)(unsafe.Pointer(bp)))%DNUM_PENT_VERTS]
	}
	return vertexNumToDirectionHex[(vertexNum+*(*int32)(unsafe.Pointer(bp)))%DNUM_HEX_VERTS]
}

// * @brief Directions in CCW order
var sDIRECTIONS1 = [6]TDirection{
	J_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT,
	IK_AXES_DIGIT, I_AXES_DIGIT, IJ_AXES_DIGIT} /* vertex.c:193:24 */

//   - @brief Reverse direction from neighbor in each direction,
//     given as an index into DIRECTIONS to facilitate rotation
var revNeighborDirectionsHex = [7]int32{
	INVALID_DIGIT, 5, 3, 4, 1, 0, 2} /* vertex.c:200:18 */

// *
// Get a single vertex for a given cell, as an H3 index, or
// H3_NULL if the vertex is invalid
// @param cell    Cell to get the vertex for
// @param vertexNum Number (index) of the vertex to calculate
func XcellToVertex(tls *libc.TLS, cell TH3Index, vertexNum int32, out uintptr) TH3Error { /* vertex.c:209:9: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var cellIsPentagon int32 = XisPentagon(tls, cell)
	var cellNumVerts int32
	if cellIsPentagon != 0 {
		cellNumVerts = DNUM_PENT_VERTS
	} else {
		cellNumVerts = DNUM_HEX_VERTS
	}
	var res int32 = int32(cell & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	// Check for invalid vertexes
	if vertexNum < 0 || vertexNum > cellNumVerts-1 {
		return E_DOMAIN
	}

	// Default the owner and vertex number to the input cell
	var owner TH3Index = cell
	var ownerVertexNum int32 = vertexNum

	// Determine the owner, looking at the three cells that share the vertex.
	// By convention, the owner is the cell with the lowest numerical index.

	// If the cell is the center child of its parent, it will always have
	// the lowest index of any neighbor, so we can skip determining the owner
	if res == 0 || TDirection(cell>>((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != CENTER_DIGIT {
		// Get the left neighbor of the vertex, with its rotations
		var left TDirection = XdirectionForVertexNum(tls, cell, vertexNum)
		if left == INVALID_DIGIT {
			return E_FAILED
		}
		*(*int32)(unsafe.Pointer(bp /* lRotations */)) = 0
		// var leftNeighbor TH3Index at bp+8, 8

		var leftNeighborError TH3Error = Xh3NeighborRotations(tls, cell, left, bp, bp+8)
		if leftNeighborError != 0 {
			return leftNeighborError
		}
		// Set to owner if lowest index
		if *(*TH3Index)(unsafe.Pointer(bp + 8)) < owner {
			owner = *(*TH3Index)(unsafe.Pointer(bp + 8 /* leftNeighbor */))
		}

		// As above, skip the right neighbor if the left is known lowest
		if res == 0 || TDirection(*(*TH3Index)(unsafe.Pointer(bp + 8))>>((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != CENTER_DIGIT {
			// Get the right neighbor of the vertex, with its rotations
			// Note that vertex - 1 is the right side, as vertex numbers are CCW
			var right TDirection = XdirectionForVertexNum(tls,
				cell, (vertexNum-1+cellNumVerts)%cellNumVerts)
			// This case should be unreachable; invalid verts fail earlier
			if func() int32 {
				if right == INVALID_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+1084, uint32(245), uintptr(unsafe.Pointer(&__func__23)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_FAILED
			}
			*(*int32)(unsafe.Pointer(bp + 16 /* rRotations */)) = 0
			// var rightNeighbor TH3Index at bp+24, 8

			var rightNeighborError TH3Error = Xh3NeighborRotations(tls, cell, right, bp+16, bp+24)
			if rightNeighborError != 0 {
				return rightNeighborError
			}
			// Set to owner if lowest index
			if *(*TH3Index)(unsafe.Pointer(bp + 24)) < owner {
				owner = *(*TH3Index)(unsafe.Pointer(bp + 24 /* rightNeighbor */))
				var dir TDirection
				if XisPentagon(tls, owner) != 0 {
					dir = XdirectionForNeighbor(tls, owner, cell)
				} else {
					dir = sDIRECTIONS1[(revNeighborDirectionsHex[right]+*(*int32)(unsafe.Pointer(bp + 16)))%DNUM_HEX_VERTS]
				}
				ownerVertexNum = XvertexNumForDirection(tls, owner, dir)
			}
		}

		// Determine the vertex number for the left neighbor
		if owner == *(*TH3Index)(unsafe.Pointer(bp + 8)) {
			var ownerIsPentagon int32 = XisPentagon(tls, owner)
			var dir TDirection
			if ownerIsPentagon != 0 {
				dir = XdirectionForNeighbor(tls, owner, cell)
			} else {
				dir = sDIRECTIONS1[(revNeighborDirectionsHex[left]+*(*int32)(unsafe.Pointer(bp)))%DNUM_HEX_VERTS]
			}

			// For the left neighbor, we need the second vertex of the
			// edge, which may involve looping around the vertex nums
			ownerVertexNum = XvertexNumForDirection(tls, owner, dir) + 1
			if ownerVertexNum == DNUM_HEX_VERTS || ownerIsPentagon != 0 && ownerVertexNum == DNUM_PENT_VERTS {
				ownerVertexNum = 0
			}
		}
	}

	// Create the vertex index
	var vertex TH3Index = owner
	vertex = vertex&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_VERTEX_MODE))<<DH3_MODE_OFFSET
	vertex = vertex&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(ownerVertexNum)<<DH3_RESERVED_OFFSET
	*(*TH3Index)(unsafe.Pointer(out)) = vertex

	return E_SUCCESS
}

var __func__23 = *(*[13]int8)(unsafe.Pointer(ts + 1110)) /* vertex.c:209:76 */

// *
// Get all vertexes for the given cell
// @param cell      Cell to get the vertexes for
// @param vertexes  Array to hold vertex output. Must have length >= 6.
func XcellToVertexes(tls *libc.TLS, cell TH3Index, vertexes uintptr) TH3Error { /* vertex.c:297:9: */
	// Get all vertexes. If the cell is a pentagon, will fill the final slot
	// with H3_NULL.
	var isPent uint8 = uint8(XisPentagon(tls, cell))
	{
		var i int32 = 0
		for ; i < DNUM_HEX_VERTS; i++ {
			if i == 5 && isPent != 0 {
				*(*TH3Index)(unsafe.Pointer(vertexes + uintptr(i)*8)) = uint64(DH3_NULL)
			} else {
				var cellError TH3Error = XcellToVertex(tls, cell, i, vertexes+uintptr(i)*8)
				if cellError != 0 {
					return cellError
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Get the geocoordinates of an H3 vertex
// @param vertex H3 index describing a vertex
// @param coord  Output geo coordinate
func XvertexToLatLng(tls *libc.TLS, vertex TH3Index, coord uintptr) TH3Error { /* vertex.c:319:9: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// Get the vertex number and owner from the vertex
	var vertexNum int32 = int32(vertex & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET)
	var owner TH3Index = vertex
	owner = owner&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	owner = owner&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(uint64(0))<<DH3_RESERVED_OFFSET

	// Get the single vertex from the boundary
	// var gb TCellBoundary at bp+16, 168

	// var fijk TFaceIJK at bp, 16

	var fijkError TH3Error = X_h3ToFaceIjk(tls, owner, bp)
	if fijkError != 0 {
		return fijkError
	}
	var res int32 = int32(owner & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if XisPentagon(tls, owner) != 0 {
		X_faceIjkPentToCellBoundary(tls, bp, res, vertexNum, 1, bp+16)
	} else {
		X_faceIjkToCellBoundary(tls, bp, res, vertexNum, 1, bp+16)
	}

	// Copy from boundary to output coord
	*(*TLatLng)(unsafe.Pointer(coord)) = *(*TLatLng)(unsafe.Pointer(bp + 16 + 8))
	return E_SUCCESS
}

// *
// Whether the input is a valid H3 vertex
// @param  vertex H3 index possibly describing a vertex
// @return        Whether the input is valid
func XisValidVertex(tls *libc.TLS, vertex TH3Index) int32 { /* vertex.c:351:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if int32(vertex&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_VERTEX_MODE {
		return 0
	}

	var vertexNum int32 = int32(vertex & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET)
	var owner TH3Index = vertex
	owner = owner&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	owner = owner&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(uint64(0))<<DH3_RESERVED_OFFSET

	if !(XisValidCell(tls, owner) != 0) {
		return 0
	}

	// The easiest way to ensure that the owner + vertex number is valid,
	// and that the vertex is canonical, is to recreate and compare.
	// var canonical TH3Index at bp, 8

	if XcellToVertex(tls, owner, vertexNum, bp) != 0 {
		return 0
	}

	if vertex == *(*TH3Index)(unsafe.Pointer(bp)) {
		return 1
	}
	return 0
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// *
// Initialize a new VertexGraph
// @param graph       Graph to initialize
// @param  numBuckets Number of buckets to include in the graph
// @param  res        Resolution of the hexagons whose vertices we're storing
func XinitVertexGraph(tls *libc.TLS, graph uintptr, numBuckets int32, res int32) { /* vertexGraph.c:37:6: */
	if numBuckets > 0 {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = libc.Xcalloc(tls, uint64(numBuckets), uint64(unsafe.Sizeof(uintptr(0))))
		if (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets != uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+1123, ts+1146, uint32(40), uintptr(unsafe.Pointer(&__func__24)))
		}
	} else {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = uintptr(0)
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets = numBuckets
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize = 0
	(*TVertexGraph)(unsafe.Pointer(graph)).Fres = res
}

var __func__24 = *(*[16]int8)(unsafe.Pointer(ts + 1177)) /* vertexGraph.c:37:67 */

// *
// Destroy a VertexGraph's sub-objects, freeing their memory. The caller is
// responsible for freeing memory allocated to the VertexGraph struct itself.
// @param graph Graph to destroy
func XdestroyVertexGraph(tls *libc.TLS, graph uintptr) { /* vertexGraph.c:54:6: */
	var node uintptr
	for libc.AssignUintptr(&node, XfirstVertexNode(tls, graph)) != uintptr(0) {
		XremoveVertexNode(tls, graph, node)
	}
	libc.Xfree(tls, (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets)
}

// *
// Get an integer hash for a lat/lng point, at a precision determined
// by the current hexagon resolution.
// TODO: Light testing suggests this might not be sufficient at resolutions
// finer than 10. Design a better hash function if performance and collisions
// seem to be an issue here.
// @param  vertex     Lat/lng vertex to hash
// @param  res        Resolution of the hexagon the vertex belongs to
// @param  numBuckets Number of buckets in the graph
// @return            Integer hash
func X_hashVertex(tls *libc.TLS, vertex uintptr, res int32, numBuckets int32) Tuint32_t { /* vertexGraph.c:73:10: */
	// Simple hash: Take the sum of the lat and lng with a precision level
	// determined by the resolution, converted to int, modulo bucket count.
	return libc.Uint32FromFloat64(libc.Xfmod(tls, libc.Xfabs(tls, ((*TLatLng)(unsafe.Pointer(vertex)).Flat+(*TLatLng)(unsafe.Pointer(vertex)).Flng)*libc.Xpow(tls, float64(10), float64(15-res))),
		float64(numBuckets)))
}

func X_initVertexNode(tls *libc.TLS, node uintptr, fromVtx uintptr, toVtx uintptr) { /* vertexGraph.c:80:6: */
	(*TVertexNode)(unsafe.Pointer(node)).Ffrom = *(*TLatLng)(unsafe.Pointer(fromVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fto = *(*TLatLng)(unsafe.Pointer(toVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fnext = uintptr(0)
}

// *
// Add a edge to the graph
// @param graph   Graph to add node to
// @param fromVtx Start vertex
// @param toVtx   End vertex
// @return        Pointer to the new node
func XaddVertexNode(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:94:12: */
	// Make the new node
	var node uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TVertexNode{})))
	if node != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1193, ts+1146, uint32(98), uintptr(unsafe.Pointer(&__func__25)))
	}
	X_initVertexNode(tls, node, fromVtx, toVtx)
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if currentNode == uintptr(0) {
		// Set bucket to the new node
		*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = node
	} else {
		// Find the end of the list
		for __ccgo := true; __ccgo; __ccgo = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			// Check the the edge we're adding doesn't already exist
			if XgeoAlmostEqual(tls, currentNode, fromVtx) != 0 && XgeoAlmostEqual(tls, currentNode+16, toVtx) != 0 {
				// already exists, bail
				libc.Xfree(tls, node)
				return currentNode
			}
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
				currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
			}
		}
		// Add the new node to the end of the list
		(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = node
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize++
	return node
}

var __func__25 = *(*[14]int8)(unsafe.Pointer(ts + 1206)) /* vertexGraph.c:95:48 */

// *
// Remove a node from the graph. The input node will be freed, and should
// not be used after removal.
// @param graph Graph to mutate
// @param node  Node to remove
// @return      0 on success, 1 on failure (node not found)
func XremoveVertexNode(tls *libc.TLS, graph uintptr, node uintptr) int32 { /* vertexGraph.c:135:5: */
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, node, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	var found int32 = 0
	if currentNode != uintptr(0) {
		if currentNode == node {
			*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = (*TVertexNode)(unsafe.Pointer(node)).Fnext
			found = 1
		}
		// Look through the list
		for !(found != 0) && (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext == node {
				// splice the node out
				(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = (*TVertexNode)(unsafe.Pointer(node)).Fnext
				found = 1
			}
			currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
		}
	}
	if found != 0 {
		libc.Xfree(tls, node)
		(*TVertexGraph)(unsafe.Pointer(graph)).Fsize--
		return 0
	}
	// Failed to find the node
	return 1
}

// *
// Find the Vertex node for a given edge, if it exists
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @param  toVtx   End vertex, or NULL if we don't care
// @return         Pointer to the vertex node, if found
func XfindNodeForEdge(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:171:12: */
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var node uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if node != uintptr(0) {
		// Look through the list and see if we find the edge
		for __ccgo := true; __ccgo; __ccgo = node != uintptr(0) {
			if XgeoAlmostEqual(tls, node, fromVtx) != 0 && (toVtx == uintptr(0) || XgeoAlmostEqual(tls, node+16, toVtx) != 0) {
				return node
			}
			node = (*TVertexNode)(unsafe.Pointer(node)).Fnext
		}
	}
	// Iteration lookup fail
	return uintptr(0)
}

// *
// Find a Vertex node starting at the given vertex
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @return         Pointer to the vertex node, if found
func XfindNodeForVertex(tls *libc.TLS, graph uintptr, fromVtx uintptr) uintptr { /* vertexGraph.c:197:12: */
	return XfindNodeForEdge(tls, graph, fromVtx, uintptr(0))
}

// *
// Get the next vertex node in the graph.
// @param  graph Graph to iterate
// @return       Vertex node, or NULL if at the end
func XfirstVertexNode(tls *libc.TLS, graph uintptr) uintptr { /* vertexGraph.c:206:12: */
	var node uintptr = uintptr(0)
	var currentIndex int32 = 0
	for node == uintptr(0) {
		if currentIndex < (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets {
			// find the first node in the next bucket
			node = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(currentIndex)*8))
		} else {
			// end of iteration
			return uintptr(0)
		}
		currentIndex++
	}
	return node
}

var ts1 = "0\x00../src/h3lib/lib/algos.c\x00h3NeighborRotations\x00../src/h3lib/lib/coordijk.c\x00_upAp7Checked\x00_upAp7rChecked\x00../src/h3lib/lib/directedEdge.c\x00directedEdgeToBoundary\x00adjacentFaceDir[tmpFijk.face][fijk.face] == KI\x00../src/h3lib/lib/faceijk.c\x00_faceIjkPentToCellBoundary\x00adjacentFaceDir[centerIJK.face][face2] == KI\x00_faceIjkToCellBoundary\x00%lx\x00../src/h3lib/lib/h3Index.c\x00isValidCell\x00compactCells\x00latLngToCell\x00_h3ToFaceIjk\x00getIcosahedronFaces\x00validateChildPos\x00cellToChildPos\x00../src/h3lib/lib/latLng.c\x00cellAreaRads2\x00polygon->next == NULL\x00../src/h3lib/lib/linkedGeo.c\x00next != NULL\x00addNewLinkedPolygon\x00loop != NULL\x00addNewLinkedLoop\x00polygon->first == NULL\x00addLinkedLoop\x00coord != NULL\x00loop->first == NULL\x00addLinkedCoord\x00candidates != NULL\x00candidateBBoxes != NULL\x00findPolygonForHole\x00innerLoops != NULL\x00bboxes != NULL\x00normalizeMultiPolygon\x00../src/h3lib/lib/localij.c\x00revDir != INVALID_DIGIT\x00baseCell != originBaseCell\x00!(originOnPent && indexOnPent)\x00baseCell == originBaseCell\x00cellToLocalIjk\x00baseCell != INVALID_BASE_CELL\x00!_isBaseCellPentagon(baseCell)\x00baseCellRotations >= 0\x00localIjkToCell\x00gridPathCells\x00../src/h3lib/lib/vertex.c\x00cellToVertex\x00graph->buckets != NULL\x00../src/h3lib/lib/vertexGraph.c\x00initVertexGraph\x00node != NULL\x00addVertexNode\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
