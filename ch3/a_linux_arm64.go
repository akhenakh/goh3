// Code generated by 'ccgo -pkgname ch3 -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T -Isrc/h3lib/include -I../src/h3lib/include ../src/h3lib/lib/algos.c ../src/h3lib/lib/baseCells.c ../src/h3lib/lib/bbox.c ../src/h3lib/lib/coordijk.c ../src/h3lib/lib/faceijk.c ../src/h3lib/lib/geoCoord.c ../src/h3lib/lib/h3Index.c ../src/h3lib/lib/h3UniEdge.c ../src/h3lib/lib/linkedGeo.c ../src/h3lib/lib/localij.c ../src/h3lib/lib/mathExtensions.c ../src/h3lib/lib/polygon.c ../src/h3lib/lib/vec2d.c ../src/h3lib/lib/vec3d.c ../src/h3lib/lib/vertex.c ../src/h3lib/lib/vertexGraph.c', DO NOT EDIT.

package ch3

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DALGOS_H                             = 0                                               // algos.h:21:1:
	DALLOC_H                             = 0                                               // alloc.h:25:1:
	DBASECELLS_H                         = 0                                               // baseCells.h:21:1:
	DBBOX_H                              = 0                                               // bbox.h:21:1:
	DBIG_ENDIAN                          = 4321                                            // endian.h:28:1:
	DBUFSIZ                              = 8192                                            // stdio.h:99:1:
	DBYTE_ORDER                          = 1234                                            // endian.h:30:1:
	DCOMPACT_ALLOC_FAILED                = -3                                              // h3Index.h:180:1:
	DCOMPACT_DUPLICATE                   = -2                                              // h3Index.h:179:1:
	DCOMPACT_LOOP_EXCEEDED               = -1                                              // h3Index.h:178:1:
	DCOMPACT_SUCCESS                     = 0                                               // h3Index.h:177:1:
	DCONSTANTS_H                         = 0                                               // constants.h:21:1:
	DCOORDIJK_H                          = 0                                               // coordijk.h:31:1:
	DDBL_DECIMAL_DIG                     = 17                                              // float.h:220:1:
	DDBL_DIG                             = 15                                              // float.h:54:1:
	DDBL_HAS_SUBNORM                     = 1                                               // float.h:228:1:
	DDBL_MANT_DIG                        = 53                                              // float.h:40:1:
	DDBL_MAX_10_EXP                      = 308                                             // float.h:94:1:
	DDBL_MAX_EXP                         = 1024                                            // float.h:82:1:
	DDBL_MIN_10_EXP                      = -307                                            // float.h:74:1:
	DDBL_MIN_EXP                         = -1021                                           // float.h:62:1:
	DDECIMAL_DIG                         = 36                                              // float.h:209:1:
	DEARTH_RADIUS_KM                     = 6371.007180918475                               // constants.h:59:1:
	DEOF                                 = -1                                              // stdio.h:104:1:
	DEPSILON                             = 0.0000000000000001                              // constants.h:42:1:
	DEPSILON_DEG                         = .000000001                                      // geoCoord.h:31:1:
	DEPSILON_RAD                         = 0                                               // geoCoord.h:33:1:
	DEXIT_FAILURE                        = 1                                               // stdlib.h:92:1:
	DEXIT_SUCCESS                        = 0                                               // stdlib.h:93:1:
	DFACEIJK_H                           = 0                                               // faceijk.h:25:1:
	DFD_SETSIZE                          = 1024                                            // select.h:73:1:
	DFILENAME_MAX                        = 4096                                            // stdio_lim.h:27:1:
	DFLT_DECIMAL_DIG                     = 9                                               // float.h:219:1:
	DFLT_DIG                             = 6                                               // float.h:53:1:
	DFLT_EPSILON                         = 0                                               // float.h:113:1:
	DFLT_EVAL_METHOD                     = 0                                               // float.h:197:1:
	DFLT_HAS_SUBNORM                     = 1                                               // float.h:227:1:
	DFLT_MANT_DIG                        = 24                                              // float.h:39:1:
	DFLT_MAX                             = 0                                               // float.h:104:1:
	DFLT_MAX_10_EXP                      = 38                                              // float.h:93:1:
	DFLT_MAX_EXP                         = 128                                             // float.h:81:1:
	DFLT_MIN                             = 0                                               // float.h:121:1:
	DFLT_MIN_10_EXP                      = -37                                             // float.h:73:1:
	DFLT_MIN_EXP                         = -125                                            // float.h:61:1:
	DFLT_RADIX                           = 2                                               // float.h:33:1:
	DFLT_ROUNDS                          = 1                                               // float.h:128:1:
	DFLT_TRUE_MIN                        = 0                                               // float.h:235:1:
	DFOPEN_MAX                           = 16                                              // stdio_lim.h:37:1:
	DFP_FAST_FMA                         = 1                                               // fp-fast.h:27:1:
	DFP_FAST_FMAF                        = 1                                               // fp-fast.h:28:1:
	DFP_ILOGB0                           = -2147483647                                     // math.h:209:1:
	DFP_ILOGBNAN                         = 2147483647                                      // math.h:214:1:
	DFP_INFINITE                         = 1                                               // math.h:940:1:
	DFP_NAN                              = 0                                               // math.h:937:1:
	DFP_NORMAL                           = 4                                               // math.h:949:1:
	DFP_SUBNORMAL                        = 3                                               // math.h:946:1:
	DFP_ZERO                             = 2                                               // math.h:943:1:
	DGEOCOORD_H                          = 0                                               // geoCoord.h:21:1:
	DH3API_H                             = 0                                               // h3api.h:24:1:
	DH3INDEX_H                           = 0                                               // h3Index.h:21:1:
	DH3_BC_OFFSET                        = 45                                              // h3Index.h:38:1:
	DH3_HEXAGON_MODE                     = 1                                               // constants.h:81:1:
	DH3_INIT                             = 35184372088831                                  // h3Index.h:90:1:
	DH3_MAX_OFFSET                       = 63                                              // h3Index.h:32:1:
	DH3_MODE_OFFSET                      = 59                                              // h3Index.h:35:1:
	DH3_NULL                             = 0                                               // h3Index.h:171:1:
	DH3_NUM_BITS                         = 64                                              // h3Index.h:29:1:
	DH3_PER_DIGIT_OFFSET                 = 3                                               // h3Index.h:47:1:
	DH3_RESERVED_OFFSET                  = 56                                              // h3Index.h:44:1:
	DH3_RES_MASK                         = 67553994410557440                               // h3Index.h:68:1:
	DH3_RES_MASK_NEGATIVE                = 18379190079298994175                            // h3Index.h:71:1:
	DH3_RES_OFFSET                       = 52                                              // h3Index.h:41:1:
	DH3_UNIEDGE_MODE                     = 2                                               // constants.h:82:1:
	DH3_VERSION_MAJOR                    = 3                                               // h3api.h:59:1:
	DH3_VERSION_MINOR                    = 7                                               // h3api.h:60:1:
	DH3_VERSION_PATCH                    = 2                                               // h3api.h:61:1:
	DHEX_HASH_OVERFLOW                   = -1                                              // algos.c:48:1:
	DHEX_RANGE_K_SUBSEQUENCE             = 2                                               // algos.c:46:1:
	DHEX_RANGE_PENTAGON                  = 1                                               // algos.c:45:1:
	DHEX_RANGE_SUCCESS                   = 0                                               // algos.c:44:1:
	DIJ                                  = 1                                               // faceijk.h:54:1:
	DINT16_MAX                           = 32767                                           // stdint.h:122:1:
	DINT16_MIN                           = -32768                                          // stdint.h:117:1:
	DINT32_MAX                           = 2147483647                                      // stdint.h:123:1:
	DINT32_MIN                           = -2147483648                                     // stdint.h:118:1:
	DINT64_MAX                           = 9223372036854775807                             // stdint.h:124:1:
	DINT64_MIN                           = -9223372036854775808                            // stdint.h:119:1:
	DINT8_MAX                            = 127                                             // stdint.h:121:1:
	DINT8_MIN                            = -128                                            // stdint.h:116:1:
	DINTMAX_MAX                          = 9223372036854775807                             // stdint.h:199:1:
	DINTMAX_MIN                          = -9223372036854775808                            // stdint.h:197:1:
	DINTPTR_MAX                          = 9223372036854775807                             // stdint.h:187:1:
	DINTPTR_MIN                          = -9223372036854775808                            // stdint.h:186:1:
	DINT_FAST16_MAX                      = 9223372036854775807                             // stdint.h:164:1:
	DINT_FAST16_MIN                      = -9223372036854775808                            // stdint.h:154:1:
	DINT_FAST32_MAX                      = 9223372036854775807                             // stdint.h:165:1:
	DINT_FAST32_MIN                      = -9223372036854775808                            // stdint.h:155:1:
	DINT_FAST64_MAX                      = 9223372036854775807                             // stdint.h:170:1:
	DINT_FAST64_MIN                      = -9223372036854775808                            // stdint.h:160:1:
	DINT_FAST8_MAX                       = 127                                             // stdint.h:162:1:
	DINT_FAST8_MIN                       = -128                                            // stdint.h:152:1:
	DINT_LEAST16_MAX                     = 32767                                           // stdint.h:140:1:
	DINT_LEAST16_MIN                     = -32768                                          // stdint.h:135:1:
	DINT_LEAST32_MAX                     = 2147483647                                      // stdint.h:141:1:
	DINT_LEAST32_MIN                     = -2147483648                                     // stdint.h:136:1:
	DINT_LEAST64_MAX                     = 9223372036854775807                             // stdint.h:142:1:
	DINT_LEAST64_MIN                     = -9223372036854775808                            // stdint.h:137:1:
	DINT_LEAST8_MAX                      = 127                                             // stdint.h:139:1:
	DINT_LEAST8_MIN                      = -128                                            // stdint.h:134:1:
	DINVALID_BASE_CELL                   = 127                                             // baseCells.h:38:1:
	DINVALID_FACE                        = -1                                              // faceijk.h:61:1:
	DINVALID_ROTATIONS                   = -1                                              // baseCells.h:49:1:
	DJK                                  = 3                                               // faceijk.h:58:1:
	DKI                                  = 2                                               // faceijk.h:56:1:
	DLDBL_DECIMAL_DIG                    = 36                                              // float.h:221:1:
	DLDBL_DIG                            = 33                                              // float.h:55:1:
	DLDBL_EPSILON                        = 0                                               // float.h:115:1:
	DLDBL_HAS_SUBNORM                    = 1                                               // float.h:229:1:
	DLDBL_MANT_DIG                       = 113                                             // float.h:41:1:
	DLDBL_MAX                            = 0                                               // float.h:106:1:
	DLDBL_MAX_10_EXP                     = 4932                                            // float.h:95:1:
	DLDBL_MAX_EXP                        = 16384                                           // float.h:83:1:
	DLDBL_MIN                            = 0                                               // float.h:123:1:
	DLDBL_MIN_10_EXP                     = -4931                                           // float.h:75:1:
	DLDBL_MIN_EXP                        = -16381                                          // float.h:63:1:
	DLDBL_TRUE_MIN                       = 0                                               // float.h:237:1:
	DLINKED_GEO_H                        = 0                                               // linkedGeo.h:21:1:
	DLITTLE_ENDIAN                       = 1234                                            // endian.h:27:1:
	DL_ctermid                           = 9                                               // stdio_lim.h:30:1:
	DL_tmpnam                            = 20                                              // stdio_lim.h:25:1:
	DMATH_ERREXCEPT                      = 2                                               // math.h:1036:1:
	DMATH_ERRNO                          = 1                                               // math.h:1035:1:
	DMAX_CELL_BNDRY_VERTS                = 10                                              // h3api.h:67:1:
	DMAX_FACE_COORD                      = 2                                               // baseCells.h:46:1:
	DMAX_H3_RES                          = 15                                              // constants.h:67:1:
	DMAX_ONE_RING_SIZE                   = 7                                               // algos.c:47:1:
	DM_180_PI                            = 57.29577951308232087679815481410517033240547    // constants.h:39:1:
	DM_1_PI                              = 0.31830988618379067154                          // math.h:1154:1:
	DM_2PI                               = 6.28318530717958647692528676655900576839433     // constants.h:34:1:
	DM_2_PI                              = 0.63661977236758134308                          // math.h:1155:1:
	DM_2_SQRTPI                          = 1.12837916709551257390                          // math.h:1156:1:
	DM_AP7_ROT_RADS                      = 0.333473172251832115336090755351601070065900389 // constants.h:50:1:
	DM_COS_AP7_ROT                       = 0.9449111825230680680167902                     // constants.h:56:1:
	DM_E                                 = 2.7182818284590452354                           // math.h:1146:1:
	DM_LN10                              = 2.30258509299404568402                          // math.h:1150:1:
	DM_LN2                               = 0.69314718055994530942                          // math.h:1149:1:
	DM_LOG10E                            = 0.43429448190325182765                          // math.h:1148:1:
	DM_LOG2E                             = 1.4426950408889634074                           // math.h:1147:1:
	DM_PI                                = 3.14159265358979323846                          // math.h:1151:1:
	DM_PI_180                            = 0.0174532925199432957692369076848861271111      // constants.h:37:1:
	DM_PI_2                              = 1.57079632679489661923                          // math.h:1152:1:
	DM_PI_4                              = 0.78539816339744830962                          // math.h:1153:1:
	DM_SIN60                             = 0                                               // constants.h:46:1:
	DM_SIN_AP7_ROT                       = 0.3273268353539885718950318                     // constants.h:53:1:
	DM_SQRT1_2                           = 0.70710678118654752440                          // math.h:1158:1:
	DM_SQRT2                             = 1.41421356237309504880                          // math.h:1157:1:
	DM_SQRT3_2                           = 0.8660254037844386467637231707529361834714      // constants.h:44:1:
	DNORMALIZATION_ERR_MULTIPLE_POLYGONS = 1                                               // linkedGeo.h:31:1:
	DNORMALIZATION_ERR_UNASSIGNED_HOLES  = 2                                               // linkedGeo.h:32:1:
	DNORMALIZATION_SUCCESS               = 0                                               // linkedGeo.h:30:1:
	DNUM_BASE_CELLS                      = 122                                             // constants.h:72:1:
	DNUM_HEX_VERTS                       = 6                                               // constants.h:74:1:
	DNUM_ICOSA_FACES                     = 20                                              // constants.h:70:1:
	DNUM_PENTAGONS                       = 12                                              // constants.h:78:1:
	DNUM_PENT_VERTS                      = 5                                               // constants.h:76:1:
	DPDP_ENDIAN                          = 3412                                            // endian.h:29:1:
	DPOLYFILL_BUFFER                     = 12                                              // algos.c:49:1:
	DPOLYGON_H                           = 0                                               // polygon.h:21:1:
	DPTRDIFF_MAX                         = 9223372036854775807                             // stdint.h:210:1:
	DPTRDIFF_MIN                         = -9223372036854775808                            // stdint.h:209:1:
	DP_tmpdir                            = "/tmp"                                          // stdio.h:120:1:
	DRAND_MAX                            = 2147483647                                      // stdlib.h:87:1:
	DRES0_U_GNOMONIC                     = 0.38196601125010500003                          // constants.h:64:1:
	DSEEK_CUR                            = 1                                               // stdio.h:110:1:
	DSEEK_END                            = 2                                               // stdio.h:111:1:
	DSEEK_SET                            = 0                                               // stdio.h:109:1:
	DSIG_ATOMIC_MAX                      = 2147483647                                      // stdint.h:223:1:
	DSIG_ATOMIC_MIN                      = -2147483648                                     // stdint.h:222:1:
	DSIZE_MAX                            = 18446744073709551615                            // stdint.h:227:1:
	DTMP_MAX                             = 238328                                          // stdio_lim.h:26:1:
	DUINT16_MAX                          = 65535                                           // stdint.h:128:1:
	DUINT32_MAX                          = 4294967295                                      // stdint.h:129:1:
	DUINT64_MAX                          = 18446744073709551615                            // stdint.h:130:1:
	DUINT8_MAX                           = 255                                             // stdint.h:127:1:
	DUINTMAX_MAX                         = 18446744073709551615                            // stdint.h:202:1:
	DUINTPTR_MAX                         = 18446744073709551615                            // stdint.h:188:1:
	DUINT_FAST16_MAX                     = 18446744073709551615                            // stdint.h:175:1:
	DUINT_FAST32_MAX                     = 18446744073709551615                            // stdint.h:176:1:
	DUINT_FAST64_MAX                     = 18446744073709551615                            // stdint.h:181:1:
	DUINT_FAST8_MAX                      = 255                                             // stdint.h:173:1:
	DUINT_LEAST16_MAX                    = 65535                                           // stdint.h:146:1:
	DUINT_LEAST32_MAX                    = 4294967295                                      // stdint.h:147:1:
	DUINT_LEAST64_MAX                    = 18446744073709551615                            // stdint.h:148:1:
	DUINT_LEAST8_MAX                     = 255                                             // stdint.h:145:1:
	DVEC2D_H                             = 0                                               // vec2d.h:21:1:
	DVERTEX_GRAPH_H                      = 0                                               // vertexGraph.h:21:1:
	DWCHAR_MAX                           = 4294967295                                      // stdint.h:240:1:
	DWCHAR_MIN                           = 0                                               // stdint.h:239:1:
	DWCONTINUED                          = 8                                               // waitflags.h:32:1:
	DWEXITED                             = 4                                               // waitflags.h:31:1:
	DWINT_MAX                            = 4294967295                                      // stdint.h:245:1:
	DWINT_MIN                            = 0                                               // stdint.h:244:1:
	DWNOHANG                             = 1                                               // waitflags.h:25:1:
	DWNOWAIT                             = 0x01000000                                      // waitflags.h:33:1:
	DWSTOPPED                            = 2                                               // waitflags.h:30:1:
	DWUNTRACED                           = 2                                               // waitflags.h:26:1:
	D_ALLOCA_H                           = 1                                               // alloca.h:19:1:
	D_ASSERT_H                           = 1                                               // assert.h:34:1:
	D_ATFILE_SOURCE                      = 1                                               // features.h:351:1:
	D_BITS_ATOMIC_WIDE_COUNTER_H         = 0                                               // atomic_wide_counter.h:20:1:
	D_BITS_BYTESWAP_H                    = 1                                               // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H                  = 1                                               // endianness.h:2:1:
	D_BITS_ENDIAN_H                      = 1                                               // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H               = 0                                               // floatn-common.h:21:1:
	D_BITS_FLOATN_H                      = 0                                               // floatn.h:20:1:
	D_BITS_LIBM_SIMD_DECL_STUBS_H        = 1                                               // libm-simd-decl-stubs.h:34:1:
	D_BITS_PTHREADTYPES_ARCH_H           = 1                                               // pthreadtypes-arch.h:20:1:
	D_BITS_PTHREADTYPES_COMMON_H         = 1                                               // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H                 = 1                                               // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H                = 1                                               // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H                   = 1                                               // stdio_lim.h:19:1:
	D_BITS_TIME64_H                      = 1                                               // time64.h:24:1:
	D_BITS_TYPESIZES_H                   = 1                                               // typesizes.h:24:1:
	D_BITS_TYPES_H                       = 1                                               // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H              = 1                                               // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H            = 1                                               // __locale_t.h:20:1:
	D_BITS_UINTN_IDENTITY_H              = 1                                               // uintn-identity.h:24:1:
	D_BITS_WCHAR_H                       = 1                                               // wchar.h:20:1:
	D_BSD_SIZE_T_                        = 0                                               // stddef.h:193:1:
	D_BSD_SIZE_T_DEFINED_                = 0                                               // stddef.h:196:1:
	D_DEFAULT_SOURCE                     = 1                                               // features.h:236:1:
	D_ENDIAN_H                           = 1                                               // endian.h:19:1:
	D_FEATURES_H                         = 1                                               // features.h:19:1:
	D_FILE_OFFSET_BITS                   = 64                                              // <builtin>:25:1:
	D_FLOAT_H___                         = 0                                               // float.h:29:1:
	D_GCC_SIZE_T                         = 0                                               // stddef.h:200:1:
	D_GCC_WCHAR_T                        = 0                                               // stddef.h:280:1:
	D_GCC_WRAP_STDINT_H                  = 0                                               // stdint.h:13:1:
	D_IOFBF                              = 0                                               // stdio.h:93:1:
	D_IOLBF                              = 1                                               // stdio.h:94:1:
	D_IONBF                              = 2                                               // stdio.h:95:1:
	D_IO_EOF_SEEN                        = 0x0010                                          // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                        = 0x0020                                          // struct_FILE.h:114:1:
	D_IO_USER_LOCK                       = 0x8000                                          // struct_FILE.h:117:1:
	D_LP64                               = 1                                               // <predefined>:301:1:
	D_MATH_H                             = 1                                               // math.h:24:1:
	D_POSIX_C_SOURCE                     = 200809                                          // features.h:290:1:
	D_POSIX_SOURCE                       = 1                                               // features.h:288:1:
	D_RWLOCK_INTERNAL_H                  = 0                                               // struct_rwlock.h:21:1:
	D_SIZET_                             = 0                                               // stddef.h:201:1:
	D_SIZE_T                             = 0                                               // stddef.h:187:1:
	D_SIZE_T_                            = 0                                               // stddef.h:192:1:
	D_SIZE_T_DECLARED                    = 0                                               // stddef.h:197:1:
	D_SIZE_T_DEFINED                     = 0                                               // stddef.h:195:1:
	D_SIZE_T_DEFINED_                    = 0                                               // stddef.h:194:1:
	D_STDBOOL_H                          = 0                                               // stdbool.h:29:1:
	D_STDC_PREDEF_H                      = 1                                               // <predefined>:177:1:
	D_STDINT_H                           = 1                                               // stdint.h:23:1:
	D_STDIO_H                            = 1                                               // stdio.h:24:1:
	D_STDLIB_H                           = 1                                               // stdlib.h:36:1:
	D_STRINGS_H                          = 1                                               // strings.h:19:1:
	D_STRING_H                           = 1                                               // string.h:23:1:
	D_STRUCT_TIMESPEC                    = 1                                               // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                        = 1                                               // cdefs.h:20:1:
	D_SYS_SELECT_H                       = 1                                               // select.h:22:1:
	D_SYS_SIZE_T_H                       = 0                                               // stddef.h:188:1:
	D_SYS_TYPES_H                        = 1                                               // types.h:23:1:
	D_THREAD_MUTEX_INTERNAL_H            = 1                                               // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H              = 1                                               // thread-shared-types.h:20:1:
	D_T_SIZE                             = 0                                               // stddef.h:190:1:
	D_T_SIZE_                            = 0                                               // stddef.h:189:1:
	D_T_WCHAR                            = 0                                               // stddef.h:271:1:
	D_T_WCHAR_                           = 0                                               // stddef.h:270:1:
	D_VA_LIST_DEFINED                    = 0                                               // stdio.h:53:1:
	D_WCHAR_T                            = 0                                               // stddef.h:269:1:
	D_WCHAR_T_                           = 0                                               // stddef.h:273:1:
	D_WCHAR_T_DECLARED                   = 0                                               // stddef.h:281:1:
	D_WCHAR_T_DEFINED                    = 0                                               // stddef.h:276:1:
	D_WCHAR_T_DEFINED_                   = 0                                               // stddef.h:275:1:
	D_WCHAR_T_H                          = 0                                               // stddef.h:277:1:
	Dfalse                               = 0                                               // stdbool.h:39:1:
	Dlinux                               = 1                                               // <predefined>:252:1:
	Dmath_errhandling                    = 3                                               // math.h:1048:1:
	Dtrue                                = 1                                               // stdbool.h:38:1:
	Dunix                                = 1                                               // <predefined>:217:1:
	DMATHEXTENSIONS_H                    = 0                                               // mathExtensions.h:21:1:
	DM_SQRT7                             = 2.6457513110645905905016157536392604257102      // faceijk.c:36:1:
	DVEC3D_H                             = 0                                               // vec3d.h:21:1:
	DPRIX16                              = "X"                                             // inttypes.h:135:1:
	DPRIX32                              = "X"                                             // inttypes.h:136:1:
	DPRIX8                               = "X"                                             // inttypes.h:134:1:
	DPRIXFAST8                           = "X"                                             // inttypes.h:144:1:
	DPRIXLEAST16                         = "X"                                             // inttypes.h:140:1:
	DPRIXLEAST32                         = "X"                                             // inttypes.h:141:1:
	DPRIXLEAST8                          = "X"                                             // inttypes.h:139:1:
	DPRId16                              = "d"                                             // inttypes.h:55:1:
	DPRId32                              = "d"                                             // inttypes.h:56:1:
	DPRId8                               = "d"                                             // inttypes.h:54:1:
	DPRIdFAST8                           = "d"                                             // inttypes.h:64:1:
	DPRIdLEAST16                         = "d"                                             // inttypes.h:60:1:
	DPRIdLEAST32                         = "d"                                             // inttypes.h:61:1:
	DPRIdLEAST8                          = "d"                                             // inttypes.h:59:1:
	DPRIi16                              = "i"                                             // inttypes.h:71:1:
	DPRIi32                              = "i"                                             // inttypes.h:72:1:
	DPRIi8                               = "i"                                             // inttypes.h:70:1:
	DPRIiFAST8                           = "i"                                             // inttypes.h:80:1:
	DPRIiLEAST16                         = "i"                                             // inttypes.h:76:1:
	DPRIiLEAST32                         = "i"                                             // inttypes.h:77:1:
	DPRIiLEAST8                          = "i"                                             // inttypes.h:75:1:
	DPRIo16                              = "o"                                             // inttypes.h:87:1:
	DPRIo32                              = "o"                                             // inttypes.h:88:1:
	DPRIo8                               = "o"                                             // inttypes.h:86:1:
	DPRIoFAST8                           = "o"                                             // inttypes.h:96:1:
	DPRIoLEAST16                         = "o"                                             // inttypes.h:92:1:
	DPRIoLEAST32                         = "o"                                             // inttypes.h:93:1:
	DPRIoLEAST8                          = "o"                                             // inttypes.h:91:1:
	DPRIu16                              = "u"                                             // inttypes.h:103:1:
	DPRIu32                              = "u"                                             // inttypes.h:104:1:
	DPRIu8                               = "u"                                             // inttypes.h:102:1:
	DPRIuFAST8                           = "u"                                             // inttypes.h:112:1:
	DPRIuLEAST16                         = "u"                                             // inttypes.h:108:1:
	DPRIuLEAST32                         = "u"                                             // inttypes.h:109:1:
	DPRIuLEAST8                          = "u"                                             // inttypes.h:107:1:
	DPRIx16                              = "x"                                             // inttypes.h:119:1:
	DPRIx32                              = "x"                                             // inttypes.h:120:1:
	DPRIx8                               = "x"                                             // inttypes.h:118:1:
	DPRIxFAST8                           = "x"                                             // inttypes.h:128:1:
	DPRIxLEAST16                         = "x"                                             // inttypes.h:124:1:
	DPRIxLEAST32                         = "x"                                             // inttypes.h:125:1:
	DPRIxLEAST8                          = "x"                                             // inttypes.h:123:1:
	DSCNd16                              = "hd"                                            // inttypes.h:172:1:
	DSCNd32                              = "d"                                             // inttypes.h:173:1:
	DSCNd8                               = "hhd"                                           // inttypes.h:171:1:
	DSCNdFAST8                           = "hhd"                                           // inttypes.h:181:1:
	DSCNdLEAST16                         = "hd"                                            // inttypes.h:177:1:
	DSCNdLEAST32                         = "d"                                             // inttypes.h:178:1:
	DSCNdLEAST8                          = "hhd"                                           // inttypes.h:176:1:
	DSCNi16                              = "hi"                                            // inttypes.h:188:1:
	DSCNi32                              = "i"                                             // inttypes.h:189:1:
	DSCNi8                               = "hhi"                                           // inttypes.h:187:1:
	DSCNiFAST8                           = "hhi"                                           // inttypes.h:197:1:
	DSCNiLEAST16                         = "hi"                                            // inttypes.h:193:1:
	DSCNiLEAST32                         = "i"                                             // inttypes.h:194:1:
	DSCNiLEAST8                          = "hhi"                                           // inttypes.h:192:1:
	DSCNo16                              = "ho"                                            // inttypes.h:220:1:
	DSCNo32                              = "o"                                             // inttypes.h:221:1:
	DSCNo8                               = "hho"                                           // inttypes.h:219:1:
	DSCNoFAST8                           = "hho"                                           // inttypes.h:229:1:
	DSCNoLEAST16                         = "ho"                                            // inttypes.h:225:1:
	DSCNoLEAST32                         = "o"                                             // inttypes.h:226:1:
	DSCNoLEAST8                          = "hho"                                           // inttypes.h:224:1:
	DSCNu16                              = "hu"                                            // inttypes.h:204:1:
	DSCNu32                              = "u"                                             // inttypes.h:205:1:
	DSCNu8                               = "hhu"                                           // inttypes.h:203:1:
	DSCNuFAST8                           = "hhu"                                           // inttypes.h:213:1:
	DSCNuLEAST16                         = "hu"                                            // inttypes.h:209:1:
	DSCNuLEAST32                         = "u"                                             // inttypes.h:210:1:
	DSCNuLEAST8                          = "hhu"                                           // inttypes.h:208:1:
	DSCNx16                              = "hx"                                            // inttypes.h:236:1:
	DSCNx32                              = "x"                                             // inttypes.h:237:1:
	DSCNx8                               = "hhx"                                           // inttypes.h:235:1:
	DSCNxFAST8                           = "hhx"                                           // inttypes.h:245:1:
	DSCNxLEAST16                         = "hx"                                            // inttypes.h:241:1:
	DSCNxLEAST32                         = "x"                                             // inttypes.h:242:1:
	DSCNxLEAST8                          = "hhx"                                           // inttypes.h:240:1:
	D_INTTYPES_H                         = 1                                               // inttypes.h:23:1:
	DH3VERTEX_H                          = 0                                               // vertex.h:21:1:
	DINVALID_VERTEX_NUM                  = -1                                              // vertex.h:36:1:
	DMAX_BASE_CELL_FACES                 = 5                                               // vertex.h:39:1:
	DDIRECTION_INDEX_OFFSET              = 2                                               // vertex.c:27:1:
)

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
const ( /* coordijk.h:63:1: */
	//* H3 digit in center
	CENTER_DIGIT = 0
	//* H3 digit in k-axes direction
	K_AXES_DIGIT = 1
	//* H3 digit in j-axes direction
	J_AXES_DIGIT = 2
	//* H3 digit in j == k direction
	JK_AXES_DIGIT = 3 // 3
	//* H3 digit in i-axes direction
	I_AXES_DIGIT = 4
	//* H3 digit in i == k direction
	IK_AXES_DIGIT = 5 // 5
	//* H3 digit in i == j direction
	IJ_AXES_DIGIT = 6 // 6
	//* H3 digit in the invalid direction
	INVALID_DIGIT = 7
	// * Valid digits will be less than this value. Same value as INVALID_DIGIT.
	NUM_DIGITS = 7
)

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

//* Digit representing overage type
const ( /* faceijk.h:64:1: */
	//* No overage (on original face)
	NO_OVERAGE = 0
	//* On face edge (only occurs on substrate grids)
	FACE_EDGE = 1
	//* Overage on new face interior
	NEW_FACE = 2
)

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:934:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

type Tptrdiff_t = int64 /* <builtin>:3:26 */

type Tsize_t = uint64 /* <builtin>:9:23 */

type Twchar_t = uint32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// Copyright 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.c
// @brief   Hexagon grid algorithms

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.h
// @brief   Hexagon grid algorithms

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Signal that all the definitions are present.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//    __STDC_WANT_IEC_60559_EXT__
// 			ISO C2X interfaces defined only in Annex F.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// Features part to handle 64-bit time_t support.
//    Copyright (C) 2021-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We need to know the word size in order to check the time size.
// Determine the wordsize from the preprocessor defines.
//
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bit size of the time_t type at glibc build time, general case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Size in bits of the 'time_t' type of the default ABI.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    supported anymore.

// Some user header file might have defined this before.

// Compilers that lack __has_attribute may object to
//        #if defined __has_attribute && __has_attribute (...)
//    even though they do not need to evaluate the right-hand side of the &&.
//    Similarly for __has_builtin, etc.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this only works with
//    gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.

// Compile time conditions to choose between the regular, _chk and _chk_warn
//    variants.  These conditions should get evaluated to constant and optimized
//    away.

// Length is known to be safe at compile time if the __L * __S <= __OBJSZ
//    condition can be folded to a constant and if it is true, or unknown (-1)

// Conversely, we know at compile time that the length is unsafe if the
//    __L * __S <= __OBJSZ condition can be folded to a constant and if it is
//    false.

// Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
//    declared.

// Fortify function f, where object size argument passed to f is the number of
//    elements and not total size.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC and clang have various useful declarations that can be made with
//    the '__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// Tell the compiler which argument to an allocation function
//    indicates the alignment of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonnull function attribute marks pointer parameters that
//    must not be NULL.  This has the name __nonnull in glibc,
//    and __attribute_nonnull__ in files shared with Gnulib to avoid
//    collision with a different __nonnull in DragonFlyBSD 5.9.

// The returns_nonnull function attribute marks the return type of the function
//    as always being non-null.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above, and in clang.
//    It works also in C++ mode (outside of arrays), but only when spelled
//    as '__restrict', not 'restrict'.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 and clang support this.
//    This syntax is not usable in C++ mode.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Gnulib avoids including these, as they don't work on non-glibc or
//    older glibc platforms.
// Determine the wordsize from the preprocessor defines.
//
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-128 version.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// Designates a 1-based positional argument ref-index of pointer type
//    that can be used to access size-index elements of the pointed-to
//    array according to access mode, or at least one element when
//    size-index is not provided:
//      access (access-mode, <ref-index> [, <size-index>])
// For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
//    use the access attribute to get object sizes from function definition
//    arguments, so we can't use them on functions we fortify.  Drop the object
//    size hints for such functions.

// Designates dealloc as a function to call to deallocate objects
//    allocated by the declared function.

// Specify that a function such as setjmp or vfork may return
//    twice.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// Determine the wordsize from the preprocessor defines.
//
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.
//
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bit size of the time_t type at glibc build time, general case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Size in bits of the 'time_t' type of the default ABI.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint64  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int64   /* types.h:44:25 */
type T__uint64_t = uint64 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = T__int8_t     /* types.h:52:18 */
type T__uint_least8_t = T__uint8_t   /* types.h:53:19 */
type T__int_least16_t = T__int16_t   /* types.h:54:19 */
type T__uint_least16_t = T__uint16_t /* types.h:55:20 */
type T__int_least32_t = T__int32_t   /* types.h:56:19 */
type T__uint_least32_t = T__uint32_t /* types.h:57:20 */
type T__int_least64_t = T__int64_t   /* types.h:58:19 */
type T__uint_least64_t = T__uint64_t /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int64    /* types.h:63:18 */
type T__u_quad_t = uint64 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int64   /* types.h:72:18 */
type T__uintmax_t = uint64 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  For the generic Linux ABI.
//    Copyright (C) 2011-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library.  If not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// And for getitimer, setitimer and rusage

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint64                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint64                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint64                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint32                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int64                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int64                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int64                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint64                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint64                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int64                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int64                /* types.h:162:31 */ // Signed count of microseconds.
type T__suseconds64_t = int64              /* types.h:163:33 */

type T__daddr_t = int32 /* types.h:165:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:166:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:169:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:172:12 */

// Type to represent block size.
type T__blksize_t = int32 /* types.h:175:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int64   /* types.h:180:28 */
type T__blkcnt64_t = int64 /* types.h:181:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint64   /* types.h:184:30 */
type T__fsblkcnt64_t = uint64 /* types.h:185:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint64   /* types.h:188:30 */
type T__fsfilcnt64_t = uint64 /* types.h:189:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int64 /* types.h:192:28 */

type T__ssize_t = int64 /* types.h:194:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int64 /* types.h:197:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint64 /* types.h:199:33 */

// These few don't really vary by system, they always correspond
//    to one of the other defined types.
type T__loff_t = T__off64_t /* types.h:203:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr   /* types.h:204:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int64 /* types.h:207:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:210:23 */

// C99: An integer type that can be accessed as an atomic entity,
//    even in the presence of asynchronous interrupts.
//    It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:215:13 */

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// wchar_t type related definitions.
//    Copyright (C) 2000-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.
//
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = T__int8_t   /* stdint-intn.h:24:18 */
type Tint16_t = T__int16_t /* stdint-intn.h:25:19 */
type Tint32_t = T__int32_t /* stdint-intn.h:26:19 */
type Tint64_t = T__int64_t /* stdint-intn.h:27:19 */

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = T__uint8_t   /* stdint-uintn.h:24:19 */
type Tuint16_t = T__uint16_t /* stdint-uintn.h:25:20 */
type Tuint32_t = T__uint32_t /* stdint-uintn.h:26:20 */
type Tuint64_t = T__uint64_t /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = T__int_least8_t   /* stdint.h:43:24 */
type Tint_least16_t = T__int_least16_t /* stdint.h:44:25 */
type Tint_least32_t = T__int_least32_t /* stdint.h:45:25 */
type Tint_least64_t = T__int_least64_t /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = T__uint_least8_t   /* stdint.h:49:25 */
type Tuint_least16_t = T__uint_least16_t /* stdint.h:50:26 */
type Tuint_least32_t = T__uint_least32_t /* stdint.h:51:26 */
type Tuint_least64_t = T__uint_least64_t /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int64 /* stdint.h:60:19 */
type Tint_fast32_t = int64 /* stdint.h:61:19 */
type Tint_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint64 /* stdint.h:73:27 */
type Tuint_fast32_t = uint64 /* stdint.h:74:27 */
type Tuint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int64   /* stdint.h:87:19 */
type Tuintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = T__intmax_t   /* stdint.h:101:21 */
type Tuintmax_t = T__uintmax_t /* stdint.h:102:22 */

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1989-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = T__builtin_va_list /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   T__off_t
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//    C++ mangled names for functions taking fpos_t arguments.
//    That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   T__off64_t
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//    C++ mangled names for functions taking fpos_t and/or fpos64_t
//    arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     T__off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]uint8
	F__ccgo_pad2     [4]byte
	F_lock           uintptr
	F_offset         T__off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          Tsize_t
	F_mode           int32
	F_unused2        [20]uint8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type Tva_list = T__gnuc_va_list /* stdio.h:52:24 */

type Toff_t = T__off64_t /* stdio.h:65:19 */

type Tssize_t = T__ssize_t /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t /* stdio.h:86:20 */

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on ldbl-128 platforms.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:63:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:81:5 */

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = T__u_char     /* types.h:33:18 */
type Tu_short = T__u_short   /* types.h:34:19 */
type Tu_int = T__u_int       /* types.h:35:17 */
type Tu_long = T__u_long     /* types.h:36:18 */
type Tquad_t = T__quad_t     /* types.h:37:18 */
type Tu_quad_t = T__u_quad_t /* types.h:38:20 */
type Tfsid_t = T__fsid_t     /* types.h:39:18 */
type Tloff_t = T__loff_t     /* types.h:42:18 */

type Tino_t = T__ino64_t /* types.h:49:19 */

type Tdev_t = T__dev_t /* types.h:59:17 */

type Tgid_t = T__gid_t /* types.h:64:17 */

type Tmode_t = T__mode_t /* types.h:69:18 */

type Tnlink_t = T__nlink_t /* types.h:74:19 */

type Tuid_t = T__uid_t /* types.h:79:17 */

type Tpid_t = T__pid_t /* types.h:97:17 */

type Tid_t = T__id_t /* types.h:103:16 */

type Tdaddr_t = T__daddr_t /* types.h:114:19 */
type Tcaddr_t = T__caddr_t /* types.h:115:19 */

type Tkey_t = T__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = T__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = T__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = T__time_t /* time_t.h:10:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = T__timer_t /* timer_t.h:7:19 */

// Copyright (C) 1989-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type Tulong = uint64  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These were defined by ISO C without the first `_'.
type Tu_int8_t = T__uint8_t   /* types.h:158:19 */
type Tu_int16_t = T__uint16_t /* types.h:159:20 */
type Tu_int32_t = T__uint32_t /* types.h:160:20 */
type Tu_int64_t = T__uint64_t /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We don't use `memset' because this would require a prototype and
//    the array isn't too big.

// Get sigset_t.

type T__sigset_t = struct{ F__val [16]uint64 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  T__time_t
	Ftv_usec T__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  T__time_t
	Ftv_nsec T__syscall_slong_t
} /* struct_timespec.h:11:1 */

type Tsuseconds_t = T__suseconds_t /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int64 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ F__fds_bits [16]T__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = T__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = T__blksize_t /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = T__blkcnt64_t     /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = T__fsblkcnt64_t /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = T__fsfilcnt64_t /* types.h:213:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Endian macros for string.h functions
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Monotonically increasing wide counters (at least 62 bits).
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Counter that is monotonically increasing (by less than 2**31 per
//    increment), with a single writer, and an arbitrary number of
//    readers.
type T__atomic_wide_counter = struct{ F__value64 uint64 } /* atomic_wide_counter.h:33:3 */

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:51:9 */

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:55:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:57:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:60:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// Default mutex implementation struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Generic struct for both POSIX and C11 mutexes.  New ports are expected
//    to use the default layout, however architecture can redefine it to
//    add arch-specific extension (such as lock-elision).  The struct have
//    a size of 32 bytes on LP32 and 40 bytes on LP64 architectures.

type S__pthread_mutex_s = struct {
	F__lock   int32
	F__count  uint32
	F__owner  int32
	F__nusers uint32
	F__kind   int32
	F__spins  int32
	F__list   T__pthread_list_t
} /* struct_mutex.h:27:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// AArch64 internal rwlock struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__pad1          uint64
	F__pad2          uint64
	F__flags         uint32
	F__ccgo_pad1     [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__wseq         T__atomic_wide_counter
	F__g1_start     T__atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:94:1 */

type T__tss_t = uint32  /* thread-shared-types.h:105:22 */
type T__thrd_t = uint64 /* thread-shared-types.h:106:27 */

type T__once_flag = struct{ F__data int32 } /* thread-shared-types.h:111:3 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type Tpthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [8]uint8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [8]uint8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [64]uint8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct {
	F__data      S__pthread_mutex_s
	F__ccgo_pad1 [8]byte
} /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct{ F__data S__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [8]uint8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [32]uint8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [8]uint8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:424:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:491:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:816:13 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Macros to control TS 18661-3 glibc features on ldbl-128 platforms.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// H3 is compiled as C, not C++ code. `extern "C"` is needed for C++ code
// to be able to use the library.

//* @brief the H3Index fits within a 64-bit unsigned integer
type TH3Index = Tuint64_t /* h3api.h:55:18 */

// library version numbers generated from VERSION file
// clang-format off
// clang-format on

// * Maximum number of cell boundary vertices; worst case is pentagon:
//  5 original verts + 5 edge crossings

//* @struct GeoCoord
//     @brief latitude/longitude in radians
type TGeoCoord = struct {
	Flat float64
	Flon float64
} /* h3api.h:75:3 */

//* @struct GeoBoundary
//     @brief cell boundary in latitude/longitude
type TGeoBoundary = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       [10]TGeoCoord
} /* h3api.h:83:3 */

// * @struct Geofence
//  @brief similar to GeoBoundary, but requires more alloc work
type TGeofence = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       uintptr
} /* h3api.h:91:3 */

// * @struct GeoPolygon
//  @brief Simplified core of GeoJSON Polygon coordinates definition
type TGeoPolygon = struct {
	Fgeofence    TGeofence
	FnumHoles    int32
	F__ccgo_pad1 [4]byte
	Fholes       uintptr
} /* h3api.h:100:3 */

// * @struct GeoMultiPolygon
//  @brief Simplified core of GeoJSON MultiPolygon coordinates definition
type TGeoMultiPolygon = struct {
	FnumPolygons int32
	F__ccgo_pad1 [4]byte
	Fpolygons    uintptr
} /* h3api.h:108:3 */

// * @struct LinkedGeoCoord
//  @brief A coordinate node in a linked geo structure, part of a linked list
type SLinkedGeoCoord = struct {
	Fvertex TGeoCoord
	Fnext   uintptr
} /* h3api.h:113:9 */

// * @struct LinkedGeoCoord
//  @brief A coordinate node in a linked geo structure, part of a linked list
type TLinkedGeoCoord = SLinkedGeoCoord /* h3api.h:113:31 */

// * @struct LinkedGeoLoop
//  @brief A loop node in a linked geo structure, part of a linked list
type SLinkedGeoLoop = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:122:9 */

// * @struct LinkedGeoLoop
//  @brief A loop node in a linked geo structure, part of a linked list
type TLinkedGeoLoop = SLinkedGeoLoop /* h3api.h:122:30 */

// * @struct LinkedGeoPolygon
//  @brief A polygon node in a linked geo structure, part of a linked list.
type SLinkedGeoPolygon = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:132:9 */

// * @struct LinkedGeoPolygon
//  @brief A polygon node in a linked geo structure, part of a linked list.
type TLinkedGeoPolygon = SLinkedGeoPolygon /* h3api.h:132:33 */

// * @struct CoordIJ
// @brief IJ hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJ = struct {
	Fi int32
	Fj int32
} /* h3api.h:147:3 */

// * @struct BBox
//  @brief  Geographic bounding box with coordinates defined in radians
type TBBox = struct {
	Fnorth float64
	Fsouth float64
	Feast  float64
	Fwest  float64
} /* bbox.h:35:3 */

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lon
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// * @struct Vec2d
//  @brief 2D floating-point vector
type TVec2d = struct {
	Fx float64
	Fy float64
} /* vec2d.h:31:3 */

// * @struct CoordIJK
// @brief IJK hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJK = struct {
	Fi int32
	Fj int32
	Fk int32
} /* coordijk.h:46:3 */

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
type TDirection = uint32 /* coordijk.h:83:3 */

// Copyright 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// * @struct VertexNode
//  @brief A single node in a vertex graph, part of a linked list
type SVertexNode = struct {
	Ffrom TGeoCoord
	Fto   TGeoCoord
	Fnext uintptr
} /* vertexGraph.h:31:9 */

// Copyright 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// * @struct VertexNode
//  @brief A single node in a vertex graph, part of a linked list
type TVertexNode = SVertexNode /* vertexGraph.h:31:27 */

// * @struct VertexGraph
//  @brief A data structure to store a graph of vertices
type TVertexGraph = struct {
	Fbuckets     uintptr
	FnumBuckets  int32
	Fsize        int32
	Fres         int32
	F__ccgo_pad1 [4]byte
} /* vertexGraph.h:46:3 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Radix of exponent representation, b.

// Number of base-FLT_RADIX digits in the significand, p.

// Number of decimal digits, q, such that any floating-point number with q
//    decimal digits can be rounded into a floating-point number with p radix b
//    digits and back again without change to the q decimal digits,
//
// 	p * log10(b)			if b is a power of 10
// 	floor((p - 1) * log10(b))	otherwise

// Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin

// Minimum negative integer such that 10 raised to that power is in the
//    range of normalized floating-point numbers,
//
// 	ceil(log10(b) * (emin - 1))

// Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.

// Maximum integer such that 10 raised to that power is in the range of
//    representable finite floating-point numbers,
//
// 	floor(log10((1 - b**-p) * b**emax))

// Maximum representable finite floating-point number,
//
// 	(1 - b**-p) * b**emax

// The difference between 1 and the least value greater than 1 that is
//    representable in the given floating point type, b**1-p.

// Minimum normalized positive floating-point number, b**(emin - 1).

// Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.
// ??? This is supposed to change with calls to fesetround in <fenv.h>.

// The floating-point expression evaluation method.  The precise
//    definitions of these values are generalised to include support for
//    the interchange and extended types defined in ISO/IEC TS 18661-3.
//    Prior to this (for C99/C11) the definitions were:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants just to the range and
// 	    precision of the type
// 	 1  evaluate operations and constants of type float and double
// 	    to the range and precision of the double type, evaluate
// 	    long double operations and constants to the range and
// 	    precision of the long double type
// 	 2  evaluate all operations and constants to the range and
// 	    precision of the long double type
//
//    The TS 18661-3 definitions are:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of float, to the range and
// 	    precision of float; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 1  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of double, to the range and
// 	    precision of double; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 2  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of long double, to the range and
// 	    precision of long double; evaluate all other operations and
// 	    constants to the range and precision of the semantic type.
// 	 N  where _FloatN  is a supported interchange floating type
// 	    evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of the _FloatN type, to the
// 	    range and precision of the _FloatN type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
// 	 N + 1, where _FloatNx is a supported extended floating type
// 	    evaluate operations and constants, whose semantic type has at
// 	    most the range and precision of the _FloatNx type, to the range
// 	    and precision of the _FloatNx type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
//
//    The compiler predefines two macros:
//
//       __FLT_EVAL_METHOD__
//       Which, depending on the value given for
//       -fpermitted-flt-eval-methods, may be limited to only those values
//       for FLT_EVAL_METHOD defined in C99/C11.
//
//      __FLT_EVAL_METHOD_TS_18661_3__
//       Which always permits the values for FLT_EVAL_METHOD defined in
//       ISO/IEC TS 18661-3.
//
//      Here we want to use __FLT_EVAL_METHOD__, unless
//      __STDC_WANT_IEC_60559_TYPES_EXT__ is defined, in which case the user
//      is specifically asking for the ISO/IEC TS 18661-3 types, so we use
//      __FLT_EVAL_METHOD_TS_18661_3__.
//
//    ??? This ought to change with the setting of the fp control word;
//    the value provided by the compiler assumes the widest setting.

// Number of decimal digits, n, such that any floating-point number in the
//    widest supported floating type with pmax radix b digits can be rounded
//    to a floating-point number with n decimal digits and back again without
//    change to the value,
//
// 	pmax * log10(b)			if b is a power of 10
// 	ceil(1 + pmax * log10(b))	otherwise

// Versions of DECIMAL_DIG for each floating-point type.

// Whether types support subnormal numbers.

// Minimum positive values, including subnormals.

// Declarations for math functions.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions required for __MATHCALL_VEC unfolding.
//    Plaform-specific analogue of this header should redefine them with specific
//    SIMD declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on ldbl-128 platforms.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// __GLIBC_FLT_EVAL_METHOD is the value of FLT_EVAL_METHOD used to
//    determine the evaluation method typedefs such as float_t and
//    double_t.  It must be a value from C11 or TS 18661-3:2015, and not
//    -1.

// In the default version of this header, follow __FLT_EVAL_METHOD__.
//    -1 is mapped to 2 (considering evaluation as long double to be a
//    conservatively safe assumption), and if __FLT_EVAL_METHOD__ is not
//    defined then assume there is no excess precision and use the value
//    0.

// Define the following typedefs.
//
//     float_t	floating-point type at least as wide as `float' used
// 		to evaluate `float' expressions
//     double_t	floating-point type at least as wide as `double' used
// 		to evaluate `double' expressions
type Tfloat_t = float32  /* math.h:163:15 */
type Tdouble_t = float64 /* math.h:164:16 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:27:1 */

type T__locale_t = uintptr /* __locale_t.h:41:32 */

type Tlocale_t = T__locale_t /* locale_t.h:24:20 */

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file baseCells.h
// @brief   Base cell related lookup tables and access functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lon
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lon.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lon
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// * @struct FaceIJK
// @brief Face number and ijk coordinates on that face-centered coordinate
// system
type TFaceIJK = struct {
	Fface  int32
	Fcoord TCoordIJK
} /* faceijk.h:38:3 */

// * @struct FaceOrientIJK
// @brief Information to transform into an adjacent face IJK system
type TFaceOrientIJK = struct {
	Fface      int32
	Ftranslate TCoordIJK
	FccwRot60  int32
} /* faceijk.h:48:3 */

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

//* Digit representing overage type
type TOverage = uint32 /* faceijk.h:71:3 */

// * @struct BaseCellData
// @brief information on a single base cell
type TBaseCellData = struct {
	FhomeFijk     TFaceIJK
	FisPentagon   int32
	FcwOffsetPent [2]int32
} /* baseCells.h:36:3 */

// Copyright 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Return codes from hexRange and related functions.

// *
// Directions used for traversing a hexagonal ring counterclockwise around
// {1, 0, 0}
//
// <pre>
//      _
//    _/ \\_
//   / \\5/ \ *   \\0/ \\4/
//   / \\_/ \ *   \\1/ \\3/
//     \\2/
// </pre>
var sDIRECTIONS = [6]TDirection{J_AXES_DIGIT, JK_AXES_DIGIT,
	K_AXES_DIGIT, IK_AXES_DIGIT,
	I_AXES_DIGIT, IJ_AXES_DIGIT} /* algos.c:65:24 */

// *
// Direction used for traversing to the next outward hexagonal ring.
var sNEXT_RING_DIRECTION TDirection = I_AXES_DIGIT /* algos.c:72:24 */

// *
// New digit when traversing along class II grids.
//
// Current digit -> direction -> new digit.
var sNEW_DIGIT_II = [7][7]TDirection{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, I_AXES_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, IK_AXES_DIGIT,
		J_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IK_AXES_DIGIT},
	{JK_AXES_DIGIT, IJ_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, K_AXES_DIGIT},
	{IK_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT,
		IJ_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT, J_AXES_DIGIT, K_AXES_DIGIT,
		I_AXES_DIGIT, JK_AXES_DIGIT}} /* algos.c:79:24 */

// *
// New traversal direction when traversing along class II grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_II = [7][7]TDirection{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, J_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		I_AXES_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:100:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_DIGIT_III = [7][7]TDirection{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT,
		IJ_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, K_AXES_DIGIT},
	{JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT,
		J_AXES_DIGIT, JK_AXES_DIGIT},
	{IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT,
		I_AXES_DIGIT, IK_AXES_DIGIT}} /* algos.c:121:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_III = [7][7]TDirection{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, JK_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, I_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:142:24 */

// *
// Maximum number of cells that result from the kRing algorithm with the given
// k. Formula source and proof: https://oeis.org/A003215
//
// @param  k   k value, k >= 0.
func XmaxKringSize(tls *libc.TLS, k int32) int32 { /* algos.c:164:5: */
	return 3*k*(k+1) + 1
}

// *
// Produce cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin   origin cell
// @param  k        k >= 0
// @param  out      zero-filled array which must be of size maxKringSize(k)
func XkRing(tls *libc.TLS, origin TH3Index, k int32, out uintptr) { /* algos.c:179:6: */
	XkRingDistances(tls, origin, k, out, uintptr(0))
}

// *
// Produce cells and their distances from the given origin cell, up to
// distance k.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin      origin cell
// @param  k           k >= 0
// @param  out         zero-filled array which must be of size maxKringSize(k)
// @param  distances   NULL or a zero-filled array which must be of size
//                     maxKringSize(k)
func XkRingDistances(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr) { /* algos.c:199:6: */
	// Optimistically try the faster hexRange algorithm first
	var failed uint8 = uint8(XhexRangeDistances(tls, origin, k, out, distances))
	if failed != 0 {
		var maxIdx int32 = XmaxKringSize(tls, k)
		// Fast algo failed, fall back to slower, correct algo
		// and also wipe out array because contents untrustworthy
		libc.Xmemset(tls, out, 0, uint64(maxIdx)*uint64(unsafe.Sizeof(TH3Index(0))))

		if distances == uintptr(0) {
			distances = libc.Xcalloc(tls, uint64(maxIdx), uint64(unsafe.Sizeof(int32(0))))
			if !(distances != 0) {
				// TODO: Return an error code when this is not void
				return
			}
			X_kRingInternal(tls, origin, k, out, distances, maxIdx, 0)
			libc.Xfree(tls, distances)
		} else {
			libc.Xmemset(tls, distances, 0, uint64(maxIdx)*uint64(unsafe.Sizeof(int32(0))))
			X_kRingInternal(tls, origin, k, out, distances, maxIdx, 0)
		}
	}
}

// *
// Internal helper function called recursively for kRingDistances.
//
// Adds the origin cell to the output set (treating it as a hash set)
// and recurses to its neighbors, if needed.
//
// @param  origin      Origin cell
// @param  k           Maximum distance to move from the origin
// @param  out         Array treated as a hash set, elements being either
//                     H3Index or 0.
// @param  distances   Scratch area, with elements paralleling the out array.
//                     Elements indicate ijk distance from the origin cell to
//                     the output cell
// @param  maxIdx      Size of out and scratch arrays (must be maxKringSize(k))
// @param  curK        Current distance from the origin
func X_kRingInternal(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr, maxIdx int32, curK int32) { /* algos.c:240:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if origin == uint64(0) {
		return
	}

	// Put origin in the output array. out is used as a hash set.
	var off int32 = int32(origin % TH3Index(maxIdx))
	for *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) != uint64(0) && *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) != origin {
		off = (off + 1) % maxIdx
	}

	// We either got a free slot in the hash set or hit a duplicate
	// We might need to process the duplicate anyways because we got
	// here on a longer path before.
	if *(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) == origin && *(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) <= curK {
		return
	}

	*(*TH3Index)(unsafe.Pointer(out + uintptr(off)*8)) = origin
	*(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) = curK

	// Base case: reached an index k away from the origin.
	if curK >= k {
		return
	}

	// Recurse to all neighbors in no particular order.
	{
		var i int32 = 0
	__1:
		if !(i < 6) {
			goto __3
		}
		{
			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			X_kRingInternal(tls, Xh3NeighborRotations(tls, origin, sDIRECTIONS[i], bp),
				k, out, distances, maxIdx, curK+1)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// *
// Returns the hexagon index neighboring the origin, in the direction dir.
//
// Implementation note: The only reachable case where this returns 0 is if the
// origin is a pentagon and the translation is in the k direction. Thus,
// 0 can only be returned if origin is a pentagon.
//
// @param origin Origin index
// @param dir Direction to move in
// @param rotations Number of ccw rotations to perform to reorient the
//                  translation vector. Will be modified to the new number of
//                  rotations to perform (such as when crossing a face edge.)
// @return H3Index of the specified neighbor or H3_NULL if deleted k-subsequence
//         distortion is encountered.
func Xh3NeighborRotations(tls *libc.TLS, origin TH3Index, dir TDirection, rotations uintptr) TH3Index { /* algos.c:284:9: */
	var out TH3Index = origin

	{
		var i int32 = 0
	__1:
		if !(i < *(*int32)(unsafe.Pointer(rotations))) {
			goto __3
		}
		{
			dir = X_rotate60ccw(tls, dir)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	var newRotations int32 = 0
	var oldBaseCell int32 = int32(out & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	var oldLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, out)

	// Adjust the indexing digits and, if needed, the base cell.
	var r int32 = int32(out&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	for 1 != 0 {
		if r == -1 {
			out = out&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4)))<<DH3_BC_OFFSET
			newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4))

			if int32(out&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET) == DINVALID_BASE_CELL {
				// Adjust for the deleted k vertex at the base cell level.
				// This edge actually borders a different neighbor.
				out = out&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + 5*4)))<<DH3_BC_OFFSET
				newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + 5*4))

				// perform the adjustment for the k-subsequence we're skipping
				// over.
				out = X_h3Rotate60ccw(tls, out)
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}

			break
		} else {
			var oldDigit TDirection = TDirection(out >> ((DMAX_H3_RES - (r + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			var nextDir TDirection
			if oldDigit == INVALID_DIGIT {
				// Only possible on invalid input
				return uint64(DH3_NULL)
			} else if XisResClassIII(tls, r+1) != 0 {
				out = out & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(*(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			} else {
				out = out & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(*(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*TDirection)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			}

			if nextDir != CENTER_DIGIT {
				dir = nextDir
				r--
			} else {
				// No more adjustment to perform
				break
			}
		}
	}

	var newBaseCell int32 = int32(out & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if X_isBaseCellPentagon(tls, newBaseCell) != 0 {
		var alreadyAdjustedKSubsequence int32 = 0

		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, out) == K_AXES_DIGIT {
			if oldBaseCell != newBaseCell {
				// in this case, we traversed into the deleted
				// k subsequence of a pentagon base cell.
				// We need to rotate out of that case depending
				// on how we got here.
				// check for a cw/ccw offset face; default is ccw

				if X_baseCellIsCwOffset(tls,
					newBaseCell, XbaseCellData[oldBaseCell].FhomeFijk.Fface) != 0 {
					out = X_h3Rotate60cw(tls, out)
				} else {
					// See cwOffsetPent in testKRing.c for why this is
					// unreachable.
					out = X_h3Rotate60ccw(tls, out) // LCOV_EXCL_LINE
				}
				alreadyAdjustedKSubsequence = 1
			} else {
				// In this case, we traversed into the deleted
				// k subsequence from within the same pentagon
				// base cell.
				if oldLeadingDigit == CENTER_DIGIT {
					// Undefined: the k direction is deleted from here
					return uint64(DH3_NULL)
				} else if oldLeadingDigit == JK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					out = X_h3Rotate60ccw(tls, out)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				} else if oldLeadingDigit == IK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					out = X_h3Rotate60cw(tls, out)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 5
				} else {
					// Should never occur
					return uint64(DH3_NULL) // LCOV_EXCL_LINE
				}
			}
		}

		{
			var i int32 = 0
		__4:
			if !(i < newRotations) {
				goto __6
			}
			out = X_h3RotatePent60ccw(tls, out)
			goto __5
		__5:
			i++
			goto __4
			goto __6
		__6:
		}

		// Account for differing orientation of the base cells (this edge
		// might not follow properties of some other edges.)
		if oldBaseCell != newBaseCell {
			if X_isBaseCellPolarPentagon(tls, newBaseCell) != 0 {
				// 'polar' base cells behave differently because they have all
				// i neighbors.
				if oldBaseCell != 118 && oldBaseCell != 8 && X_h3LeadingNonZeroDigit(tls, out) != JK_AXES_DIGIT {
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				}
			} else if X_h3LeadingNonZeroDigit(tls, out) == IK_AXES_DIGIT && !(alreadyAdjustedKSubsequence != 0) {
				// account for distortion introduced to the 5 neighbor by the
				// deleted k subsequence.
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}
		}
	} else {
		{
			var i int32 = 0
		__7:
			if !(i < newRotations) {
				goto __9
			}
			out = X_h3Rotate60ccw(tls, out)
			goto __8
		__8:
			i++
			goto __7
			goto __9
		__9:
		}
	}

	*(*int32)(unsafe.Pointer(rotations)) = (*(*int32)(unsafe.Pointer(rotations)) + newRotations) % 6

	return out
}

// *
// hexRange produces indexes within k distance of the origin index.
// Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxKringSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XhexRange(tls *libc.TLS, origin TH3Index, k int32, out uintptr) int32 { /* algos.c:433:5: */
	return XhexRangeDistances(tls, origin, k, out, uintptr(0))
}

// *
// hexRange produces indexes within k distance of the origin index.
// Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin. The distances in hexagons is placed in the distances array at
// the same offset.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxKringSize(k).
// @param distances Null or array which must be of size maxKringSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XhexRangeDistances(tls *libc.TLS, origin TH3Index, k int32, out uintptr, distances uintptr) int32 { /* algos.c:455:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// Return codes:
	// 1 Pentagon was encountered
	// 2 Pentagon distortion (deleted k subsequence) was encountered
	// Pentagon being encountered is not itself a problem; really the deleted
	// k-subsequence is the problem, but for compatibility reasons we fail on
	// the pentagon.

	// k must be >= 0, so origin is always needed
	var idx int32 = 0
	*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = origin
	if distances != 0 {
		*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = 0
	}
	idx++

	if Xh3IsPentagon(tls, origin) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return DHEX_RANGE_PENTAGON
	}

	// 0 < ring <= k, current ring
	var ring int32 = 1
	// 0 <= direction < 6, current side of the ring
	var direction int32 = 0
	// 0 <= i < ring, current position on the side of the ring
	var i int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0

	for ring <= k {
		if direction == 0 && i == 0 {
			// Not putting in the output set as it will be done later, at
			// the end of this ring.
			origin = Xh3NeighborRotations(tls, origin, sNEXT_RING_DIRECTION, bp)
			if origin == uint64(0) { // LCOV_EXCL_BR_LINE
				// Should not be possible because `origin` would have to be a
				// pentagon
				return DHEX_RANGE_K_SUBSEQUENCE // LCOV_EXCL_LINE
			}

			if Xh3IsPentagon(tls, origin) != 0 {
				// Pentagon was encountered; bail out as user doesn't want this.
				return DHEX_RANGE_PENTAGON
			}
		}

		origin = Xh3NeighborRotations(tls, origin, sDIRECTIONS[direction], bp)
		if origin == uint64(0) { // LCOV_EXCL_BR_LINE
			// Should not be possible because `origin` would have to be a
			// pentagon
			return DHEX_RANGE_K_SUBSEQUENCE // LCOV_EXCL_LINE
		}
		*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = origin
		if distances != 0 {
			*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = ring
		}
		idx++

		i++
		// Check if end of this side of the k-ring
		if i == ring {
			i = 0
			direction++
			// Check if end of this ring.
			if direction == 6 {
				direction = 0
				ring++
			}
		}

		if Xh3IsPentagon(tls, origin) != 0 {
			// Pentagon was encountered; bail out as user doesn't want this.
			return DHEX_RANGE_PENTAGON
		}
	}
	return DHEX_RANGE_SUCCESS
}

// *
// hexRanges takes an array of input hex IDs and a max k-ring and returns an
// array of hexagon IDs sorted first by the original hex IDs and then by the
// k-ring (0 to max), with no guaranteed sorting within each k-ring group.
//
// @param h3Set A pointer to an array of H3Indexes
// @param length The total number of H3Indexes in h3Set
// @param k The number of rings to generate
// @param out A pointer to the output memory to dump the new set of H3Indexes to
//            The memory block should be equal to maxKringSize(k) * length
// @return 0 if no pentagon is encountered. Cannot trust output otherwise
func XhexRanges(tls *libc.TLS, h3Set uintptr, length int32, k int32, out uintptr) int32 { /* algos.c:549:5: */
	var success int32 = 0
	var segment uintptr
	var segmentSize int32 = XmaxKringSize(tls, k)
	{
		var i int32 = 0
	__1:
		if !(i < length) {
			goto __3
		}
		{
			// Determine the appropriate segment of the output array to operate on
			segment = out + uintptr(i*segmentSize)*8
			success = XhexRange(tls, *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8)), k, segment)
			if success != 0 {
				return success
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return 0
}

// *
// Returns the "hollow" ring of hexagons at exactly grid distance k from
// the origin hexagon. In particular, k=0 returns just the origin hexagon.
//
// A nonzero failure code may be returned in some cases, for example,
// if a pentagon is encountered.
// Failure cases may be fixed in future versions.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size 6 * k (or 1 if k == 0)
// @return 0 if successful; nonzero otherwise.
func XhexRing(tls *libc.TLS, origin TH3Index, k int32, out uintptr) int32 { /* algos.c:575:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// Short-circuit on 'identity' ring
	if k == 0 {
		*(*TH3Index)(unsafe.Pointer(out)) = origin
		return 0
	}
	var idx int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
	// Scratch structure for checking for pentagons
	if Xh3IsPentagon(tls, origin) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return DHEX_RANGE_PENTAGON
	}

	{
		var ring int32 = 0
	__1:
		if !(ring < k) {
			goto __3
		}
		{
			origin = Xh3NeighborRotations(tls, origin, sNEXT_RING_DIRECTION, bp)
			if origin == uint64(0) { // LCOV_EXCL_BR_LINE
				// Should not be possible because `origin` would have to be a
				// pentagon
				return DHEX_RANGE_K_SUBSEQUENCE // LCOV_EXCL_LINE
			}

			if Xh3IsPentagon(tls, origin) != 0 {
				return DHEX_RANGE_PENTAGON
			}

		}
		goto __2
	__2:
		ring++
		goto __1
		goto __3
	__3:
	}

	var lastIndex TH3Index = origin

	*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = origin
	idx++

	{
		var direction int32 = 0
	__4:
		if !(direction < 6) {
			goto __6
		}
		{
			{
				var pos int32 = 0
			__7:
				if !(pos < k) {
					goto __9
				}
				{
					origin = Xh3NeighborRotations(tls, origin, sDIRECTIONS[direction], bp)
					if origin == uint64(0) { // LCOV_EXCL_BR_LINE
						// Should not be possible because `origin` would have to be a
						// pentagon
						return DHEX_RANGE_K_SUBSEQUENCE // LCOV_EXCL_LINE
					}

					// Skip the very last index, it was already added. We do
					// however need to traverse to it because of the pentagonal
					// distortion check, below.
					if pos != k-1 || direction != 5 {
						*(*TH3Index)(unsafe.Pointer(out + uintptr(idx)*8)) = origin
						idx++

						if Xh3IsPentagon(tls, origin) != 0 {
							return DHEX_RANGE_PENTAGON
						}
					}

				}
				goto __8
			__8:
				pos++
				goto __7
				goto __9
			__9:
			}

		}
		goto __5
	__5:
		direction++
		goto __4
		goto __6
	__6:
	}

	// Check that this matches the expected lastIndex, if it doesn't,
	// it indicates pentagonal distortion occurred and we should report
	// failure.
	if lastIndex != origin {
		return DHEX_RANGE_PENTAGON
	} else {
		return DHEX_RANGE_SUCCESS
	}
	return int32(0)
}

// *
// maxPolyfillSize returns the number of hexagons to allocate space for when
// performing a polyfill on the given GeoJSON-like data structure.
//
// The size is the maximum of either the number of points in the geofence or the
// number of hexagons in the bounding box of the geofence.
//
// @param geoPolygon A GeoJSON-like data structure indicating the poly to fill
// @param res Hexagon resolution (0-15)
// @return number of hexagons to allocate for
func XmaxPolyfillSize(tls *libc.TLS, geoPolygon uintptr, res int32) int32 { /* algos.c:654:5: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// Get the bounding box for the GeoJSON-like struct
	// var bbox TBBox at bp+16, 32

	*(*TGeofence)(unsafe.Pointer(bp /* geofence */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeofence
	XbboxFromGeofence(tls, bp, bp+16)
	var numHexagons int32 = XbboxHexEstimate(tls, bp+16, res)
	// This algorithm assumes that the number of vertices is usually less than
	// the number of hexagons, but when it's wrong, this will keep it from
	// failing
	var totalVerts int32 = (*TGeofence)(unsafe.Pointer(bp /* &geofence */)).FnumVerts
	{
		var i int32 = 0
	__1:
		if !(i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles) {
			goto __3
		}
		{
			totalVerts = totalVerts + (*TGeofence)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16)).FnumVerts

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	if numHexagons < totalVerts {
		numHexagons = totalVerts
	}
	// When the polygon is very small, near an icosahedron edge and is an odd
	// resolution, the line tracing needs an extra buffer than the estimator
	// function provides (but beefing that up to cover causes most situations to
	// overallocate memory)
	numHexagons = numHexagons + DPOLYFILL_BUFFER
	return numHexagons
}

// *
// polyfill takes a given GeoJSON-like data structure and preallocated,
// zeroed memory, and fills it with the hexagons that are contained by
// the GeoJSON-like data structure.
//
// This implementation traces the GeoJSON geofence(s) in cartesian space with
// hexagons, tests them and their neighbors to be contained by the geofence(s),
// and then any newly found hexagons are used to test again until no new
// hexagons are found.
//
// @param geoPolygon The geofence and holes defining the relevant area
// @param res The Hexagon resolution (0-15)
// @param out The slab of zeroed memory to write to. Assumed to be big enough.
func Xpolyfill(tls *libc.TLS, geoPolygon uintptr, res int32, out uintptr) { /* algos.c:690:6: */
	// TODO: Eliminate this wrapper with the H3 4.0.0 release
	var failure int32 = X_polyfillInternal(tls, geoPolygon, res, out)
	// The polyfill algorithm can theoretically fail if the allocated memory is
	// not large enough for the polygon, but this should be impossible given the
	// conservative overestimation of the number of hexagons possible.
	// LCOV_EXCL_START
	if failure != 0 {
		var numHexagons int32 = XmaxPolyfillSize(tls, geoPolygon, res)
		{
			var i int32 = 0
		__1:
			if !(i < numHexagons) {
				goto __3
			}
			*(*TH3Index)(unsafe.Pointer(out + uintptr(i)*8)) = uint64(DH3_NULL)
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
		}
	}
	// LCOV_EXCL_STOP
}

// *
// _getEdgeHexagons takes a given geofence ring (either the main geofence or
// one of the holes) and traces it with hexagons and updates the search and
// found memory blocks. This is used for determining the initial hexagon set
// for the polyfill algorithm to execute on.
//
// @param geofence The geofence (or hole) to be traced
// @param numHexagons The maximum number of hexagons possible for the geofence
//                    (also the bounds of the search and found arrays)
// @param res The hexagon resolution (0-15)
// @param numSearchHexes The number of hexagons found so far to be searched
// @param search The block of memory containing the hexagons to search from
// @param found The block of memory containing the hexagons found from the
// search
//
// @return An error code if the hash function cannot insert a found hexagon
//         into the found array.
func X_getEdgeHexagons(tls *libc.TLS, geofence uintptr, numHexagons int32, res int32, numSearchHexes uintptr, search uintptr, found uintptr) int32 { /* algos.c:722:5: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	{
		var i int32 = 0
	__1:
		if !(i < (*TGeofence)(unsafe.Pointer(geofence)).FnumVerts) {
			goto __3
		}
		{
			*(*TGeoCoord)(unsafe.Pointer(bp /* origin */)) = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(geofence)).Fverts + uintptr(i)*16))
			if i == (*TGeofence)(unsafe.Pointer(geofence)).FnumVerts-1 {
				*(*TGeoCoord)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(geofence)).Fverts))
			} else {
				*(*TGeoCoord)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(geofence)).Fverts + uintptr(i+1)*16))
			}
			var numHexesEstimate int32 = XlineHexEstimate(tls, bp, bp+16, res)
			{
				var j int32 = 0
			__4:
				if !(j < numHexesEstimate) {
					goto __6
				}
				{
					// var interpolate TGeoCoord at bp+32, 16

					(*TGeoCoord)(unsafe.Pointer(bp + 32 /* &interpolate */)).Flat = (*TGeoCoord)(unsafe.Pointer(bp)).Flat*float64(numHexesEstimate-j)/float64(numHexesEstimate) + (*TGeoCoord)(unsafe.Pointer(bp+16)).Flat*float64(j)/float64(numHexesEstimate)
					(*TGeoCoord)(unsafe.Pointer(bp + 32 /* &interpolate */)).Flon = (*TGeoCoord)(unsafe.Pointer(bp)).Flon*float64(numHexesEstimate-j)/float64(numHexesEstimate) + (*TGeoCoord)(unsafe.Pointer(bp+16)).Flon*float64(j)/float64(numHexesEstimate)
					var pointHex TH3Index = XgeoToH3(tls, bp+32, res)
					// A simple hash to store the hexagon, or move to another place if
					// needed
					var loc int32 = int32(pointHex % TH3Index(numHexagons))
					var loopCount int32 = 0
					for *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) != uint64(0) {
						// If this conditional is reached, the `found` memory block is
						// too small for the given polygon. This should not happen.
						if loopCount > numHexagons {
							return -1
						} // LCOV_EXCL_LINE
						if *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) == pointHex {
							break
						} // At least two points of the geofence index to the
						// same cell
						loc = (loc + 1) % numHexagons
						loopCount++
					}
					if *(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) == pointHex {
						goto __5
					} // Skip this hex, already exists in the found hash
					// Otherwise, set it in the found hash for now
					*(*TH3Index)(unsafe.Pointer(found + uintptr(loc)*8)) = pointHex

					*(*TH3Index)(unsafe.Pointer(search + uintptr(*(*int32)(unsafe.Pointer(numSearchHexes)))*8)) = pointHex
					*(*int32)(unsafe.Pointer(numSearchHexes))++

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return 0
}

// *
// _polyfillInternal traces the provided geoPolygon data structure with hexagons
// and then iteratively searches through these hexagons and their immediate
// neighbors to see if they are contained within the polygon or not. Those that
// are found are added to the out array as well as the found array. Once all
// hexagons to search are checked, the found hexagons become the new search
// array and the found array is wiped and the process repeats until no new
// hexagons can be found.
//
// @param geoPolygon The geofence and holes defining the relevant area
// @param res The Hexagon resolution (0-15)
// @param out The slab of zeroed memory to write to. Assumed to be big enough.
//
// @return An error code if any of the hash operations fails to insert a hexagon
//         into an array of memory.
func X_polyfillInternal(tls *libc.TLS, geoPolygon uintptr, res int32, out uintptr) int32 { /* algos.c:783:5: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// One of the goals of the polyfill algorithm is that two adjacent polygons
	// with zero overlap have zero overlapping hexagons. That the hexagons are
	// uniquely assigned. There are a few approaches to take here, such as
	// deciding based on which polygon has the greatest overlapping area of the
	// hexagon, or the most number of contained points on the hexagon (using the
	// center point as a tiebreaker).
	//
	// But if the polygons are convex, both of these more complex algorithms can
	// be reduced down to checking whether or not the center of the hexagon is
	// contained in the polygon, and so this is the approach that this polyfill
	// algorithm will follow, as it's simpler, faster, and the error for concave
	// polygons is still minimal (only affecting concave shapes on the order of
	// magnitude of the hexagon size or smaller, not impacting larger concave
	// shapes)
	//
	// This first part is identical to the maxPolyfillSize above.

	// Get the bounding boxes for the polygon and any holes
	var bboxes uintptr = libc.Xmalloc(tls, uint64((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles+1)*uint64(unsafe.Sizeof(TBBox{})))
	if bboxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts, ts+15, uint32(803), uintptr(unsafe.Pointer(&__func__)))
	}
	XbboxesFromGeoPolygon(tls, geoPolygon, bboxes)

	// Get the estimated number of hexagons and allocate some temporary memory
	// for the hexagons
	var numHexagons int32 = XmaxPolyfillSize(tls, geoPolygon, res)
	var search uintptr = libc.Xcalloc(tls, uint64(numHexagons), uint64(unsafe.Sizeof(TH3Index(0))))
	var found uintptr = libc.Xcalloc(tls, uint64(numHexagons), uint64(unsafe.Sizeof(TH3Index(0))))

	// Some metadata for tracking the state of the search and found memory
	// blocks
	*(*int32)(unsafe.Pointer(bp + 16 /* numSearchHexes */)) = 0
	var numFoundHexes int32 = 0

	// 1. Trace the hexagons along the polygon defining the outer geofence and
	// add them to the search hash. The hexagon containing the geofence point
	// may or may not be contained by the geofence (as the hexagon's center
	// point may be outside of the boundary.)
	*(*TGeofence)(unsafe.Pointer(bp /* geofence */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeofence
	var failure int32 = X_getEdgeHexagons(tls, bp, numHexagons, res, bp+16,
		search, found)
	// If this branch is reached, we have exceeded the maximum number of
	// hexagons possible and need to clean up the allocated memory.
	// LCOV_EXCL_START
	if failure != 0 {
		libc.Xfree(tls, search)
		libc.Xfree(tls, found)
		libc.Xfree(tls, bboxes)
		return failure
	}
	// LCOV_EXCL_STOP

	// 2. Iterate over all holes, trace the polygons defining the holes with
	// hexagons and add to only the search hash. We're going to temporarily use
	// the `found` hash to use for dedupe purposes and then re-zero it once
	// we're done here, otherwise we'd have to scan the whole set on each insert
	// to make sure there's no duplicates, which is very inefficient.
	{
		var i int32 = 0
	__1:
		if !(i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles) {
			goto __3
		}
		{
			var hole uintptr = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes + uintptr(i)*16
			failure = X_getEdgeHexagons(tls, hole, numHexagons, res, bp+16,
				search, found)
			// If this branch is reached, we have exceeded the maximum number of
			// hexagons possible and need to clean up the allocated memory.
			// LCOV_EXCL_START
			if failure != 0 {
				libc.Xfree(tls, search)
				libc.Xfree(tls, found)
				libc.Xfree(tls, bboxes)
				return failure
			}
			// LCOV_EXCL_STOP

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// 3. Re-zero the found hash so it can be used in the main loop below
	{
		var i1 int32 = 0
	__4:
		if !(i1 < numHexagons) {
			goto __6
		}
		*(*TH3Index)(unsafe.Pointer(found + uintptr(i1)*8)) = uint64(0)
		goto __5
	__5:
		i1++
		goto __4
		goto __6
	__6:
	}

	// 4. Begin main loop. While the search hash is not empty do the following
	for *(*int32)(unsafe.Pointer(bp + 16)) > 0 {
		// Iterate through all hexagons in the current search hash, then loop
		// through all neighbors and test Point-in-Poly, if point-in-poly
		// succeeds, add to out and found hashes if not already there.
		var currentSearchNum int32 = 0
		var i int32 = 0
		for currentSearchNum < *(*int32)(unsafe.Pointer(bp + 16)) {
			*(*[7]TH3Index)(unsafe.Pointer(bp + 24 /* ring */)) = [7]TH3Index{0: uint64(0)}
			var searchHex TH3Index = *(*TH3Index)(unsafe.Pointer(search + uintptr(i)*8))
			XkRing(tls, searchHex, 1, bp+24)
			{
				var j int32 = 0
			__7:
				if !(j < DMAX_ONE_RING_SIZE) {
					goto __9
				}
				{
					if *(*TH3Index)(unsafe.Pointer(bp + 24 + uintptr(j)*8)) == uint64(DH3_NULL) {
						goto __8 // Skip if this was a pentagon and only had 5
						// neighbors
					}

					var hex TH3Index = *(*TH3Index)(unsafe.Pointer(bp + 24 + uintptr(j)*8))

					// A simple hash to store the hexagon, or move to another place
					// if needed. This MUST be done before the point-in-poly check
					// since that's far more expensive
					var loc int32 = int32(hex % TH3Index(numHexagons))
					var loopCount int32 = 0
					for *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) != uint64(0) {
						// If this branch is reached, we have exceeded the maximum
						// number of hexagons possible and need to clean up the
						// allocated memory.
						// LCOV_EXCL_START
						if loopCount > numHexagons {
							libc.Xfree(tls, search)
							libc.Xfree(tls, found)
							libc.Xfree(tls, bboxes)
							return -1
						}
						// LCOV_EXCL_STOP
						if *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
							break
						} // Skip duplicates found
						loc = (loc + 1) % numHexagons
						loopCount++
					}
					if *(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
						goto __8 // Skip this hex, already exists in the out hash
					}

					// Check if the hexagon is in the polygon or not
					// var hexCenter TGeoCoord at bp+80, 16

					Xh3ToGeo(tls, hex, bp+80)

					// If not, skip
					if !(XpointInsidePolygon(tls, geoPolygon, bboxes, bp+80) != 0) {
						goto __8
					}

					// Otherwise set it in the output array
					*(*TH3Index)(unsafe.Pointer(out + uintptr(loc)*8)) = hex

					// Set the hexagon in the found hash
					*(*TH3Index)(unsafe.Pointer(found + uintptr(numFoundHexes)*8)) = hex
					numFoundHexes++

				}
				goto __8
			__8:
				j++
				goto __7
				goto __9
			__9:
			}
			currentSearchNum++
			i++
		}

		// Swap the search and found pointers, copy the found hex count to the
		// search hex count, and zero everything related to the found memory.
		var temp uintptr = search
		search = found
		found = temp
		{
			var j int32 = 0
		__10:
			if !(j < *(*int32)(unsafe.Pointer(bp + 16))) {
				goto __12
			}
			*(*TH3Index)(unsafe.Pointer(found + uintptr(j)*8)) = uint64(0)
			goto __11
		__11:
			j++
			goto __10
			goto __12
		__12:
		}
		*(*int32)(unsafe.Pointer(bp + 16 /* numSearchHexes */)) = numFoundHexes
		numFoundHexes = 0
		// Repeat until no new hexagons are found
	}
	// The out memory structure should be complete, end it here
	libc.Xfree(tls, bboxes)
	libc.Xfree(tls, search)
	libc.Xfree(tls, found)
	return 0
}

var __func__ = *(*[18]uint8)(unsafe.Pointer(ts + 40)) /* algos.c:783:76 */

// *
// Internal: Create a vertex graph from a set of hexagons. It is the
// responsibility of the caller to call destroyVertexGraph on the populated
// graph, otherwise the memory in the graph nodes will not be freed.
// @private
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in the set
// @param graph    Output graph
func Xh3SetToVertexGraph(tls *libc.TLS, h3Set uintptr, numHexes int32, graph uintptr) { /* algos.c:949:6: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var vertices TGeoBoundary at bp, 168

	var fromVtx uintptr
	var toVtx uintptr
	var edge uintptr
	if numHexes < 1 {
		// We still need to init the graph, or calls to destroyVertexGraph will
		// fail
		XinitVertexGraph(tls, graph, 0, 0)
		return
	}
	var res int32 = int32(*(*TH3Index)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var minBuckets int32 = 6
	// TODO: Better way to calculate/guess?
	var numBuckets int32
	if numHexes > minBuckets {
		numBuckets = numHexes
	} else {
		numBuckets = minBuckets
	}
	XinitVertexGraph(tls, graph, numBuckets, res)
	// Iterate through every hexagon
	{
		var i int32 = 0
	__1:
		if !(i < numHexes) {
			goto __3
		}
		{
			Xh3ToGeoBoundary(tls, *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8)), bp)
			// iterate through every edge
			{
				var j int32 = 0
			__4:
				if !(j < (*TGeoBoundary)(unsafe.Pointer(bp)).FnumVerts) {
					goto __6
				}
				{
					fromVtx = bp + 8 + uintptr(j)*16
					toVtx = bp + 8 + uintptr((j+1)%(*TGeoBoundary)(unsafe.Pointer(bp)).FnumVerts)*16
					// If we've seen this edge already, it will be reversed
					edge = XfindNodeForEdge(tls, graph, toVtx, fromVtx)
					if edge != uintptr(0) {
						// If we've seen it, drop it. No edge is shared by more than 2
						// hexagons, so we'll never see it again.
						XremoveVertexNode(tls, graph, edge)
					} else {
						// Add a new node for this edge
						XaddVertexNode(tls, graph, fromVtx, toVtx)
					}

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// *
// Internal: Create a LinkedGeoPolygon from a vertex graph. It is the
// responsibility of the caller to call destroyLinkedPolygon on the populated
// linked geo structure, or the memory for that structure will not be freed.
// @private
// @param graph Input graph
// @param out   Output polygon
func X_vertexGraphToLinkedGeo(tls *libc.TLS, graph uintptr, out uintptr) { /* algos.c:995:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TLinkedGeoPolygon)(unsafe.Pointer(out)) = TLinkedGeoPolygon{}
	var loop uintptr
	var edge uintptr
	// var nextVtx TGeoCoord at bp, 16

	// Find the next unused entry point
	for libc.AssignUintptr(&edge, XfirstVertexNode(tls, graph)) != uintptr(0) {
		loop = XaddNewLinkedLoop(tls, out)
		// Walk the graph to get the outline
		for __ccgo := true; __ccgo; __ccgo = edge != 0 {
			XaddLinkedCoord(tls, loop, edge)
			*(*TGeoCoord)(unsafe.Pointer(bp /* nextVtx */)) = (*TVertexNode)(unsafe.Pointer(edge)).Fto
			// Remove frees the node, so we can't use edge after this
			XremoveVertexNode(tls, graph, edge)
			edge = XfindNodeForVertex(tls, graph, bp)
		}
	}
}

// *
// Create a LinkedGeoPolygon describing the outline(s) of a set of  hexagons.
// Polygon outlines will follow GeoJSON MultiPolygon order: Each polygon will
// have one outer loop, which is first in the list, followed by any holes.
//
// It is the responsibility of the caller to call destroyLinkedPolygon on the
// populated linked geo structure, or the memory for that structure will
// not be freed.
//
// It is expected that all hexagons in the set have the same resolution and
// that the set contains no duplicates. Behavior is undefined if duplicates
// or multiple resolutions are present, and the algorithm may produce
// unexpected or invalid output.
//
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in set
// @param out      Output polygon
func Xh3SetToLinkedGeo(tls *libc.TLS, h3Set uintptr, numHexes int32, out uintptr) { /* algos.c:1032:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var graph TVertexGraph at bp, 24

	Xh3SetToVertexGraph(tls, h3Set, numHexes, bp)
	X_vertexGraphToLinkedGeo(tls, bp, out)
	// TODO: The return value, possibly indicating an error, is discarded here -
	// we should use this when we update the API to return a value
	XnormalizeMultiPolygon(tls, out)
	XdestroyVertexGraph(tls, bp)
}

// * @struct BaseCellRotation
//  @brief base cell at a given ijk and required rotations into its system
type TBaseCellRotation = struct {
	FbaseCell int32
	FccwRot60 int32
} /* baseCells.c:31:3 */

// * @brief Neighboring base cell ID in each IJK direction.
//
// For each base cell, for each direction, the neighboring base
// cell ID is given. 127 indicates there is no neighbor in that direction.
var XbaseCellNeighbors = [122][7]int32{
	{0, 1, 5, 2, 4, 3, 8},                          // base cell 0
	{1, 7, 6, 9, 0, 3, 2},                          // base cell 1
	{2, 6, 10, 11, 0, 1, 5},                        // base cell 2
	{3, 13, 1, 7, 4, 12, 0},                        // base cell 3
	{4, DINVALID_BASE_CELL, 15, 8, 3, 0, 12},       // base cell 4 (pentagon)
	{5, 2, 18, 10, 8, 0, 16},                       // base cell 5
	{6, 14, 11, 17, 1, 9, 2},                       // base cell 6
	{7, 21, 9, 19, 3, 13, 1},                       // base cell 7
	{8, 5, 22, 16, 4, 0, 15},                       // base cell 8
	{9, 19, 14, 20, 1, 7, 6},                       // base cell 9
	{10, 11, 24, 23, 5, 2, 18},                     // base cell 10
	{11, 17, 23, 25, 2, 6, 10},                     // base cell 11
	{12, 28, 13, 26, 4, 15, 3},                     // base cell 12
	{13, 26, 21, 29, 3, 12, 7},                     // base cell 13
	{14, DINVALID_BASE_CELL, 17, 27, 9, 20, 6},     // base cell 14 (pentagon)
	{15, 22, 28, 31, 4, 8, 12},                     // base cell 15
	{16, 18, 33, 30, 8, 5, 22},                     // base cell 16
	{17, 11, 14, 6, 35, 25, 27},                    // base cell 17
	{18, 24, 30, 32, 5, 10, 16},                    // base cell 18
	{19, 34, 20, 36, 7, 21, 9},                     // base cell 19
	{20, 14, 19, 9, 40, 27, 36},                    // base cell 20
	{21, 38, 19, 34, 13, 29, 7},                    // base cell 21
	{22, 16, 41, 33, 15, 8, 31},                    // base cell 22
	{23, 24, 11, 10, 39, 37, 25},                   // base cell 23
	{24, DINVALID_BASE_CELL, 32, 37, 10, 23, 18},   // base cell 24 (pentagon)
	{25, 23, 17, 11, 45, 39, 35},                   // base cell 25
	{26, 42, 29, 43, 12, 28, 13},                   // base cell 26
	{27, 40, 35, 46, 14, 20, 17},                   // base cell 27
	{28, 31, 42, 44, 12, 15, 26},                   // base cell 28
	{29, 43, 38, 47, 13, 26, 21},                   // base cell 29
	{30, 32, 48, 50, 16, 18, 33},                   // base cell 30
	{31, 41, 44, 53, 15, 22, 28},                   // base cell 31
	{32, 30, 24, 18, 52, 50, 37},                   // base cell 32
	{33, 30, 49, 48, 22, 16, 41},                   // base cell 33
	{34, 19, 38, 21, 54, 36, 51},                   // base cell 34
	{35, 46, 45, 56, 17, 27, 25},                   // base cell 35
	{36, 20, 34, 19, 55, 40, 54},                   // base cell 36
	{37, 39, 52, 57, 24, 23, 32},                   // base cell 37
	{38, DINVALID_BASE_CELL, 34, 51, 29, 47, 21},   // base cell 38 (pentagon)
	{39, 37, 25, 23, 59, 57, 45},                   // base cell 39
	{40, 27, 36, 20, 60, 46, 55},                   // base cell 40
	{41, 49, 53, 61, 22, 33, 31},                   // base cell 41
	{42, 58, 43, 62, 28, 44, 26},                   // base cell 42
	{43, 62, 47, 64, 26, 42, 29},                   // base cell 43
	{44, 53, 58, 65, 28, 31, 42},                   // base cell 44
	{45, 39, 35, 25, 63, 59, 56},                   // base cell 45
	{46, 60, 56, 68, 27, 40, 35},                   // base cell 46
	{47, 38, 43, 29, 69, 51, 64},                   // base cell 47
	{48, 49, 30, 33, 67, 66, 50},                   // base cell 48
	{49, DINVALID_BASE_CELL, 61, 66, 33, 48, 41},   // base cell 49 (pentagon)
	{50, 48, 32, 30, 70, 67, 52},                   // base cell 50
	{51, 69, 54, 71, 38, 47, 34},                   // base cell 51
	{52, 57, 70, 74, 32, 37, 50},                   // base cell 52
	{53, 61, 65, 75, 31, 41, 44},                   // base cell 53
	{54, 71, 55, 73, 34, 51, 36},                   // base cell 54
	{55, 40, 54, 36, 72, 60, 73},                   // base cell 55
	{56, 68, 63, 77, 35, 46, 45},                   // base cell 56
	{57, 59, 74, 78, 37, 39, 52},                   // base cell 57
	{58, DINVALID_BASE_CELL, 62, 76, 44, 65, 42},   // base cell 58 (pentagon)
	{59, 63, 78, 79, 39, 45, 57},                   // base cell 59
	{60, 72, 68, 80, 40, 55, 46},                   // base cell 60
	{61, 53, 49, 41, 81, 75, 66},                   // base cell 61
	{62, 43, 58, 42, 82, 64, 76},                   // base cell 62
	{63, DINVALID_BASE_CELL, 56, 45, 79, 59, 77},   // base cell 63 (pentagon)
	{64, 47, 62, 43, 84, 69, 82},                   // base cell 64
	{65, 58, 53, 44, 86, 76, 75},                   // base cell 65
	{66, 67, 81, 85, 49, 48, 61},                   // base cell 66
	{67, 66, 50, 48, 87, 85, 70},                   // base cell 67
	{68, 56, 60, 46, 90, 77, 80},                   // base cell 68
	{69, 51, 64, 47, 89, 71, 84},                   // base cell 69
	{70, 67, 52, 50, 83, 87, 74},                   // base cell 70
	{71, 89, 73, 91, 51, 69, 54},                   // base cell 71
	{72, DINVALID_BASE_CELL, 73, 55, 80, 60, 88},   // base cell 72 (pentagon)
	{73, 91, 72, 88, 54, 71, 55},                   // base cell 73
	{74, 78, 83, 92, 52, 57, 70},                   // base cell 74
	{75, 65, 61, 53, 94, 86, 81},                   // base cell 75
	{76, 86, 82, 96, 58, 65, 62},                   // base cell 76
	{77, 63, 68, 56, 93, 79, 90},                   // base cell 77
	{78, 74, 59, 57, 95, 92, 79},                   // base cell 78
	{79, 78, 63, 59, 93, 95, 77},                   // base cell 79
	{80, 68, 72, 60, 99, 90, 88},                   // base cell 80
	{81, 85, 94, 101, 61, 66, 75},                  // base cell 81
	{82, 96, 84, 98, 62, 76, 64},                   // base cell 82
	{83, DINVALID_BASE_CELL, 74, 70, 100, 87, 92},  // base cell 83 (pentagon)
	{84, 69, 82, 64, 97, 89, 98},                   // base cell 84
	{85, 87, 101, 102, 66, 67, 81},                 // base cell 85
	{86, 76, 75, 65, 104, 96, 94},                  // base cell 86
	{87, 83, 102, 100, 67, 70, 85},                 // base cell 87
	{88, 72, 91, 73, 99, 80, 105},                  // base cell 88
	{89, 97, 91, 103, 69, 84, 71},                  // base cell 89
	{90, 77, 80, 68, 106, 93, 99},                  // base cell 90
	{91, 73, 89, 71, 105, 88, 103},                 // base cell 91
	{92, 83, 78, 74, 108, 100, 95},                 // base cell 92
	{93, 79, 90, 77, 109, 95, 106},                 // base cell 93
	{94, 86, 81, 75, 107, 104, 101},                // base cell 94
	{95, 92, 79, 78, 109, 108, 93},                 // base cell 95
	{96, 104, 98, 110, 76, 86, 82},                 // base cell 96
	{97, DINVALID_BASE_CELL, 98, 84, 103, 89, 111}, // base cell 97 (pentagon)
	{98, 110, 97, 111, 82, 96, 84},                 // base cell 98
	{99, 80, 105, 88, 106, 90, 113},                // base cell 99
	{100, 102, 83, 87, 108, 114, 92},               // base cell 100
	{101, 102, 107, 112, 81, 85, 94},               // base cell 101
	{102, 101, 87, 85, 114, 112, 100},              // base cell 102
	{103, 91, 97, 89, 116, 105, 111},               // base cell 103
	{104, 107, 110, 115, 86, 94, 96},               // base cell 104
	{105, 88, 103, 91, 113, 99, 116},               // base cell 105
	{106, 93, 99, 90, 117, 109, 113},               // base cell 106
	{107, DINVALID_BASE_CELL, 101, 94, 115, 104,
		112}, // base cell 107 (pentagon)
	{108, 100, 95, 92, 118, 114, 109},   // base cell 108
	{109, 108, 93, 95, 117, 118, 106},   // base cell 109
	{110, 98, 104, 96, 119, 111, 115},   // base cell 110
	{111, 97, 110, 98, 116, 103, 119},   // base cell 111
	{112, 107, 102, 101, 120, 115, 114}, // base cell 112
	{113, 99, 116, 105, 117, 106, 121},  // base cell 113
	{114, 112, 100, 102, 118, 120, 108}, // base cell 114
	{115, 110, 107, 104, 120, 119, 112}, // base cell 115
	{116, 103, 119, 111, 113, 105, 121}, // base cell 116
	{117, DINVALID_BASE_CELL, 109, 118, 113, 121,
		106}, // base cell 117 (pentagon)
	{118, 120, 108, 114, 117, 121, 109}, // base cell 118
	{119, 111, 115, 110, 121, 116, 120}, // base cell 119
	{120, 115, 114, 112, 121, 119, 118}, // base cell 120
	{121, 116, 120, 119, 117, 113, 118}, // base cell 121
} /* baseCells.c:38:11 */

// * @brief Neighboring base cell rotations in each IJK direction.
//
// For each base cell, for each direction, the number of 60 degree
// CCW rotations to the coordinate system of the neighbor is given.
// -1 indicates there is no neighbor in that direction.
var XbaseCellNeighbor60CCWRots = [122][7]int32{
	{0, 5, 0, 0, 1, 5, 1},  // base cell 0
	{0, 0, 1, 0, 1, 0, 1},  // base cell 1
	{0, 0, 0, 0, 0, 5, 0},  // base cell 2
	{0, 5, 0, 0, 2, 5, 1},  // base cell 3
	{0, -1, 1, 0, 3, 4, 2}, // base cell 4 (pentagon)
	{0, 0, 1, 0, 1, 0, 1},  // base cell 5
	{0, 0, 0, 3, 5, 5, 0},  // base cell 6
	{0, 0, 0, 0, 0, 5, 0},  // base cell 7
	{0, 5, 0, 0, 0, 5, 1},  // base cell 8
	{0, 0, 1, 3, 0, 0, 1},  // base cell 9
	{0, 0, 1, 3, 0, 0, 1},  // base cell 10
	{0, 3, 3, 3, 0, 0, 0},  // base cell 11
	{0, 5, 0, 0, 3, 5, 1},  // base cell 12
	{0, 0, 1, 0, 1, 0, 1},  // base cell 13
	{0, -1, 3, 0, 5, 2, 0}, // base cell 14 (pentagon)
	{0, 5, 0, 0, 4, 5, 1},  // base cell 15
	{0, 0, 0, 0, 0, 5, 0},  // base cell 16
	{0, 3, 3, 3, 3, 0, 3},  // base cell 17
	{0, 0, 0, 3, 5, 5, 0},  // base cell 18
	{0, 3, 3, 3, 0, 0, 0},  // base cell 19
	{0, 3, 3, 3, 0, 3, 0},  // base cell 20
	{0, 0, 0, 3, 5, 5, 0},  // base cell 21
	{0, 0, 1, 0, 1, 0, 1},  // base cell 22
	{0, 3, 3, 3, 0, 3, 0},  // base cell 23
	{0, -1, 3, 0, 5, 2, 0}, // base cell 24 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 25
	{0, 0, 0, 0, 0, 5, 0},  // base cell 26
	{0, 3, 0, 0, 0, 3, 3},  // base cell 27
	{0, 0, 1, 0, 1, 0, 1},  // base cell 28
	{0, 0, 1, 3, 0, 0, 1},  // base cell 29
	{0, 3, 3, 3, 0, 0, 0},  // base cell 30
	{0, 0, 0, 0, 0, 5, 0},  // base cell 31
	{0, 3, 3, 3, 3, 0, 3},  // base cell 32
	{0, 0, 1, 3, 0, 0, 1},  // base cell 33
	{0, 3, 3, 3, 3, 0, 3},  // base cell 34
	{0, 0, 3, 0, 3, 0, 3},  // base cell 35
	{0, 0, 0, 3, 0, 0, 3},  // base cell 36
	{0, 3, 0, 0, 0, 3, 3},  // base cell 37
	{0, -1, 3, 0, 5, 2, 0}, // base cell 38 (pentagon)
	{0, 3, 0, 0, 3, 3, 0},  // base cell 39
	{0, 3, 0, 0, 3, 3, 0},  // base cell 40
	{0, 0, 0, 3, 5, 5, 0},  // base cell 41
	{0, 0, 0, 3, 5, 5, 0},  // base cell 42
	{0, 3, 3, 3, 0, 0, 0},  // base cell 43
	{0, 0, 1, 3, 0, 0, 1},  // base cell 44
	{0, 0, 3, 0, 0, 3, 3},  // base cell 45
	{0, 0, 0, 3, 0, 3, 0},  // base cell 46
	{0, 3, 3, 3, 0, 3, 0},  // base cell 47
	{0, 3, 3, 3, 0, 3, 0},  // base cell 48
	{0, -1, 3, 0, 5, 2, 0}, // base cell 49 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 50
	{0, 3, 0, 0, 0, 3, 3},  // base cell 51
	{0, 0, 3, 0, 3, 0, 3},  // base cell 52
	{0, 3, 3, 3, 0, 0, 0},  // base cell 53
	{0, 0, 3, 0, 3, 0, 3},  // base cell 54
	{0, 0, 3, 0, 0, 3, 3},  // base cell 55
	{0, 3, 3, 3, 0, 0, 3},  // base cell 56
	{0, 0, 0, 3, 0, 3, 0},  // base cell 57
	{0, -1, 3, 0, 5, 2, 0}, // base cell 58 (pentagon)
	{0, 3, 3, 3, 3, 3, 0},  // base cell 59
	{0, 3, 3, 3, 3, 3, 0},  // base cell 60
	{0, 3, 3, 3, 3, 0, 3},  // base cell 61
	{0, 3, 3, 3, 3, 0, 3},  // base cell 62
	{0, -1, 3, 0, 5, 2, 0}, // base cell 63 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 64
	{0, 3, 3, 3, 0, 3, 0},  // base cell 65
	{0, 3, 0, 0, 0, 3, 3},  // base cell 66
	{0, 3, 0, 0, 3, 3, 0},  // base cell 67
	{0, 3, 3, 3, 0, 0, 0},  // base cell 68
	{0, 3, 0, 0, 3, 3, 0},  // base cell 69
	{0, 0, 3, 0, 0, 3, 3},  // base cell 70
	{0, 0, 0, 3, 0, 3, 0},  // base cell 71
	{0, -1, 3, 0, 5, 2, 0}, // base cell 72 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 73
	{0, 3, 3, 3, 0, 0, 3},  // base cell 74
	{0, 0, 0, 3, 0, 0, 3},  // base cell 75
	{0, 3, 0, 0, 0, 3, 3},  // base cell 76
	{0, 0, 0, 3, 0, 5, 0},  // base cell 77
	{0, 3, 3, 3, 0, 0, 0},  // base cell 78
	{0, 0, 1, 3, 1, 0, 1},  // base cell 79
	{0, 0, 1, 3, 1, 0, 1},  // base cell 80
	{0, 0, 3, 0, 3, 0, 3},  // base cell 81
	{0, 0, 3, 0, 3, 0, 3},  // base cell 82
	{0, -1, 3, 0, 5, 2, 0}, // base cell 83 (pentagon)
	{0, 0, 3, 0, 0, 3, 3},  // base cell 84
	{0, 0, 0, 3, 0, 3, 0},  // base cell 85
	{0, 3, 0, 0, 3, 3, 0},  // base cell 86
	{0, 3, 3, 3, 3, 3, 0},  // base cell 87
	{0, 0, 0, 3, 0, 5, 0},  // base cell 88
	{0, 3, 3, 3, 3, 3, 0},  // base cell 89
	{0, 0, 0, 0, 0, 0, 1},  // base cell 90
	{0, 3, 3, 3, 0, 0, 0},  // base cell 91
	{0, 0, 0, 3, 0, 5, 0},  // base cell 92
	{0, 5, 0, 0, 5, 5, 0},  // base cell 93
	{0, 0, 3, 0, 0, 3, 3},  // base cell 94
	{0, 0, 0, 0, 0, 0, 1},  // base cell 95
	{0, 0, 0, 3, 0, 3, 0},  // base cell 96
	{0, -1, 3, 0, 5, 2, 0}, // base cell 97 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 98
	{0, 5, 0, 0, 5, 5, 0},  // base cell 99
	{0, 0, 1, 3, 1, 0, 1},  // base cell 100
	{0, 3, 3, 3, 0, 0, 3},  // base cell 101
	{0, 3, 3, 3, 0, 0, 0},  // base cell 102
	{0, 0, 1, 3, 1, 0, 1},  // base cell 103
	{0, 3, 3, 3, 3, 3, 0},  // base cell 104
	{0, 0, 0, 0, 0, 0, 1},  // base cell 105
	{0, 0, 1, 0, 3, 5, 1},  // base cell 106
	{0, -1, 3, 0, 5, 2, 0}, // base cell 107 (pentagon)
	{0, 5, 0, 0, 5, 5, 0},  // base cell 108
	{0, 0, 1, 0, 4, 5, 1},  // base cell 109
	{0, 3, 3, 3, 0, 0, 0},  // base cell 110
	{0, 0, 0, 3, 0, 5, 0},  // base cell 111
	{0, 0, 0, 3, 0, 5, 0},  // base cell 112
	{0, 0, 1, 0, 2, 5, 1},  // base cell 113
	{0, 0, 0, 0, 0, 0, 1},  // base cell 114
	{0, 0, 1, 3, 1, 0, 1},  // base cell 115
	{0, 5, 0, 0, 5, 5, 0},  // base cell 116
	{0, -1, 1, 0, 3, 4, 2}, // base cell 117 (pentagon)
	{0, 0, 1, 0, 0, 5, 1},  // base cell 118
	{0, 0, 0, 0, 0, 0, 1},  // base cell 119
	{0, 5, 0, 0, 5, 5, 0},  // base cell 120
	{0, 0, 1, 0, 1, 5, 1},  // base cell 121
} /* baseCells.c:171:11 */

// * @brief Resolution 0 base cell lookup table for each face.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, gives the base cell located at that
// coordinate and the number of 60 ccw rotations to rotate into that base
// cell's orientation.
//
// Valid lookup coordinates are from (0, 0, 0) to (2, 2, 2).
//
// This table can be accessed using the functions `_faceIjkToBaseCell` and
// `_faceIjkToBaseCellCCWrot60`
var faceIjkBaseCells = [20][3][3][3]TBaseCellRotation{{
	{{{FbaseCell: 16}, {FbaseCell: 18}, {FbaseCell: 24}}, // j 0
		{{FbaseCell: 33}, {FbaseCell: 30}, {FbaseCell: 32, FccwRot60: 3}}, // j 1
		{{FbaseCell: 49, FccwRot60: 1}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}},
	{
		{
			// i 1
			{FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}, {FbaseCell: 10, FccwRot60: 5}}, // j 0
		{{FbaseCell: 22}, {FbaseCell: 16}, {FbaseCell: 18}}, // j 1
		{{FbaseCell: 41, FccwRot60: 1}, {FbaseCell: 33}, {FbaseCell: 30}}},
	{
		{
			// i 2
			{FbaseCell: 4}, {FccwRot60: 5}, {FbaseCell: 2, FccwRot60: 5}}, // j 0
		{{FbaseCell: 15, FccwRot60: 1}, {FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}}, // j 1
		{{FbaseCell: 31, FccwRot60: 1}, {FbaseCell: 22}, {FbaseCell: 16}}}},
	{
		{ // face 1
			{
				{FbaseCell: 2}, {FbaseCell: 6}, {FbaseCell: 14}}, // j 0
			{{FbaseCell: 10}, {FbaseCell: 11}, {FbaseCell: 17, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 1}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}},
		{
			{
				// i 1
				{}, {FbaseCell: 1, FccwRot60: 5}, {FbaseCell: 9, FccwRot60: 5}}, // j 0
			{{FbaseCell: 5}, {FbaseCell: 2}, {FbaseCell: 6}}, // j 1
			{{FbaseCell: 18, FccwRot60: 1}, {FbaseCell: 10}, {FbaseCell: 11}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 1}, {FbaseCell: 3, FccwRot60: 5}, {FbaseCell: 7, FccwRot60: 5}}, // j 0
			{{FbaseCell: 8, FccwRot60: 1}, {}, {FbaseCell: 1, FccwRot60: 5}}, // j 1
			{{FbaseCell: 16, FccwRot60: 1}, {FbaseCell: 5}, {FbaseCell: 2}}}},
	{
		{ // face 2
			{
				{FbaseCell: 7}, {FbaseCell: 21}, {FbaseCell: 38}}, // j 0
			{{FbaseCell: 9}, {FbaseCell: 19}, {FbaseCell: 34, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 1}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}, {FbaseCell: 29, FccwRot60: 5}}, // j 0
			{{FbaseCell: 1}, {FbaseCell: 7}, {FbaseCell: 21}}, // j 1
			{{FbaseCell: 6, FccwRot60: 1}, {FbaseCell: 9}, {FbaseCell: 19}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 2}, {FbaseCell: 12, FccwRot60: 5}, {FbaseCell: 26, FccwRot60: 5}}, // j 0
			{{FccwRot60: 1}, {FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}}, // j 1
			{{FbaseCell: 2, FccwRot60: 1}, {FbaseCell: 1}, {FbaseCell: 7}}}},
	{
		{ // face 3
			{
				{FbaseCell: 26}, {FbaseCell: 42}, {FbaseCell: 58}}, // j 0
			{{FbaseCell: 29}, {FbaseCell: 43}, {FbaseCell: 62, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 1}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}, {FbaseCell: 44, FccwRot60: 5}}, // j 0
			{{FbaseCell: 13}, {FbaseCell: 26}, {FbaseCell: 42}}, // j 1
			{{FbaseCell: 21, FccwRot60: 1}, {FbaseCell: 29}, {FbaseCell: 43}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 3}, {FbaseCell: 15, FccwRot60: 5}, {FbaseCell: 31, FccwRot60: 5}}, // j 0
			{{FbaseCell: 3, FccwRot60: 1}, {FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}}, // j 1
			{{FbaseCell: 7, FccwRot60: 1}, {FbaseCell: 13}, {FbaseCell: 26}}}},
	{
		{ // face 4
			{
				{FbaseCell: 31}, {FbaseCell: 41}, {FbaseCell: 49}}, // j 0
			{{FbaseCell: 44}, {FbaseCell: 53}, {FbaseCell: 61, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 1}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}, {FbaseCell: 33, FccwRot60: 5}}, // j 0
			{{FbaseCell: 28}, {FbaseCell: 31}, {FbaseCell: 41}}, // j 1
			{{FbaseCell: 42, FccwRot60: 1}, {FbaseCell: 44}, {FbaseCell: 53}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 4}, {FbaseCell: 8, FccwRot60: 5}, {FbaseCell: 16, FccwRot60: 5}}, // j 0
			{{FbaseCell: 12, FccwRot60: 1}, {FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}}, // j 1
			{{FbaseCell: 26, FccwRot60: 1}, {FbaseCell: 28}, {FbaseCell: 31}}}},
	{
		{ // face 5
			{
				{FbaseCell: 50}, {FbaseCell: 48}, {FbaseCell: 49, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}, {FbaseCell: 33, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 3}, {FbaseCell: 18, FccwRot60: 3}, {FbaseCell: 16, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 70}, {FbaseCell: 67}, {FbaseCell: 66, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}, {FbaseCell: 48}}, // j 1
			{{FbaseCell: 37, FccwRot60: 3}, {FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 83}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74, FccwRot60: 3}, {FbaseCell: 70}, {FbaseCell: 67}}, // j 1
			{{FbaseCell: 57, FccwRot60: 1}, {FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}}}},
	{
		{ // face 6
			{
				{FbaseCell: 25}, {FbaseCell: 23}, {FbaseCell: 24, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}, {FbaseCell: 10, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 3}, {FbaseCell: 6, FccwRot60: 3}, {FbaseCell: 2, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 45}, {FbaseCell: 39}, {FbaseCell: 37, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}, {FbaseCell: 23}}, // j 1
			{{FbaseCell: 27, FccwRot60: 3}, {FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 63}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56, FccwRot60: 3}, {FbaseCell: 45}, {FbaseCell: 39}}, // j 1
			{{FbaseCell: 46, FccwRot60: 3}, {FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}}}},
	{
		{ // face 7
			{
				{FbaseCell: 36}, {FbaseCell: 20}, {FbaseCell: 14, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}, {FbaseCell: 9, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 3}, {FbaseCell: 21, FccwRot60: 3}, {FbaseCell: 7, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 55}, {FbaseCell: 40}, {FbaseCell: 27, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}, {FbaseCell: 20}}, // j 1
			{{FbaseCell: 51, FccwRot60: 3}, {FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 72}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73, FccwRot60: 3}, {FbaseCell: 55}, {FbaseCell: 40}}, // j 1
			{{FbaseCell: 71, FccwRot60: 3}, {FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}}}},
	{
		{ // face 8
			{
				{FbaseCell: 64}, {FbaseCell: 47}, {FbaseCell: 38, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}, {FbaseCell: 29, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 3}, {FbaseCell: 42, FccwRot60: 3}, {FbaseCell: 26, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 84}, {FbaseCell: 69}, {FbaseCell: 51, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}, {FbaseCell: 47}}, // j 1
			{{FbaseCell: 76, FccwRot60: 3}, {FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 97}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98, FccwRot60: 3}, {FbaseCell: 84}, {FbaseCell: 69}}, // j 1
			{{FbaseCell: 96, FccwRot60: 3}, {FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}}}},
	{
		{ // face 9
			{
				{FbaseCell: 75}, {FbaseCell: 65}, {FbaseCell: 58, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}, {FbaseCell: 44, FccwRot60: 3}}, // j 1
			{{FbaseCell: 49, FccwRot60: 3}, {FbaseCell: 41, FccwRot60: 3}, {FbaseCell: 31, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 94}, {FbaseCell: 86}, {FbaseCell: 76, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}, {FbaseCell: 65}}, // j 1
			{{FbaseCell: 66, FccwRot60: 3}, {FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 107}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101, FccwRot60: 3}, {FbaseCell: 94}, {FbaseCell: 86}}, // j 1
			{{FbaseCell: 85, FccwRot60: 3}, {FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}}}},
	{
		{ // face 10
			{
				{FbaseCell: 57}, {FbaseCell: 59}, {FbaseCell: 63, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}, {FbaseCell: 79, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 3}, {FbaseCell: 92, FccwRot60: 3}, {FbaseCell: 95, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}, {FbaseCell: 45, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52}, {FbaseCell: 57}, {FbaseCell: 59}}, // j 1
			{{FbaseCell: 70, FccwRot60: 3}, {FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 24}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32, FccwRot60: 3}, {FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}}, // j 1
			{{FbaseCell: 50, FccwRot60: 3}, {FbaseCell: 52}, {FbaseCell: 57}}}},
	{
		{ // face 11
			{
				{FbaseCell: 46}, {FbaseCell: 60}, {FbaseCell: 72, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}, {FbaseCell: 80, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 3}, {FbaseCell: 77, FccwRot60: 3}, {FbaseCell: 90, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}, {FbaseCell: 55, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35}, {FbaseCell: 46}, {FbaseCell: 60}}, // j 1
			{{FbaseCell: 45, FccwRot60: 3}, {FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 14}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17, FccwRot60: 3}, {FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}}, // j 1
			{{FbaseCell: 25, FccwRot60: 3}, {FbaseCell: 35}, {FbaseCell: 46}}}},
	{
		{ // face 12
			{
				{FbaseCell: 71}, {FbaseCell: 89}, {FbaseCell: 97, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}, {FbaseCell: 103, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 3}, {FbaseCell: 88, FccwRot60: 3}, {FbaseCell: 105, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}, {FbaseCell: 84, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54}, {FbaseCell: 71}, {FbaseCell: 89}}, // j 1
			{{FbaseCell: 55, FccwRot60: 3}, {FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 38}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34, FccwRot60: 3}, {FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}}, // j 1
			{{FbaseCell: 36, FccwRot60: 3}, {FbaseCell: 54}, {FbaseCell: 71}}}},
	{
		{ // face 13
			{
				{FbaseCell: 96}, {FbaseCell: 104}, {FbaseCell: 107, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}, {FbaseCell: 115, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 3}, {FbaseCell: 111, FccwRot60: 3}, {FbaseCell: 119, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}, {FbaseCell: 94, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82}, {FbaseCell: 96}, {FbaseCell: 104}}, // j 1
			{{FbaseCell: 84, FccwRot60: 3}, {FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 58}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62, FccwRot60: 3}, {FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}}, // j 1
			{{FbaseCell: 64, FccwRot60: 3}, {FbaseCell: 82}, {FbaseCell: 96}}}},
	{
		{ // face 14
			{
				{FbaseCell: 85}, {FbaseCell: 87}, {FbaseCell: 83, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}, {FbaseCell: 100, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 3}, {FbaseCell: 112, FccwRot60: 3}, {FbaseCell: 114, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}, {FbaseCell: 70, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81}, {FbaseCell: 85}, {FbaseCell: 87}}, // j 1
			{{FbaseCell: 94, FccwRot60: 3}, {FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 49}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61, FccwRot60: 3}, {FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}}, // j 1
			{{FbaseCell: 75, FccwRot60: 3}, {FbaseCell: 81}, {FbaseCell: 85}}}},
	{
		{ // face 15
			{
				{FbaseCell: 95}, {FbaseCell: 92}, {FbaseCell: 83}}, // j 0
			{{FbaseCell: 79}, {FbaseCell: 78}, {FbaseCell: 74, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 1}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 109}, {FbaseCell: 108}, {FbaseCell: 100, FccwRot60: 5}}, // j 0
			{{FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}, {FbaseCell: 92}}, // j 1
			{{FbaseCell: 77, FccwRot60: 1}, {FbaseCell: 79}, {FbaseCell: 78}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 4}, {FbaseCell: 118, FccwRot60: 5}, {FbaseCell: 114, FccwRot60: 5}}, // j 0
			{{FbaseCell: 106, FccwRot60: 1}, {FbaseCell: 109}, {FbaseCell: 108}}, // j 1
			{{FbaseCell: 90, FccwRot60: 1}, {FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}}}},
	{
		{ // face 16
			{
				{FbaseCell: 90}, {FbaseCell: 77}, {FbaseCell: 63}}, // j 0
			{{FbaseCell: 80}, {FbaseCell: 68}, {FbaseCell: 56, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 1}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 106}, {FbaseCell: 93}, {FbaseCell: 79, FccwRot60: 5}}, // j 0
			{{FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}, {FbaseCell: 77}}, // j 1
			{{FbaseCell: 88, FccwRot60: 1}, {FbaseCell: 80}, {FbaseCell: 68}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 3}, {FbaseCell: 109, FccwRot60: 5}, {FbaseCell: 95, FccwRot60: 5}}, // j 0
			{{FbaseCell: 113, FccwRot60: 1}, {FbaseCell: 106}, {FbaseCell: 93}}, // j 1
			{{FbaseCell: 105, FccwRot60: 1}, {FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}}}},
	{
		{ // face 17
			{
				{FbaseCell: 105}, {FbaseCell: 88}, {FbaseCell: 72}}, // j 0
			{{FbaseCell: 103}, {FbaseCell: 91}, {FbaseCell: 73, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 1}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 113}, {FbaseCell: 99}, {FbaseCell: 80, FccwRot60: 5}}, // j 0
			{{FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}, {FbaseCell: 88}}, // j 1
			{{FbaseCell: 111, FccwRot60: 1}, {FbaseCell: 103}, {FbaseCell: 91}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 2}, {FbaseCell: 106, FccwRot60: 5}, {FbaseCell: 90, FccwRot60: 5}}, // j 0
			{{FbaseCell: 121, FccwRot60: 1}, {FbaseCell: 113}, {FbaseCell: 99}}, // j 1
			{{FbaseCell: 119, FccwRot60: 1}, {FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}}}},
	{
		{ // face 18
			{
				{FbaseCell: 119}, {FbaseCell: 111}, {FbaseCell: 97}}, // j 0
			{{FbaseCell: 115}, {FbaseCell: 110}, {FbaseCell: 98, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 1}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 121}, {FbaseCell: 116}, {FbaseCell: 103, FccwRot60: 5}}, // j 0
			{{FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}, {FbaseCell: 111}}, // j 1
			{{FbaseCell: 112, FccwRot60: 1}, {FbaseCell: 115}, {FbaseCell: 110}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 1}, {FbaseCell: 113, FccwRot60: 5}, {FbaseCell: 105, FccwRot60: 5}}, // j 0
			{{FbaseCell: 118, FccwRot60: 1}, {FbaseCell: 121}, {FbaseCell: 116}}, // j 1
			{{FbaseCell: 114, FccwRot60: 1}, {FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}}}},
	{
		{ // face 19
			{
				{FbaseCell: 114}, {FbaseCell: 112}, {FbaseCell: 107}}, // j 0
			{{FbaseCell: 100}, {FbaseCell: 102}, {FbaseCell: 101, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 1}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 118}, {FbaseCell: 120}, {FbaseCell: 115, FccwRot60: 5}}, // j 0
			{{FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}, {FbaseCell: 112}}, // j 1
			{{FbaseCell: 92, FccwRot60: 1}, {FbaseCell: 100}, {FbaseCell: 102}}},
		{
			{
				// i 2
				{FbaseCell: 117}, {FbaseCell: 121, FccwRot60: 5}, {FbaseCell: 119, FccwRot60: 5}}, // j 0
			{{FbaseCell: 109, FccwRot60: 1}, {FbaseCell: 118}, {FbaseCell: 120}},                // j 1
			{{FbaseCell: 95, FccwRot60: 1}, {FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}}}}} /* baseCells.c:308:31 */

// * @brief Resolution 0 base cell data table.
//
// For each base cell, gives the "home" face and ijk+ coordinates on that face,
// whether or not the base cell is a pentagon. Additionally, if the base cell
// is a pentagon, the two cw offset rotation adjacent faces are given (-1
// indicates that no cw offset rotation faces exist for this base cell).
var XbaseCellData = [122]TBaseCellData{{

	FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1}}}, // base cell 0
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 1
	{FhomeFijk: TFaceIJK{Fface: 1}},                                                                           // base cell 2
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 3
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}},          // base cell 4
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 5
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fk: 1}}},                                                 // base cell 6
	{FhomeFijk: TFaceIJK{Fface: 2}},                                                                           // base cell 7
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1}}},                                                           // base cell 8
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 9
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 10
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                          // base cell 11
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 12
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 13
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{2, 6}}, // base cell 14
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 15
	{}, // base cell 16
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 17
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fk: 1}}},                                                             // base cell 18
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 19
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 20
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 21
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                                      // base cell 22
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 23
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{1, 5}},   // base cell 24
	{FhomeFijk: TFaceIJK{Fface: 6}},                                                                             // base cell 25
	{FhomeFijk: TFaceIJK{Fface: 3}},                                                                             // base cell 26
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 27
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                            // base cell 28
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 29
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                                      // base cell 30
	{FhomeFijk: TFaceIJK{Fface: 4}},                                                                             // base cell 31
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 32
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1}}},                                                             // base cell 33
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 34
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 35
	{FhomeFijk: TFaceIJK{Fface: 7}},                                                                             // base cell 36
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 37
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{3, 7}},   // base cell 38
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 39
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 40
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 41
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 42
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 43
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 44
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 45
	{FhomeFijk: TFaceIJK{Fface: 11}},                                                                            // base cell 46
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 47
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 48
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{0, 9}},   // base cell 49
	{FhomeFijk: TFaceIJK{Fface: 5}},                                                                             // base cell 50
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 51
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 52
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 53
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 54
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 55
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 56
	{FhomeFijk: TFaceIJK{Fface: 10}},                                                                            // base cell 57
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{4, 8}},   // base cell 58
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 59
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 60
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 61
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 62
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{11, 15}},  // base cell 63
	{FhomeFijk: TFaceIJK{Fface: 8}},                                                                             // base cell 64
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 65
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 66
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 67
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 68
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 69
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 70
	{FhomeFijk: TFaceIJK{Fface: 12}},                                                                            // base cell 71
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{12, 16}},  // base cell 72
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 73
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 74
	{FhomeFijk: TFaceIJK{Fface: 9}},                                                                             // base cell 75
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 76
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 77
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 78
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 79
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 80
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 81
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 82
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{10, 19}},  // base cell 83
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 84
	{FhomeFijk: TFaceIJK{Fface: 14}},                                                                            // base cell 85
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 86
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 87
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 88
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 89
	{FhomeFijk: TFaceIJK{Fface: 16}},                                                                            // base cell 90
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 91
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 92
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 93
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 94
	{FhomeFijk: TFaceIJK{Fface: 15}},                                                                            // base cell 95
	{FhomeFijk: TFaceIJK{Fface: 13}},                                                                            // base cell 96
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{13, 17}},  // base cell 97
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 98
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 99
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 100
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 101
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 102
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 103
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 104
	{FhomeFijk: TFaceIJK{Fface: 17}},                                                                            // base cell 105
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 106
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{14, 18}},  // base cell 107
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 108
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 109
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 110
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 111
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 112
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 113
	{FhomeFijk: TFaceIJK{Fface: 19}},                                                                            // base cell 114
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 115
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 116
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}}, // base cell 117
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 118
	{FhomeFijk: TFaceIJK{Fface: 18}},                                                                            // base cell 119
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 120
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1}}}}                                                  /* baseCells.c:697:20 */

//* @brief Return whether or not the indicated base cell is a pentagon.
func X_isBaseCellPentagon(tls *libc.TLS, baseCell int32) int32 { /* baseCells.c:824:5: */
	return XbaseCellData[baseCell].FisPentagon
}

// * @brief Return whether the indicated base cell is a pentagon where all
// neighbors are oriented towards it.
func X_isBaseCellPolarPentagon(tls *libc.TLS, baseCell int32) uint8 { /* baseCells.c:830:6: */
	return uint8(libc.Bool32(baseCell == 4 || baseCell == 117))
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the base cell located at that
// coordinate.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCell(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:842:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FbaseCell
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the number of 60' ccw rotations
// to rotate into the coordinate system of the base cell at that coordinates.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCellCCWrot60(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:855:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FccwRot60
}

// * @brief Find the FaceIJK given a base cell.
func X_baseCellToFaceIjk(tls *libc.TLS, baseCell int32, h uintptr) { /* baseCells.c:862:6: */
	*(*TFaceIJK)(unsafe.Pointer(h)) = XbaseCellData[baseCell].FhomeFijk
}

// *
// @brief Given a base cell and the face it appears on, return
//        the number of 60' ccw rotations for that base cell's
//        coordinate system.
// @returns The number of rotations, or INVALID_ROTATIONS if the base
//          cell is not found on the given face
func X_baseCellToCCWrot60(tls *libc.TLS, baseCell int32, face int32) int32 { /* baseCells.c:873:5: */
	if face < 0 || face > DNUM_ICOSA_FACES {
		return -1
	}
	{
		var i int32 = 0
	__1:
		if !(i < 3) {
			goto __3
		}
		{
			{
				var j int32 = 0
			__4:
				if !(j < 3) {
					goto __6
				}
				{
					{
						var k int32 = 0
					__7:
						if !(k < 3) {
							goto __9
						}
						{
							if (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells))+uintptr(face)*216+uintptr(i)*72+uintptr(j)*24+uintptr(k)*8)).FbaseCell == baseCell {
								return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr(face)*216 + uintptr(i)*72 + uintptr(j)*24 + uintptr(k)*8)).FccwRot60
							}

						}
						goto __8
					__8:
						k++
						goto __7
						goto __9
					__9:
					}

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return -1
}

// * @brief Return whether or not the tested face is a cw offset face.
func X_baseCellIsCwOffset(tls *libc.TLS, baseCell int32, testFace int32) uint8 { /* baseCells.c:889:6: */
	return uint8(libc.Bool32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20)) == testFace || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20 + 1*4)) == testFace))
}

// * @brief Return the neighboring base cell in the given direction.
func X_getBaseCellNeighbor(tls *libc.TLS, baseCell int32, dir TDirection) int32 { /* baseCells.c:896:5: */
	return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(baseCell)*28 + uintptr(dir)*4))
}

// * @brief Return the direction from the origin base cell to the neighbor.
// Returns INVALID_DIGIT if the base cells are not neighbors.
func X_getBaseCellDirection(tls *libc.TLS, originBaseCell int32, neighboringBaseCell int32) TDirection { /* baseCells.c:903:11: */
	{
		var dir TDirection = CENTER_DIGIT
	__1:
		if !(dir < NUM_DIGITS) {
			goto __3
		}
		{
			var testBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
			if testBaseCell == neighboringBaseCell {
				return dir
			}

		}
		goto __2
	__2:
		dir++
		goto __1
		goto __3
	__3:
	}
	return INVALID_DIGIT
}

// *
// res0IndexCount returns the number of resolution 0 indexes
//
// @return int count of resolution 0 indexes
func Xres0IndexCount(tls *libc.TLS) int32 { /* baseCells.c:918:5: */
	return DNUM_BASE_CELLS
}

// *
// getRes0Indexes generates all base cells storing them into the provided
// memory pointer. Buffer must be of size NUM_BASE_CELLS * sizeof(H3Index).
//
// @param out H3Index* the memory to store the resulting base cells in
func XgetRes0Indexes(tls *libc.TLS, out uintptr) { /* baseCells.c:926:6: */
	{
		var bc int32 = 0
	__1:
		if !(bc < DNUM_BASE_CELLS) {
			goto __3
		}
		{
			var baseCell TH3Index = 35184372088831
			baseCell = baseCell&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_HEXAGON_MODE))<<DH3_MODE_OFFSET
			baseCell = baseCell&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(bc)<<DH3_BC_OFFSET
			*(*TH3Index)(unsafe.Pointer(out + uintptr(bc)*8)) = baseCell

		}
		goto __2
	__2:
		bc++
		goto __1
		goto __3
	__3:
	}
}

// *
// Whether the given bounding box crosses the antimeridian
// @param  bbox Bounding box to inspect
// @return      is transmeridian
func XbboxIsTransmeridian(tls *libc.TLS, bbox uintptr) uint8 { /* bbox.c:35:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(bbox)).Feast < (*TBBox)(unsafe.Pointer(bbox)).Fwest))
}

// *
// Get the center of a bounding box
// @param bbox   Input bounding box
// @param center Output center coordinate
func XbboxCenter(tls *libc.TLS, bbox uintptr, center uintptr) { /* bbox.c:42:6: */
	(*TGeoCoord)(unsafe.Pointer(center)).Flat = ((*TBBox)(unsafe.Pointer(bbox)).Fnorth + (*TBBox)(unsafe.Pointer(bbox)).Fsouth) / 2.0
	// If the bbox crosses the antimeridian, shift east 360 degrees
	var east float64
	if XbboxIsTransmeridian(tls, bbox) != 0 {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast + 6.28318530717958647692528676655900576839433
	} else {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast
	}
	(*TGeoCoord)(unsafe.Pointer(center)).Flon = XconstrainLng(tls, (east+(*TBBox)(unsafe.Pointer(bbox)).Fwest)/2.0)
}

// *
// Whether the bounding box contains a given point
// @param  bbox  Bounding box
// @param  point Point to test
// @return       Whether the point is contained
func XbboxContains(tls *libc.TLS, bbox uintptr, point uintptr) uint8 { /* bbox.c:55:6: */
	return uint8(libc.Bool32((*TGeoCoord)(unsafe.Pointer(point)).Flat >= (*TBBox)(unsafe.Pointer(bbox)).Fsouth && (*TGeoCoord)(unsafe.Pointer(point)).Flat <= (*TBBox)(unsafe.Pointer(bbox)).Fnorth && func() int32 {
		if XbboxIsTransmeridian(tls, bbox) != 0 {
			return libc.Bool32((*TGeoCoord)(unsafe.Pointer(point)).Flon >= (*TBBox)(unsafe.Pointer(bbox)).Fwest || (*TGeoCoord)(unsafe.Pointer(point)).Flon <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
		}
		return libc.Bool32((*TGeoCoord)(unsafe.Pointer(point)).Flon >= (*TBBox)(unsafe.Pointer(bbox)).Fwest && (*TGeoCoord)(unsafe.Pointer(point)).Flon <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
	}() != 0))
}

// *
// Whether two bounding boxes are strictly equal
// @param  b1 Bounding box 1
// @param  b2 Bounding box 2
// @return    Whether the boxes are equal
func XbboxEquals(tls *libc.TLS, b1 uintptr, b2 uintptr) uint8 { /* bbox.c:71:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(b1)).Fnorth == (*TBBox)(unsafe.Pointer(b2)).Fnorth && (*TBBox)(unsafe.Pointer(b1)).Fsouth == (*TBBox)(unsafe.Pointer(b2)).Fsouth && (*TBBox)(unsafe.Pointer(b1)).Feast == (*TBBox)(unsafe.Pointer(b2)).Feast && (*TBBox)(unsafe.Pointer(b1)).Fwest == (*TBBox)(unsafe.Pointer(b2)).Fwest))
}

// *
// _hexRadiusKm returns the radius of a given hexagon in Km
//
// @param h3Index the index of the hexagon
// @return the radius of the hexagon in Km
func X_hexRadiusKm(tls *libc.TLS, h3Index TH3Index) float64 { /* bbox.c:82:8: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// There is probably a cheaper way to determine the radius of a
	// hexagon, but this way is conceptually simple
	// var h3Center TGeoCoord at bp, 16

	// var h3Boundary TGeoBoundary at bp+16, 168

	Xh3ToGeo(tls, h3Index, bp)
	Xh3ToGeoBoundary(tls, h3Index, bp+16)
	return XpointDistKm(tls, bp, bp+16+8)
}

// *
// bboxHexEstimate returns an estimated number of hexagons that fit
//                 within the cartesian-projected bounding box
//
// @param bbox the bounding box to estimate the hexagon fill level
// @param res the resolution of the H3 hexagons to fill the bounding box
// @return the estimated number of hexagons to fill the bounding box
func XbboxHexEstimate(tls *libc.TLS, bbox uintptr, res int32) int32 { /* bbox.c:100:5: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]TH3Index)(unsafe.Pointer(bp /* pentagons */)) = [12]TH3Index{0: uint64(0)}
	XgetPentagonIndexes(tls, res, bp)
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*TH3Index)(unsafe.Pointer(bp)))
	// Area of a regular hexagon is 3/2*sqrt(3) * r * r
	// The pentagon has the most distortion (smallest edges) and shares its
	// edges with hexagons, so the most-distorted hexagons have this area,
	// shrunk by 20% off chance that the bounding box perfectly bounds a
	// pentagon.
	var pentagonAreaKm2 float64 = 0.8 * (2.59807621135 * pentagonRadiusKm * pentagonRadiusKm)

	// Then get the area of the bounding box of the geofence in question
	// var p1 TGeoCoord at bp+96, 16

	// var p2 TGeoCoord at bp+112, 16

	(*TGeoCoord)(unsafe.Pointer(bp + 96 /* &p1 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fnorth
	(*TGeoCoord)(unsafe.Pointer(bp + 96 /* &p1 */)).Flon = (*TBBox)(unsafe.Pointer(bbox)).Feast
	(*TGeoCoord)(unsafe.Pointer(bp + 112 /* &p2 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fsouth
	(*TGeoCoord)(unsafe.Pointer(bp + 112 /* &p2 */)).Flon = (*TBBox)(unsafe.Pointer(bbox)).Fwest
	var d float64 = XpointDistKm(tls, bp+96, bp+112)
	// Derived constant based on: https://math.stackexchange.com/a/1921940
	// Clamped to 3 as higher values tend to rapidly drag the estimate to zero.
	var a float64 = d * d / Xfmin(tls, 3.0, libc.Xfabs(tls, ((*TGeoCoord)(unsafe.Pointer(bp+96)).Flon-(*TGeoCoord)(unsafe.Pointer(bp+112)).Flon)/((*TGeoCoord)(unsafe.Pointer(bp+96)).Flat-(*TGeoCoord)(unsafe.Pointer(bp+112)).Flat)))

	// Divide the two to get an estimate of the number of hexagons needed
	var estimate int32 = libc.Int32FromFloat64(libc.Xceil(tls, a/pentagonAreaKm2))
	if estimate == 0 {
		estimate = 1
	}
	return estimate
}

// *
// lineHexEstimate returns an estimated number of hexagons that trace
//                 the cartesian-projected line
//
//  @param origin the origin coordinates
//  @param destination the destination coordinates
//  @param res the resolution of the H3 hexagons to trace the line
//  @return the estimated number of hexagons required to trace the line
func XlineHexEstimate(tls *libc.TLS, origin uintptr, destination uintptr, res int32) int32 { /* bbox.c:139:5: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]TH3Index)(unsafe.Pointer(bp /* pentagons */)) = [12]TH3Index{0: uint64(0)}
	XgetPentagonIndexes(tls, res, bp)
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*TH3Index)(unsafe.Pointer(bp)))

	var dist float64 = XpointDistKm(tls, origin, destination)
	var estimate int32 = libc.Int32FromFloat64(libc.Xceil(tls, dist/(float64(2)*pentagonRadiusKm)))
	if estimate == 0 {
		estimate = 1
	}
	return estimate
}

// * @brief CoordIJK unit vectors corresponding to the 7 H3 digits.
var sUNIT_VECS3 = [7]TCoordIJK{
	{},             // direction 0
	{Fk: 1},        // direction 1
	{Fj: 1},        // direction 2
	{Fj: 1, Fk: 1}, // direction 3
	{Fi: 1},        // direction 4
	{Fi: 1, Fk: 1}, // direction 5
	{Fi: 1, Fj: 1}, // direction 6
} /* coordijk.h:50:23 */

// *
// Sets an IJK coordinate to the specified component values.
//
// @param ijk The IJK coordinate to set.
// @param i The desired i component value.
// @param j The desired j component value.
// @param k The desired k component value.
func X_setIJK(tls *libc.TLS, ijk uintptr, i int32, j int32, k int32) { /* coordijk.c:40:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = i
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = j
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = k
}

// *
// Determine the containing hex in ijk+ coordinates for a 2D cartesian
// coordinate vector (from DGGRID).
//
// @param v The 2D cartesian coordinate vector.
// @param h The ijk+ coordinates of the containing hex.
func X_hex2dToCoordIJK(tls *libc.TLS, v uintptr, h uintptr) { /* coordijk.c:53:6: */
	var a1 float64
	var a2 float64
	var x1 float64
	var x2 float64
	var m1 int32
	var m2 int32
	var r1 float64
	var r2 float64

	// quantize into the ij system and then normalize
	(*TCoordIJK)(unsafe.Pointer(h)).Fk = 0

	a1 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fx)
	a2 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fy)

	// first do a reverse conversion
	x2 = a2 / 0.8660254037844386467637231707529361834714
	x1 = a1 + x2/2.0

	// check if we have the center of a hex
	m1 = int32(x1)
	m2 = int32(x2)

	// otherwise round correctly
	r1 = x1 - float64(m1)
	r2 = x2 - float64(m2)

	if r1 < 0.5 {
		if r1 < float64(1.0)/3.0 {
			if r2 < (1.0+r1)/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		} else {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 1.0-r1 <= r2 && r2 < 2.0*r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			}
		}
	} else {
		if r1 < float64(2.0)/3.0 {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 2.0*r1-1.0 < r2 && r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			}
		} else {
			if r2 < r1/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		}
	}

	// now fold across the axes if necessary

	if (*TVec2d)(unsafe.Pointer(v)).Fx < 0.0 {
		if (*TCoordIJK)(unsafe.Pointer(h)).Fj%2 == 0 {
			var axisi int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fj / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - 2.0*float64(diff))
		} else {
			var axisi int64 = int64(((*TCoordIJK)(unsafe.Pointer(h)).Fj + 1) / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - (2.0*float64(diff) + float64(1)))
		}
	}

	if (*TVec2d)(unsafe.Pointer(v)).Fy < 0.0 {
		(*TCoordIJK)(unsafe.Pointer(h)).Fi = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (2*(*TCoordIJK)(unsafe.Pointer(h)).Fj+1)/2
		(*TCoordIJK)(unsafe.Pointer(h)).Fj = -1 * (*TCoordIJK)(unsafe.Pointer(h)).Fj
	}

	X_ijkNormalize(tls, h)
}

// *
// Find the center point in 2D cartesian coordinates of a hex.
//
// @param h The ijk coordinates of the hex.
// @param v The 2D cartesian coordinates of the hex center point.
func X_ijkToHex2d(tls *libc.TLS, h uintptr, v uintptr) { /* coordijk.c:152:6: */
	var i int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (*TCoordIJK)(unsafe.Pointer(h)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fj - (*TCoordIJK)(unsafe.Pointer(h)).Fk

	(*TVec2d)(unsafe.Pointer(v)).Fx = float64(i) - 0.5*float64(j)
	(*TVec2d)(unsafe.Pointer(v)).Fy = float64(j) * 0.8660254037844386467637231707529361834714
}

// *
// Returns whether or not two ijk coordinates contain exactly the same
// component values.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
// @return 1 if the two addresses match, 0 if they do not.
func X_ijkMatches(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:168:5: */
	return libc.Bool32((*TCoordIJK)(unsafe.Pointer(c1)).Fi == (*TCoordIJK)(unsafe.Pointer(c2)).Fi && (*TCoordIJK)(unsafe.Pointer(c1)).Fj == (*TCoordIJK)(unsafe.Pointer(c2)).Fj && (*TCoordIJK)(unsafe.Pointer(c1)).Fk == (*TCoordIJK)(unsafe.Pointer(c2)).Fk)
}

// *
// Add two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param sum The sum of the two sets of ijk coordinates.
func X_ijkAdd(tls *libc.TLS, h1 uintptr, h2 uintptr, sum uintptr) { /* coordijk.c:179:6: */
	(*TCoordIJK)(unsafe.Pointer(sum)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi + (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(sum)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj + (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(sum)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk + (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Subtract two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param diff The difference of the two sets of ijk coordinates (h1 - h2).
func X_ijkSub(tls *libc.TLS, h1 uintptr, h2 uintptr, diff uintptr) { /* coordijk.c:192:6: */
	(*TCoordIJK)(unsafe.Pointer(diff)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi - (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(diff)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj - (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(diff)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk - (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Uniformly scale ijk coordinates by a scalar. Works in place.
//
// @param c The ijk coordinates to scale.
// @param factor The scaling factor.
func X_ijkScale(tls *libc.TLS, c uintptr, factor int32) { /* coordijk.c:204:6: */
	*(*int32)(unsafe.Pointer(c)) *= factor
	*(*int32)(unsafe.Pointer(c + 4)) *= factor
	*(*int32)(unsafe.Pointer(c + 8)) *= factor
}

// *
// Normalizes ijk coordinates by setting the components to the smallest possible
// values. Works in place.
//
// @param c The ijk coordinates to normalize.
func X_ijkNormalize(tls *libc.TLS, c uintptr) { /* coordijk.c:216:6: */
	// remove any negative values
	if (*TCoordIJK)(unsafe.Pointer(c)).Fi < 0 {
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		(*TCoordIJK)(unsafe.Pointer(c)).Fi = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		(*TCoordIJK)(unsafe.Pointer(c)).Fj = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		(*TCoordIJK)(unsafe.Pointer(c)).Fk = 0
	}

	// remove the min value if needed
	var min int32 = (*TCoordIJK)(unsafe.Pointer(c)).Fi
	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fj
	}
	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fk
	}
	if min > 0 {
		*(*int32)(unsafe.Pointer(c)) -= min
		*(*int32)(unsafe.Pointer(c + 4)) -= min
		*(*int32)(unsafe.Pointer(c + 8)) -= min
	}
}

// *
// Determines the H3 digit corresponding to a unit vector in ijk coordinates.
//
// @param ijk The ijk coordinates; must be a unit vector.
// @return The H3 digit (0-6) corresponding to the ijk unit vector, or
// INVALID_DIGIT on failure.
func X_unitIjkToDigit(tls *libc.TLS, ijk uintptr) TDirection { /* coordijk.c:254:11: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*TCoordIJK)(unsafe.Pointer(bp /* c */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
	X_ijkNormalize(tls, bp)

	var digit TDirection = INVALID_DIGIT
	{
		var i TDirection = CENTER_DIGIT
	__1:
		if !(i < NUM_DIGITS) {
			goto __3
		}
		{
			if X_ijkMatches(tls, bp, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(i)*12) != 0 {
				digit = i
				goto __3
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	return digit
}

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// counter-clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:275:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(3*i-j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(i+2*j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:292:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlroundl(tls, float64(2*i+j)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlroundl(tls, float64(3*j-i)/7.0))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:310:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 3}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:332:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex in the specified digit
// direction from the specified ijk coordinates. Works in place.
//
// @param ijk The ijk coordinates.
// @param digit The digit direction from the original ijk coordinates.
func X_neighbor(tls *libc.TLS, ijk uintptr, digit TDirection) { /* coordijk.c:355:6: */
	if digit > CENTER_DIGIT && digit < NUM_DIGITS {
		X_ijkAdd(tls, ijk, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(digit)*12, ijk)
		X_ijkNormalize(tls, ijk)
	}
}

// *
// Rotates ijk coordinates 60 degrees counter-clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60ccw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:367:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates ijk coordinates 60 degrees clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60cw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:388:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates indexing digit 60 degrees counter-clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60ccw(tls *libc.TLS, digit TDirection) TDirection { /* coordijk.c:409:11: */
	switch digit {
	case K_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return TDirection(0)
}

// *
// Rotates indexing digit 60 degrees clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60cw(tls *libc.TLS, digit TDirection) TDirection { /* coordijk.c:433:11: */
	switch digit {
	case K_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return TDirection(0)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp3(tls *libc.TLS, ijk uintptr) { /* coordijk.c:459:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 2}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp3r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:481:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Finds the distance between the two coordinates. Returns result.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
func XijkDistance(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:503:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var diff TCoordIJK at bp, 12

	X_ijkSub(tls, c1, c2, bp)
	X_ijkNormalize(tls, bp)
	var absDiff = TCoordIJK{Fi: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fi), Fj: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fj), Fk: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fk)}
	return func() int32 {
		if absDiff.Fi > func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}() {
			return absDiff.Fi
		}
		return func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}()
	}()
}

// *
// Transforms coordinates from the IJK+ coordinate system to the IJ coordinate
// system.
//
// @param ijk The input IJK+ coordinates
// @param ij The output IJ coordinates
func XijkToIj(tls *libc.TLS, ijk uintptr, ij uintptr) { /* coordijk.c:518:6: */
	(*TCoordIJ)(unsafe.Pointer(ij)).Fi = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJ)(unsafe.Pointer(ij)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
}

// *
// Transforms coordinates from the IJ coordinate system to the IJK+ coordinate
// system.
//
// @param ij The input IJ coordinates
// @param ijk The output IJK+ coordinates
func XijToIjk(tls *libc.TLS, ij uintptr, ijk uintptr) { /* coordijk.c:530:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = (*TCoordIJ)(unsafe.Pointer(ij)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJ)(unsafe.Pointer(ij)).Fj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	X_ijkNormalize(tls, ijk)
}

// *
// Convert IJK coordinates to cube coordinates, in place
// @param ijk Coordinate to convert
func XijkToCube(tls *libc.TLS, ijk uintptr) { /* coordijk.c:542:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi + (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
}

// *
// Convert cube coordinates to IJK coordinates, in place
// @param ijk Coordinate to convert
func XcubeToIjk(tls *libc.TLS, ijk uintptr) { /* coordijk.c:552:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// Copyright 2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec3d.h
// @brief   3D floating point vector functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// * @struct Vec3D
//  @brief 3D floating point structure
type TVec3d = struct {
	Fx float64
	Fy float64
	Fz float64
} /* vec3d.h:32:3 */

//* square root of 7

//* @brief icosahedron face centers in lat/lon radians
var XfaceCenterGeo = [20]TGeoCoord{
	{Flat: 0.803582649718989942, Flon: 1.248397419617396099},   // face  0
	{Flat: 1.307747883455638156, Flon: 2.536945009877921159},   // face  1
	{Flat: 1.054751253523952054, Flon: -1.347517358900396623},  // face  2
	{Flat: 0.600191595538186799, Flon: -0.450603909469755746},  // face  3
	{Flat: 0.491715428198773866, Flon: 0.401988202911306943},   // face  4
	{Flat: 0.172745327415618701, Flon: 1.678146885280433686},   // face  5
	{Flat: 0.605929321571350690, Flon: 2.953923329812411617},   // face  6
	{Flat: 0.427370518328979641, Flon: -1.888876200336285401},  // face  7
	{Flat: -0.079066118549212831, Flon: -0.733429513380867741}, // face  8
	{Flat: -0.230961644455383637, Flon: 0.506495587332349035},  // face  9
	{Flat: 0.079066118549212831, Flon: 2.408163140208925497},   // face 10
	{Flat: 0.230961644455383637, Flon: -2.635097066257444203},  // face 11
	{Flat: -0.172745327415618701, Flon: -1.463445768309359553}, // face 12
	{Flat: -0.605929321571350690, Flon: -0.187669323777381622}, // face 13
	{Flat: -0.427370518328979641, Flon: 1.252716453253507838},  // face 14
	{Flat: -0.600191595538186799, Flon: 2.690988744120037492},  // face 15
	{Flat: -0.491715428198773866, Flon: -2.739604450678486295}, // face 16
	{Flat: -0.803582649718989942, Flon: -1.893195233972397139}, // face 17
	{Flat: -1.307747883455638156, Flon: -0.604647643711872080}, // face 18
	{Flat: -1.054751253523952054, Flon: 1.794075294689396615},  // face 19
} /* faceijk.c:39:16 */

//* @brief icosahedron face centers in x/y/z on the unit sphere
var faceCenterPoint = [20]TVec3d{
	{Fx: 0.2199307791404606, Fy: 0.6583691780274996, Fz: 0.7198475378926182},    // face  0
	{Fx: -0.2139234834501421, Fy: 0.1478171829550703, Fz: 0.9656017935214205},   // face  1
	{Fx: 0.1092625278784797, Fy: -0.4811951572873210, Fz: 0.8697775121287253},   // face  2
	{Fx: 0.7428567301586791, Fy: -0.3593941678278028, Fz: 0.5648005936517033},   // face  3
	{Fx: 0.8112534709140969, Fy: 0.3448953237639384, Fz: 0.4721387736413930},    // face  4
	{Fx: -0.1055498149613921, Fy: 0.9794457296411413, Fz: 0.1718874610009365},   // face  5
	{Fx: -0.8075407579970092, Fy: 0.1533552485898818, Fz: 0.5695261994882688},   // face  6
	{Fx: -0.2846148069787907, Fy: -0.8644080972654206, Fz: 0.4144792552473539},  // face  7
	{Fx: 0.7405621473854482, Fy: -0.6673299564565524, Fz: -0.0789837646326737},  // face  8
	{Fx: 0.8512303986474293, Fy: 0.4722343788582681, Fz: -0.2289137388687808},   // face  9
	{Fx: -0.7405621473854481, Fy: 0.6673299564565524, Fz: 0.0789837646326737},   // face 10
	{Fx: -0.8512303986474292, Fy: -0.4722343788582682, Fz: 0.2289137388687808},  // face 11
	{Fx: 0.1055498149613919, Fy: -0.9794457296411413, Fz: -0.1718874610009365},  // face 12
	{Fx: 0.8075407579970092, Fy: -0.1533552485898819, Fz: -0.5695261994882688},  // face 13
	{Fx: 0.2846148069787908, Fy: 0.8644080972654204, Fz: -0.4144792552473539},   // face 14
	{Fx: -0.7428567301586791, Fy: 0.3593941678278027, Fz: -0.5648005936517033},  // face 15
	{Fx: -0.8112534709140971, Fy: -0.3448953237639382, Fz: -0.4721387736413930}, // face 16
	{Fx: -0.2199307791404607, Fy: -0.6583691780274996, Fz: -0.7198475378926182}, // face 17
	{Fx: 0.2139234834501420, Fy: -0.1478171829550704, Fz: -0.9656017935214205},  // face 18
	{Fx: -0.1092625278784796, Fy: 0.4811951572873210, Fz: -0.8697775121287253},  // face 19
} /* faceijk.c:63:20 */

// * @brief icosahedron face ijk axes as azimuth in radians from face center to
// vertex 0/1/2 respectively
var faceAxesAzRadsCII = [20][3]float64{
	{5.619958268523939882, 3.525563166130744542,
		1.431168063737548730}, // face  0
	{5.760339081714187279, 3.665943979320991689,
		1.571548876927796127}, // face  1
	{0.780213654393430055, 4.969003859179821079,
		2.874608756786625655}, // face  2
	{0.430469363979999913, 4.619259568766391033,
		2.524864466373195467}, // face  3
	{6.130269123335111400, 4.035874020941915804,
		1.941478918548720291}, // face  4
	{2.692877706530642877, 0.598482604137447119,
		4.787272808923838195}, // face  5
	{2.982963003477243874, 0.888567901084048369,
		5.077358105870439581}, // face  6
	{3.532912002790141181, 1.438516900396945656,
		5.627307105183336758}, // face  7
	{3.494305004259568154, 1.399909901866372864,
		5.588700106652763840}, // face  8
	{3.003214169499538391, 0.908819067106342928,
		5.097609271892733906}, // face  9
	{5.930472956509811562, 3.836077854116615875,
		1.741682751723420374}, // face 10
	{0.138378484090254847, 4.327168688876645809,
		2.232773586483450311}, // face 11
	{0.448714947059150361, 4.637505151845541521,
		2.543110049452346120}, // face 12
	{0.158629650112549365, 4.347419854898940135,
		2.253024752505744869}, // face 13
	{5.891865957979238535, 3.797470855586042958,
		1.703075753192847583}, // face 14
	{2.711123289609793325, 0.616728187216597771,
		4.805518392002988683}, // face 15
	{3.294508837434268316, 1.200113735041072948,
		5.388903939827463911}, // face 16
	{3.804819692245439833, 1.710424589852244509,
		5.899214794638635174}, // face 17
	{3.664438879055192436, 1.570043776661997111,
		5.758833981448388027}, // face 18
	{2.361378999196363184, 0.266983896803167583,
		4.455774101589558636}, // face 19
} /* faceijk.c:89:21 */

//* @brief Definition of which faces neighbor each other.
var faceNeighbors = [20][4]TFaceOrientIJK{{
	{}, // central face
	{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
	{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
	{Fface: 5, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 1
		{Fface: 1}, // central face
		{Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},           // ij quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 2
		{Fface: 2}, // central face
		{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 3
		{Fface: 3}, // central face
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 4
		{Fface: 4}, // central face
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},           // ki quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 5
		{Fface: 5}, // central face
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 6
		{Fface: 6}, // central face
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 1, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 7
		{Fface: 7}, // central face
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 8
		{Fface: 8}, // central face
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 9
		{Fface: 9}, // central face
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 10
		{Fface: 10}, // central face
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 11
		{Fface: 11}, // central face
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 12
		{Fface: 12}, // central face
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 13
		{Fface: 13}, // central face
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 14
		{Fface: 14}, // central face
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 15
		{Fface: 15}, // central face
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 16
		{Fface: 16}, // central face
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 17
		{Fface: 17}, // central face
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 18
		{Fface: 18}, // central face
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 19
		{Fface: 19}, // central face
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},  // ij quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},  // ki quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}}} /* faceijk.c:133:28 */

// * @brief direction from the origin face to the destination face, relative to
// the origin face's coordinate system, or -1 if not adjacent.
var adjacentFaceDir = [20][20]int32{
	{0, DKI, -1, -1, DIJ, DJK, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 0
	{DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 1
	{-1, DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 2
	{-1, -1, DIJ, 0, DKI, -1, -1, -1, DJK, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 3
	{DKI, -1, -1, DIJ, 0, -1, -1, -1, -1, DJK,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 4
	{DJK, -1, -1, -1, -1, 0, -1, -1, -1, -1,
		DIJ, -1, -1, -1, DKI, -1, -1, -1, -1, -1}, // face 5
	{-1, DJK, -1, -1, -1, -1, 0, -1, -1, -1,
		DKI, DIJ, -1, -1, -1, -1, -1, -1, -1, -1}, // face 6
	{-1, -1, DJK, -1, -1, -1, -1, 0, -1, -1,
		-1, DKI, DIJ, -1, -1, -1, -1, -1, -1, -1}, // face 7
	{-1, -1, -1, DJK, -1, -1, -1, -1, 0, -1,
		-1, -1, DKI, DIJ, -1, -1, -1, -1, -1, -1}, // face 8
	{-1, -1, -1, -1, DJK, -1, -1, -1, -1, 0,
		-1, -1, -1, DKI, DIJ, -1, -1, -1, -1, -1}, // face 9
	{-1, -1, -1, -1, -1, DIJ, DKI, -1, -1, -1,
		0, -1, -1, -1, -1, DJK, -1, -1, -1, -1}, // face 10
	{-1, -1, -1, -1, -1, -1, DIJ, DKI, -1, -1,
		-1, 0, -1, -1, -1, -1, DJK, -1, -1, -1}, // face 11
	{-1, -1, -1, -1, -1, -1, -1, DIJ, DKI, -1,
		-1, -1, 0, -1, -1, -1, -1, DJK, -1, -1}, // face 12
	{-1, -1, -1, -1, -1, -1, -1, -1, DIJ, DKI,
		-1, -1, -1, 0, -1, -1, -1, -1, DJK, -1}, // face 13
	{-1, -1, -1, -1, -1, DKI, -1, -1, -1, DIJ,
		-1, -1, -1, -1, 0, -1, -1, -1, -1, DJK}, // face 14
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		DJK, -1, -1, -1, -1, 0, DIJ, -1, -1, DKI}, // face 15
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, DJK, -1, -1, -1, DKI, 0, DIJ, -1, -1}, // face 16
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, DJK, -1, -1, -1, DKI, 0, DIJ, -1}, // face 17
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, DJK, -1, -1, -1, DKI, 0, DIJ}, // face 18
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, DJK, DIJ, -1, -1, DKI, 0}, // face 19
} /* faceijk.c:278:18 */

//* @brief overage distance table
var maxDimByCIIres = [17]int32{
	2,        // res  0
	-1,       // res  1
	14,       // res  2
	-1,       // res  3
	98,       // res  4
	-1,       // res  5
	686,      // res  6
	-1,       // res  7
	4802,     // res  8
	-1,       // res  9
	33614,    // res 10
	-1,       // res 11
	235298,   // res 12
	-1,       // res 13
	1647086,  // res 14
	-1,       // res 15
	11529602, // res 16
} /* faceijk.c:322:18 */

//* @brief unit scale distance table
var unitScaleByCIIres = [17]int32{
	1,       // res  0
	-1,      // res  1
	7,       // res  2
	-1,      // res  3
	49,      // res  4
	-1,      // res  5
	343,     // res  6
	-1,      // res  7
	2401,    // res  8
	-1,      // res  9
	16807,   // res 10
	-1,      // res 11
	117649,  // res 12
	-1,      // res 13
	823543,  // res 14
	-1,      // res 15
	5764801, // res 16
} /* faceijk.c:343:18 */

// *
// Encodes a coordinate on the sphere to the FaceIJK address of the containing
// cell at the specified resolution.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param h The FaceIJK address of the containing cell at resolution res.
func X_geoToFaceIjk(tls *libc.TLS, g uintptr, res int32, h uintptr) { /* faceijk.c:371:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// first convert to hex2d
	// var v TVec2d at bp, 16

	X_geoToHex2d(tls, g, res, h, bp)

	// then convert to ijk+
	X_hex2dToCoordIJK(tls, bp, h+4)
}

// *
// Encodes a coordinate on the sphere to the corresponding icosahedral face and
// containing 2D hex coordinates relative to that face center.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param face The icosahedral face containing the spherical coordinates.
// @param v The 2D hex coordinates of the cell containing the point.
func X_geoToHex2d(tls *libc.TLS, g uintptr, res int32, face uintptr, v uintptr) { /* faceijk.c:389:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var v3d TVec3d at bp, 24

	X_geoToVec3d(tls, g, bp)

	// determine the icosahedron face
	*(*int32)(unsafe.Pointer(face)) = 0
	var sqd float64 = X_pointSquareDist(tls, uintptr(unsafe.Pointer(&faceCenterPoint)), bp)
	{
		var f int32 = 1
	__1:
		if !(f < DNUM_ICOSA_FACES) {
			goto __3
		}
		{
			var sqdT float64 = X_pointSquareDist(tls, uintptr(unsafe.Pointer(&faceCenterPoint))+uintptr(f)*24, bp)
			if sqdT < sqd {
				*(*int32)(unsafe.Pointer(face)) = f
				sqd = sqdT
			}

		}
		goto __2
	__2:
		f++
		goto __1
		goto __3
	__3:
	}

	// cos(r) = 1 - 2 * sin^2(r/2) = 1 - 2 * (sqd / 4) = 1 - sqd/2
	var r float64 = libc.Xacos(tls, float64(1)-sqd/float64(2))

	if r < 0.0000000000000001 {
		(*TVec2d)(unsafe.Pointer(v)).Fx = libc.AssignPtrFloat64(v+8, 0.0)
		return
	}

	// now have face and r, now find CCW theta from CII i-axis
	var theta float64 = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(*(*int32)(unsafe.Pointer(face)))*24))-X_posAngleRads(tls, X_geoAzimuthRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(*(*int32)(unsafe.Pointer(face)))*16, g)))

	// adjust theta for Class III (odd resolutions)
	if XisResClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta-0.333473172251832115336090755351601070065900389)
	}

	// perform gnomonic scaling of r
	r = libc.Xtan(tls, r)

	// scale for current resolution length u
	r = r / 0.38196601125010500003
	{
		var i int32 = 0
	__4:
		if !(i < res) {
			goto __6
		}
		r = r * 2.6457513110645905905016157536392604257102
		goto __5
	__5:
		i++
		goto __4
		goto __6
	__6:
	}

	// we now have (r, theta) in hex2d with theta ccw from x-axes

	// convert to local x,y
	(*TVec2d)(unsafe.Pointer(v)).Fx = r * libc.Xcos(tls, theta)
	(*TVec2d)(unsafe.Pointer(v)).Fy = r * libc.Xsin(tls, theta)
}

// *
// Determines the center point in spherical coordinates of a cell given by 2D
// hex coordinates on a particular icosahedral face.
//
// @param v The 2D hex coordinates of the cell.
// @param face The icosahedral face upon which the 2D hex coordinate system is
//             centered.
// @param res The H3 resolution of the cell.
// @param substrate Indicates whether or not this grid is actually a substrate
//        grid relative to the specified resolution.
// @param g The spherical coordinates of the cell center point.
func X_hex2dToGeo(tls *libc.TLS, v uintptr, face int32, res int32, substrate int32, g uintptr) { /* faceijk.c:446:6: */
	// calculate (r, theta) in hex2d
	var r float64 = X_v2dMag(tls, v)

	if r < 0.0000000000000001 {
		*(*TGeoCoord)(unsafe.Pointer(g)) = XfaceCenterGeo[face]
		return
	}

	var theta float64 = libc.Xatan2(tls, (*TVec2d)(unsafe.Pointer(v)).Fy, (*TVec2d)(unsafe.Pointer(v)).Fx)

	// scale for current resolution length u
	{
		var i int32 = 0
	__1:
		if !(i < res) {
			goto __3
		}
		r = r / 2.6457513110645905905016157536392604257102
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// scale accordingly if this is a substrate grid
	if substrate != 0 {
		r = r / 3.0
		if XisResClassIII(tls, res) != 0 {
			r = r / 2.6457513110645905905016157536392604257102
		}
	}

	r = r * 0.38196601125010500003

	// perform inverse gnomonic scaling of r
	r = libc.Xatan(tls, r)

	// adjust theta for Class III
	// if a substrate grid, then it's already been adjusted for Class III
	if !(substrate != 0) && XisResClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta+0.333473172251832115336090755351601070065900389)
	}

	// find theta as an azimuth
	theta = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(face)*24))-theta)

	// now find the point at (r,theta) from the face center
	X_geoAzDistanceRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(face)*16, theta, r, g)
}

// *
// Determines the center point in spherical coordinates of a cell given by
// a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param g The spherical coordinates of the cell center point.
func X_faceIjkToGeo(tls *libc.TLS, h uintptr, res int32, g uintptr) { /* faceijk.c:492:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var v TVec2d at bp, 16

	X_ijkToHex2d(tls, h+4, bp)
	X_hex2dToGeo(tls, bp, (*TFaceIJK)(unsafe.Pointer(h)).Fface, res, 0, g)
}

// *
// Generates the cell boundary in spherical coordinates for a pentagonal cell
// given by a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the pentagonal cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkPentToGeoBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:508:6: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [5]TFaceIJK at bp+20, 80

	X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_PENT_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lon
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	// var lastFijk TFaceIJK at bp+116, 16

	{
		var vert int32 = start
	__1:
		if !(vert < start+length+additionalIteration) {
			goto __3
		}
		{
			var v int32 = vert % DNUM_PENT_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			X_adjustPentVertOverage(tls, bp+100, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)))

			// all Class III pentagon edges cross icosa edges
			// note that Class II pentagons have vertices on the edge,
			// not edge intersections
			if XisResClassIII(tls, res) != 0 && vert > start {
				// find hex2d of the two vertexes on the last face

				*(*TFaceIJK)(unsafe.Pointer(bp + 152 /* tmpFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+116+4, bp+136)

				var currentToLastDir int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+116 /* &lastFijk */)).Fface)*4))

				var fijkOrient uintptr = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr(currentToLastDir)*20

				(*TFaceIJK)(unsafe.Pointer(bp + 152 /* &tmpFijk */)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface
				var ijk uintptr = bp + 152 + 4

				// rotate and translate for adjacent face
				{
					var i int32 = 0
				__4:
					if !(i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60) {
						goto __6
					}
					X_ijkRotate60ccw(tls, ijk)
					goto __5
				__5:
					i++
					goto __4
					goto __6
				__6:
				}

				*(*TCoordIJK)(unsafe.Pointer(bp + 168 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
				X_ijkScale(tls, bp+168, unitScaleByCIIres[*(*int32)(unsafe.Pointer(bp + 16))]*3)
				X_ijkAdd(tls, ijk, bp+168, ijk)
				X_ijkNormalize(tls, ijk)
				// var orig2d1 TVec2d at bp+184, 16

				X_ijkToHex2d(tls, ijk, bp+184)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 216 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 232 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface)*4)) {
				case DIJ:
					edge0 = bp + 200 /* &v0 */
					edge1 = bp + 216 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 216 /* &v1 */
					edge1 = bp + 232 /* &v2 */
					break
					fallthrough
				case DKI:
					fallthrough
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100)).Fface)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+58, ts+105, uint32(581), uintptr(unsafe.Pointer(&__func__1)))
					}
					edge0 = bp + 232 /* &v2 */
					edge1 = bp + 200 /* &v0 */
					break
				}

				// find the intersection and add the lat/lon point to the result
				// var inter TVec2d at bp+248, 16

				X_v2dIntersect(tls, bp+136, bp+184, edge0, edge1, bp+248)
				X_hex2dToGeo(tls, bp+248, (*TFaceIJK)(unsafe.Pointer(bp+152 /* &tmpFijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
					g+8+uintptr((*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			// convert vertex to lat/lon and add to the result
			// vert == start + NUM_PENT_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_PENT_VERTS {
				// var vec TVec2d at bp+264, 16

				X_ijkToHex2d(tls, bp+100+4, bp+264)
				X_hex2dToGeo(tls, bp+264, (*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* lastFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))

		}
		goto __2
	__2:
		vert++
		goto __1
		goto __3
	__3:
	}
}

var __func__1 = *(*[26]uint8)(unsafe.Pointer(ts + 132)) /* faceijk.c:509:48 */

// *
// Get the vertices of a pentagon cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//            necessary for the substrate grid resolution.
// @param fijkVerts Output array for the vertices
func X_faceIjkPentToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:617:6: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// the vertexes of an origin-centered pentagon in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp + 60 /* vertsCII */)) = [5]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
	}

	// the vertexes of an origin-centered pentagon in a Class III resolution on
	// a substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II. vertices listed ccw from the
	// i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [5]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 60 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
	__1:
		if !(v < DNUM_PENT_VERTS) {
			goto __3
		}
		{
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)

		}
		goto __2
	__2:
		v++
		goto __1
		goto __3
	__3:
	}
}

// *
// Generates the cell boundary in spherical coordinates for a cell given by a
// FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkToGeoBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:681:6: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	X_faceIjkToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_HEX_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lon
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	var lastFace int32 = -1
	var lastOverage TOverage = NO_OVERAGE
	{
		var vert int32 = start
	__1:
		if !(vert < start+length+additionalIteration) {
			goto __3
		}
		{
			var v int32 = vert % DNUM_HEX_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			var pentLeading4 int32 = 0
			var overage TOverage = X_adjustOverageClassII(tls, bp+116, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), pentLeading4, 1)

			//
			//         Check for edge-crossing. Each face of the underlying icosahedron is a
			//         different projection plane. So if an edge of the hexagon crosses an
			//         icosahedron edge, an additional vertex must be introduced at that
			//         intersection point. Then each half of the cell edge can be projected
			//         to geographic coordinates using the appropriate icosahedron face
			//         projection. Note that Class II cell edges have vertices on the face
			//         edge, with no edge line intersections.
			//
			if XisResClassIII(tls, res) != 0 && vert > start && (*TFaceIJK)(unsafe.Pointer(bp+116)).Fface != lastFace && lastOverage != FACE_EDGE {
				// find hex2d of the two vertexes on original face
				var lastV int32 = (v + 5) % DNUM_HEX_VERTS
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+20+uintptr(lastV)*16+4, bp+136)
				// var orig2d1 TVec2d at bp+152, 16

				X_ijkToHex2d(tls, bp+20+uintptr(v)*16+4, bp+152)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 168 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 184 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}

				var face2 int32 = func() int32 {
					if lastFace == (*TFaceIJK)(unsafe.Pointer(bp)).Fface {
						return (*TFaceIJK)(unsafe.Pointer(bp + 116)).Fface
					}
					return lastFace
				}()
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) {
				case DIJ:
					edge0 = bp + 168 /* &v0 */
					edge1 = bp + 184 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 184 /* &v1 */
					edge1 = bp + 200 /* &v2 */
					break
					fallthrough
				// case KI:
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+158, ts+105, uint32(746), uintptr(unsafe.Pointer(&__func__2)))
					}
					edge0 = bp + 200 /* &v2 */
					edge1 = bp + 168 /* &v0 */
					break
				}

				// find the intersection and add the lat/lon point to the result
				// var inter TVec2d at bp+216, 16

				X_v2dIntersect(tls, bp+136, bp+152, edge0, edge1, bp+216)
				//
				//             If a point of intersection occurs at a hexagon vertex, then each
				//             adjacent hexagon edge will lie completely on a single icosahedron
				//             face, and no additional vertex is required.
				//
				var isIntersectionAtVertex uint8 = uint8(libc.Bool32(X_v2dEquals(tls, bp+136, bp+216) != 0 || X_v2dEquals(tls, bp+152, bp+216) != 0))
				if !(isIntersectionAtVertex != 0) {
					X_hex2dToGeo(tls, bp+216, (*TFaceIJK)(unsafe.Pointer(bp /* &centerIJK */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
						g+8+uintptr((*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
					(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts++
				}
			}

			// convert vertex to lat/lon and add to the result
			// vert == start + NUM_HEX_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_HEX_VERTS {
				// var vec TVec2d at bp+232, 16

				X_ijkToHex2d(tls, bp+116+4, bp+232)
				X_hex2dToGeo(tls, bp+232, (*TFaceIJK)(unsafe.Pointer(bp+116 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TGeoBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			lastFace = (*TFaceIJK)(unsafe.Pointer(bp + 116 /* &fijk */)).Fface
			lastOverage = overage

		}
		goto __2
	__2:
		vert++
		goto __1
		goto __3
	__3:
	}
}

var __func__2 = *(*[22]uint8)(unsafe.Pointer(ts + 203)) /* faceijk.c:682:44 */

// *
// Get the vertices of a cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//            necessary for the substrate grid resolution.
// @param fijkVerts Output array for the vertices
func X_faceIjkToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:792:6: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	// the vertexes of an origin-centered cell in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp + 72 /* vertsCII */)) = [6]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
		{Fi: 2, Fk: 1}, // 5
	}

	// the vertexes of an origin-centered cell in a Class III resolution on a
	// substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [6]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
		{Fi: 5, Fk: 1}, // 5
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 72 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
	__1:
		if !(v < DNUM_HEX_VERTS) {
			goto __3
		}
		{
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)

		}
		goto __2
	__2:
		v++
		goto __1
		goto __3
	__3:
	}
}

// *
// Adjusts a FaceIJK address in place so that the resulting cell address is
// relative to the correct icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param pentLeading4 Whether or not the cell is a pentagon with a leading
//        digit 4.
// @param substrate Whether or not the cell is in a substrate grid.
// @return 0 if on original face (no overage); 1 if on face edge (only occurs
//         on substrate grids); 2 if overage on new face interior
func X_adjustOverageClassII(tls *libc.TLS, fijk uintptr, res int32, pentLeading4 int32, substrate int32) TOverage { /* faceijk.c:860:9: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var overage TOverage = NO_OVERAGE

	var ijk uintptr = fijk + 4

	// get the maximum dimension value; scale if a substrate grid
	var maxDim int32 = maxDimByCIIres[res]
	if substrate != 0 {
		maxDim = maxDim * 3
	}

	// check for overage
	if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
		overage = FACE_EDGE
	} else if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk > maxDim {
		overage = NEW_FACE
		var fijkOrient uintptr
		if (*TCoordIJK)(unsafe.Pointer(ijk)).Fk > 0 {
			if (*TCoordIJK)(unsafe.Pointer(ijk)).Fj > 0 { // jk "quadrant"
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 3*20
			} else {
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 2*20

				// adjust for the pentagonal missing sequence
				if pentLeading4 != 0 {
					// translate origin to center of pentagon
					// var origin TCoordIJK at bp, 12

					X_setIJK(tls, bp, maxDim, 0, 0)
					// var tmp TCoordIJK at bp+12, 12

					X_ijkSub(tls, ijk, bp, bp+12)
					// rotate to adjust for the missing sequence
					X_ijkRotate60cw(tls, bp+12)
					// translate the origin back to the center of the triangle
					X_ijkAdd(tls, bp+12, bp, ijk)
				}
			}
		} else { // ij "quadrant"
			fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 1*20
		}

		(*TFaceIJK)(unsafe.Pointer(fijk)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface

		// rotate and translate for adjacent face
		{
			var i int32 = 0
		__1:
			if !(i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60) {
				goto __3
			}
			X_ijkRotate60ccw(tls, ijk)
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
		var unitScale int32 = unitScaleByCIIres[res]
		if substrate != 0 {
			unitScale = unitScale * 3
		}
		X_ijkScale(tls, bp+24, unitScale)
		X_ijkAdd(tls, ijk, bp+24, ijk)
		X_ijkNormalize(tls, ijk)

		// overage points on pentagon boundaries can end up on edges
		if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
			overage = FACE_EDGE
		}
	}

	return overage
}

// *
// Adjusts a FaceIJK address for a pentagon vertex in a substrate grid in
// place so that the resulting cell address is relative to the correct
// icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
func X_adjustPentVertOverage(tls *libc.TLS, fijk uintptr, res int32) TOverage { /* faceijk.c:929:9: */
	var pentLeading4 int32 = 0
	var overage TOverage
	for __ccgo := true; __ccgo; __ccgo = overage == NEW_FACE {
		overage = X_adjustOverageClassII(tls, fijk, res, pentLeading4, 1)
	}
	return overage
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// *
// Normalizes radians to a value between 0.0 and two PI.
//
// @param rads The input radians value.
// @return The normalized radians value.
func X_posAngleRads(tls *libc.TLS, rads float64) float64 { /* geoCoord.c:34:8: */
	var tmp float64 = func() float64 {
		if rads < 0.0 {
			return rads + 6.28318530717958647692528676655900576839433
		}
		return rads
	}()
	if rads >= 6.28318530717958647692528676655900576839433 {
		tmp = tmp - 6.28318530717958647692528676655900576839433
	}
	return tmp
}

// *
// Determines if the components of two spherical coordinates are within some
// threshold distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @param threshold The threshold distance.
// @return Whether or not the two coordinates are within the threshold distance
//         of each other.
func XgeoAlmostEqualThreshold(tls *libc.TLS, p1 uintptr, p2 uintptr, threshold float64) uint8 { /* geoCoord.c:50:6: */
	return uint8(libc.Bool32(libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat-(*TGeoCoord)(unsafe.Pointer(p2)).Flat) < threshold && libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flon-(*TGeoCoord)(unsafe.Pointer(p2)).Flon) < threshold))
}

// *
// Determines if the components of two spherical coordinates are within our
// standard epsilon distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return Whether or not the two coordinates are within the epsilon distance
//         of each other.
func XgeoAlmostEqual(tls *libc.TLS, p1 uintptr, p2 uintptr) uint8 { /* geoCoord.c:65:6: */
	return XgeoAlmostEqualThreshold(tls, p1, p2, float64(.000000001)*0.0174532925199432957692369076848861271111)
}

// *
// Set the components of spherical coordinates in decimal degrees.
//
// @param p The spherical coordinates.
// @param latDegs The desired latitude in decimal degrees.
// @param lonDegs The desired longitude in decimal degrees.
func XsetGeoDegs(tls *libc.TLS, p uintptr, latDegs float64, lonDegs float64) { /* geoCoord.c:76:6: */
	X_setGeoRads(tls, p, XdegsToRads(tls, latDegs),
		XdegsToRads(tls, lonDegs))
}

// *
// Set the components of spherical coordinates in radians.
//
// @param p The spherical coordinates.
// @param latRads The desired latitude in decimal radians.
// @param lonRads The desired longitude in decimal radians.
func X_setGeoRads(tls *libc.TLS, p uintptr, latRads float64, lonRads float64) { /* geoCoord.c:88:6: */
	(*TGeoCoord)(unsafe.Pointer(p)).Flat = latRads
	(*TGeoCoord)(unsafe.Pointer(p)).Flon = lonRads
}

// *
// Convert from decimal degrees to radians.
//
// @param degrees The decimal degrees.
// @return The corresponding radians.
func XdegsToRads(tls *libc.TLS, degrees float64) float64 { /* geoCoord.c:99:8: */
	return degrees * 0.0174532925199432957692369076848861271111
}

// *
// Convert from radians to decimal degrees.
//
// @param radians The radians.
// @return The corresponding decimal degrees.
func XradsToDegs(tls *libc.TLS, radians float64) float64 { /* geoCoord.c:107:8: */
	return radians * 57.29577951308232087679815481410517033240547
}

// *
// constrainLat makes sure latitudes are in the proper bounds
//
// @param lat The original lat value
// @return The corrected lat value
func XconstrainLat(tls *libc.TLS, lat float64) float64 { /* geoCoord.c:115:8: */
	for lat > 1.57079632679489661923 {
		lat = lat - 3.14159265358979323846
	}
	return lat
}

// *
// constrainLng makes sure longitudes are in the proper bounds
//
// @param lng The origin lng value
// @return The corrected lng value
func XconstrainLng(tls *libc.TLS, lng float64) float64 { /* geoCoord.c:128:8: */
	for lng > 3.14159265358979323846 {
		lng = lng - float64(float64(2))*3.14159265358979323846
	}
	for lng < -3.14159265358979323846 {
		lng = lng + float64(float64(2))*3.14159265358979323846
	}
	return lng
}

// *
// The great circle distance in radians between two spherical coordinates.
//
// This function uses the Haversine formula.
// For math details, see:
//     https://en.wikipedia.org/wiki/Haversine_formula
//     https://www.movable-type.co.uk/scripts/latlong.html
//
// @param  a  the first lat/lng pair (in radians)
// @param  b  the second lat/lng pair (in radians)
//
// @return    the great circle distance in radians between a and b
func XpointDistRads(tls *libc.TLS, a uintptr, b uintptr) float64 { /* geoCoord.c:151:8: */
	var sinLat float64 = libc.Xsin(tls, ((*TGeoCoord)(unsafe.Pointer(b)).Flat-(*TGeoCoord)(unsafe.Pointer(a)).Flat)/2.0)
	var sinLng float64 = libc.Xsin(tls, ((*TGeoCoord)(unsafe.Pointer(b)).Flon-(*TGeoCoord)(unsafe.Pointer(a)).Flon)/2.0)

	var A float64 = sinLat*sinLat + libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(a)).Flat)*libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(b)).Flat)*sinLng*sinLng

	return float64(2) * libc.Xatan2(tls, libc.Xsqrt(tls, A), libc.Xsqrt(tls, float64(1)-A))
}

// *
// The great circle distance in kilometers between two spherical coordinates.
func XpointDistKm(tls *libc.TLS, a uintptr, b uintptr) float64 { /* geoCoord.c:163:8: */
	return XpointDistRads(tls, a, b) * 6371.007180918475
}

// *
// The great circle distance in meters between two spherical coordinates.
func XpointDistM(tls *libc.TLS, a uintptr, b uintptr) float64 { /* geoCoord.c:170:8: */
	return XpointDistKm(tls, a, b) * float64(1000)
}

// *
// Determines the azimuth to p2 from p1 in radians.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return The azimuth in radians from p1 to p2.
func X_geoAzimuthRads(tls *libc.TLS, p1 uintptr, p2 uintptr) float64 { /* geoCoord.c:181:8: */
	return libc.Xatan2(tls, libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)*libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flon-(*TGeoCoord)(unsafe.Pointer(p1)).Flon),
		libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)-libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)*libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flon-(*TGeoCoord)(unsafe.Pointer(p1)).Flon))
}

// *
// Computes the point on the sphere a specified azimuth and distance from
// another point.
//
// @param p1 The first spherical coordinates.
// @param az The desired azimuth from p1.
// @param distance The desired distance from p1, must be non-negative.
// @param p2 The spherical coordinates at the desired azimuth and distance from
// p1.
func X_geoAzDistanceRads(tls *libc.TLS, p1 uintptr, az float64, distance float64, p2 uintptr) { /* geoCoord.c:197:6: */
	if distance < 0.0000000000000001 {
		*(*TGeoCoord)(unsafe.Pointer(p2)) = *(*TGeoCoord)(unsafe.Pointer(p1))
		return
	}
	var sinlat float64
	var sinlon float64
	var coslon float64

	az = X_posAngleRads(tls, az)

	// check for due north/south azimuth
	if az < 0.0000000000000001 || libc.Xfabs(tls, az-3.14159265358979323846) < 0.0000000000000001 {
		if az < 0.0000000000000001 { // due north
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = (*TGeoCoord)(unsafe.Pointer(p1)).Flat + distance
		} else { // due south
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = (*TGeoCoord)(unsafe.Pointer(p1)).Flat - distance
		}

		if libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = 0.0
		} else if libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = 0.0
		} else {
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = XconstrainLng(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flon)
		}
	} else {
		sinlat = libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, distance) + libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, distance)*libc.Xcos(tls, az)
		if sinlat > 1.0 {
			sinlat = 1.0
		}
		if sinlat < -1.0 {
			sinlat = -1.0
		}
		(*TGeoCoord)(unsafe.Pointer(p2)).Flat = libc.Xasin(tls, sinlat)
		if libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = 0.0
		} else if libc.Xfabs(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TGeoCoord)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = 0.0
		} else {
			sinlon = libc.Xsin(tls, az) * libc.Xsin(tls, distance) / libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)
			coslon = (libc.Xcos(tls, distance) - libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)) / libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flat) / libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(p2)).Flat)
			if sinlon > 1.0 {
				sinlon = 1.0
			}
			if sinlon < -1.0 {
				sinlon = -1.0
			}
			if coslon > 1.0 {
				coslon = 1.0
			}
			if coslon < -1.0 {
				coslon = -1.0
			}
			(*TGeoCoord)(unsafe.Pointer(p2)).Flon = XconstrainLng(tls, (*TGeoCoord)(unsafe.Pointer(p1)).Flon+libc.Xatan2(tls, sinlon, coslon))
		}
	}
}

// The following functions provide meta information about the H3 hexagons at
// each zoom level. Since there are only 16 total levels, these are current
// handled with hardwired static values, but it may be worthwhile to put these
// static values into another file that can be autogenerated by source code in
// the future.

func XhexAreaKm2(tls *libc.TLS, res int32) float64 { /* geoCoord.c:261:8: */
	return areas[res]
}

var areas = [16]float64{
	4250546.848, 607220.9782, 86745.85403, 12392.26486,
	1770.323552, 252.9033645, 36.1290521, 5.1612932,
	0.7373276, 0.1053325, 0.0150475, 0.0021496,
	0.0003071, 0.0000439, 0.0000063, 0.0000009} /* geoCoord.c:262:25 */

func XhexAreaM2(tls *libc.TLS, res int32) float64 { /* geoCoord.c:270:8: */
	return areas1[res]
}

var areas1 = [16]float64{
	4.25055e+12, 6.07221e+11, float64(86745854035), float64(12392264862),
	float64(1770323552), 252903364.5, 36129052.1, 5161293.2,
	737327.6, 105332.5, 15047.5, 2149.6,
	307.1, 43.9, 6.3, 0.9} /* geoCoord.c:271:25 */

func XedgeLengthKm(tls *libc.TLS, res int32) float64 { /* geoCoord.c:279:8: */
	return lens[res]
}

var lens = [16]float64{
	1107.712591, 418.6760055, 158.2446558, 59.81085794,
	22.6063794, 8.544408276, 3.229482772, 1.220629759,
	0.461354684, 0.174375668, 0.065907807, 0.024910561,
	0.009415526, 0.003559893, 0.001348575, 0.000509713} /* geoCoord.c:280:25 */

func XedgeLengthM(tls *libc.TLS, res int32) float64 { /* geoCoord.c:288:8: */
	return lens1[res]
}

var lens1 = [16]float64{
	1107712.591, 418676.0055, 158244.6558, 59810.85794,
	22606.3794, 8544.408276, 3229.482772, 1220.629759,
	461.3546837, 174.3756681, 65.90780749, 24.9105614,
	9.415526211, 3.559893033, 1.348574562, 0.509713273} /* geoCoord.c:289:25 */

//* @brief Number of unique valid H3Indexes at given resolution.
func XnumHexagons(tls *libc.TLS, res int32) Tint64_t { /* geoCoord.c:298:9: */
	return nums[res]
}

var nums = [16]Tint64_t{122,
	842,
	5882,
	41162,
	288122,
	2016842,
	14117882,
	98825162,
	691776122,
	4842432842,
	33897029882,
	237279209162,
	1660954464122,
	11626681248842,
	81386768741882,
	569707381193162} /* geoCoord.c:309:26 */

// *
// Surface area in radians^2 of spherical triangle on unit sphere.
//
// For the math, see:
// https://en.wikipedia.org/wiki/Spherical_trigonometry#Area_and_spherical_excess
//
// @param   a  length of triangle side A in radians
// @param   b  length of triangle side B in radians
// @param   c  length of triangle side C in radians
//
// @return     area in radians^2 of triangle on unit sphere
func XtriangleEdgeLengthsToArea(tls *libc.TLS, a float64, b float64, c float64) float64 { /* geoCoord.c:340:8: */
	var s float64 = (a + b + c) / float64(2)

	a = (s - a) / float64(2)
	b = (s - b) / float64(2)
	c = (s - c) / float64(2)
	s = s / float64(2)

	return float64(4) * libc.Xatan(tls, libc.Xsqrt(tls, libc.Xtan(tls, s)*libc.Xtan(tls, a)*libc.Xtan(tls, b)*libc.Xtan(tls, c)))
}

// *
// Compute area in radians^2 of a spherical triangle, given its vertices.
//
// @param   a  vertex lat/lng in radians
// @param   b  vertex lat/lng in radians
// @param   c  vertex lat/lng in radians
//
// @return     area of triangle on unit sphere, in radians^2
func XtriangleArea(tls *libc.TLS, a uintptr, b uintptr, c uintptr) float64 { /* geoCoord.c:360:8: */
	return XtriangleEdgeLengthsToArea(tls, XpointDistRads(tls, a, b),
		XpointDistRads(tls, b, c),
		XpointDistRads(tls, c, a))
}

// *
// Area of H3 cell in radians^2.
//
// The area is calculated by breaking the cell into spherical triangles and
// summing up their areas. Note that some H3 cells (hexagons and pentagons)
// are irregular, and have more than 6 or 5 sides.
//
// todo: optimize the computation by re-using the edges shared between triangles
//
// @param   cell  H3 cell
//
// @return        cell area in radians^2
func XcellAreaRads2(tls *libc.TLS, cell TH3Index) float64 { /* geoCoord.c:379:8: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var c TGeoCoord at bp, 16

	// var gb TGeoBoundary at bp+16, 168

	Xh3ToGeo(tls, cell, bp)
	Xh3ToGeoBoundary(tls, cell, bp+16)

	var area float64 = 0.0
	{
		var i int32 = 0
	__1:
		if !(i < (*TGeoBoundary)(unsafe.Pointer(bp+16)).FnumVerts) {
			goto __3
		}
		{
			var j int32 = (i + 1) % (*TGeoBoundary)(unsafe.Pointer(bp+16)).FnumVerts
			area = area + XtriangleArea(tls, bp+16+8+uintptr(i)*16, bp+16+8+uintptr(j)*16, bp)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	return area
}

// *
// Area of H3 cell in kilometers^2.
func XcellAreaKm2(tls *libc.TLS, h TH3Index) float64 { /* geoCoord.c:397:8: */
	return XcellAreaRads2(tls, h) * 6371.007180918475 * 6371.007180918475
}

// *
// Area of H3 cell in meters^2.
func XcellAreaM2(tls *libc.TLS, h TH3Index) float64 { /* geoCoord.c:404:8: */
	return XcellAreaKm2(tls, h) * float64(1000) * float64(1000)
}

// *
// Length of a unidirectional edge in radians.
//
// @param   edge  H3 unidirectional edge
//
// @return        length in radians
func XexactEdgeLengthRads(tls *libc.TLS, edge TH3Index) float64 { /* geoCoord.c:415:8: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var gb TGeoBoundary at bp, 168

	XgetH3UnidirectionalEdgeBoundary(tls, edge, bp)

	var length float64 = 0.0
	{
		var i int32 = 0
	__1:
		if !(i < (*TGeoBoundary)(unsafe.Pointer(bp)).FnumVerts-1) {
			goto __3
		}
		{
			length = length + XpointDistRads(tls, bp+8+uintptr(i)*16, bp+8+uintptr(i+1)*16)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	return length
}

// *
// Length of a unidirectional edge in kilometers.
func XexactEdgeLengthKm(tls *libc.TLS, edge TH3Index) float64 { /* geoCoord.c:431:8: */
	return XexactEdgeLengthRads(tls, edge) * 6371.007180918475
}

// *
// Length of a unidirectional edge in meters.
func XexactEdgeLengthM(tls *libc.TLS, edge TH3Index) float64 { /* geoCoord.c:438:8: */
	return XexactEdgeLengthKm(tls, edge) * float64(1000)
}

// Copyright 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lon.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the type definitions.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = uint32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:275:5 */

// *
// Returns the H3 resolution of an H3 index.
// @param h The H3 index.
// @return The resolution of the H3 index argument.
func Xh3GetResolution(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:38:5: */
	return int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
}

// *
// Returns the H3 base cell "number" of an H3 cell (hexagon or pentagon).
//
// Note: Technically works on H3 edges, but will return base cell of the
// origin cell.
//
// @param h The H3 cell.
// @return The base cell "number" of the H3 cell argument.
func Xh3GetBaseCell(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:49:5: */
	return int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
}

// *
// Converts a string representation of an H3 index into an H3 index.
// @param str The string representation of an H3 index.
// @return The H3 index corresponding to the string argument, or H3_NULL if
// invalid.
func XstringToH3(tls *libc.TLS, str uintptr) TH3Index { /* h3Index.c:57:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TH3Index)(unsafe.Pointer(bp + 8 /* h */)) = uint64(DH3_NULL)
	// If failed, h will be unmodified and we should return H3_NULL anyways.
	libc.Xsscanf(tls, str, ts+225, libc.VaList(bp, bp+8))
	return *(*TH3Index)(unsafe.Pointer(bp + 8 /* h */))
}

// *
// Converts an H3 index into a string representation.
// @param h The H3 index to convert.
// @param str The string representation of the H3 index.
// @param sz Size of the buffer `str`
func Xh3ToString(tls *libc.TLS, h TH3Index, str uintptr, sz Tsize_t) { /* h3Index.c:70:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// An unsigned 64 bit integer will be expressed in at most
	// 16 digits plus 1 for the null terminator.
	if sz < uint64(17) {
		// Buffer is potentially not large enough.
		return
	}
	libc.Xsprintf(tls, str, ts+225, libc.VaList(bp, h))
}

// *
// Returns whether or not an H3 index is a valid cell (hexagon or pentagon).
// @param h The H3 index to validate.
// @return 1 if the H3 index if valid, and 0 if it is not.
func Xh3IsValid(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:85:5: */
	if int32(h&(Tuint64_t(uint64(1))<<DH3_MAX_OFFSET)>>DH3_MAX_OFFSET) != 0 {
		return 0
	}

	if int32(h&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_HEXAGON_MODE {
		return 0
	}

	if int32(h&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) != 0 {
		return 0
	}

	var baseCell int32 = int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if baseCell < 0 || baseCell >= DNUM_BASE_CELLS {
		return 0
	}

	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if res < 0 || res > DMAX_H3_RES {
		return 0
	}

	var foundFirstNonZeroDigit uint8 = uint8(Dfalse)
	{
		var r int32 = 1
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			var digit TDirection = TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))

			if !(foundFirstNonZeroDigit != 0) && digit != CENTER_DIGIT {
				foundFirstNonZeroDigit = uint8(Dtrue)
				if X_isBaseCellPentagon(tls, baseCell) != 0 && digit == K_AXES_DIGIT {
					return 0
				}
			}

			if digit < CENTER_DIGIT || digit >= NUM_DIGITS {
				return 0
			}

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}

	{
		var r1 int32 = res + 1
	__4:
		if !(r1 <= DMAX_H3_RES) {
			goto __6
		}
		{
			var digit TDirection = TDirection(h >> ((DMAX_H3_RES - r1) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			if digit != INVALID_DIGIT {
				return 0
			}

		}
		goto __5
	__5:
		r1++
		goto __4
		goto __6
	__6:
	}

	return 1
}

// *
// Initializes an H3 index.
// @param hp The H3 index to initialize.
// @param res The H3 resolution to initialize the index to.
// @param baseCell The H3 base cell to initialize the index to.
// @param initDigit The H3 digit (0-7) to initialize all of the index digits to.
func XsetH3Index(tls *libc.TLS, hp uintptr, res int32, baseCell int32, initDigit TDirection) { /* h3Index.c:127:6: */
	var h TH3Index = 35184372088831
	h = h&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_HEXAGON_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET
	h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET
	{
		var r int32 = 1
	__1:
		if !(r <= res) {
			goto __3
		}
		h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(initDigit)<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}
	*(*TH3Index)(unsafe.Pointer(hp)) = h
}

// *
// h3ToParent produces the parent index for a given H3 index
//
// @param h H3Index to find parent of
// @param parentRes The resolution to switch to (parent, grandparent, etc)
//
// @return H3Index of the parent, or H3_NULL if you actually asked for a child
func Xh3ToParent(tls *libc.TLS, h TH3Index, parentRes int32) TH3Index { /* h3Index.c:144:9: */
	var childRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if parentRes > childRes {
		return uint64(DH3_NULL)
	} else if parentRes == childRes {
		return h
	} else if parentRes < 0 || parentRes > DMAX_H3_RES {
		return uint64(DH3_NULL)
	}
	var parentH TH3Index = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|Tuint64_t(parentRes)<<DH3_RES_OFFSET)
	{
		var i int32 = parentRes + 1
	__1:
		if !(i <= childRes) {
			goto __3
		}
		{
			parentH = parentH & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return parentH
}

// *
// Determines whether one resolution is a valid child resolution of another.
// Each resolution is considered a valid child resolution of itself.
//
// @param parentRes int resolution of the parent
// @param childRes int resolution of the child
//
// @return The validity of the child resolution
func _isValidChildRes(tls *libc.TLS, parentRes int32, childRes int32) uint8 { /* h3Index.c:169:13: */
	if childRes < parentRes || childRes > DMAX_H3_RES {
		return uint8(Dfalse)
	}
	return uint8(Dtrue)
}

// *
// maxH3ToChildrenSize returns the maximum number of children possible for a
// given child level.
//
// @param h H3Index to find the number of children of
// @param childRes The resolution of the child level you're interested in
//
// @return int count of maximum number of children (equal for hexagons, less for
// pentagons
func XmaxH3ToChildrenSize(tls *libc.TLS, h TH3Index, childRes int32) int32 { /* h3Index.c:186:5: */
	var parentRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if !(_isValidChildRes(tls, parentRes, childRes) != 0) {
		return 0
	}
	return X_ipow(tls, 7, childRes-parentRes)
}

// *
// makeDirectChild takes an index and immediately returns the immediate child
// index based on the specified cell number. Bit operations only, could generate
// invalid indexes if not careful (deleted cell under a pentagon).
//
// @param h H3Index to find the direct child of
// @param cellNumber int id of the direct child (0-6)
//
// @return The new H3Index for the child
func XmakeDirectChild(tls *libc.TLS, h TH3Index, cellNumber int32) TH3Index { /* h3Index.c:204:9: */
	var childRes int32 = int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) + 1
	var childH TH3Index = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|Tuint64_t(childRes)<<DH3_RES_OFFSET)
	childH = childH & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(cellNumber)<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)
	return childH
}

// *
// h3ToChildren takes the given hexagon id and generates all of the children
// at the specified resolution storing them into the provided memory pointer.
// It's assumed that maxH3ToChildrenSize was used to determine the allocation.
//
// @param h H3Index to find the children of
// @param childRes int the child level to produce
// @param children H3Index* the memory to store the resulting addresses in
func Xh3ToChildren(tls *libc.TLS, h TH3Index, childRes int32, children uintptr) { /* h3Index.c:220:6: */
	var parentRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if !(_isValidChildRes(tls, parentRes, childRes) != 0) {
		return
	} else if parentRes == childRes {
		*(*TH3Index)(unsafe.Pointer(children)) = h
		return
	}
	var bufferSize int32 = XmaxH3ToChildrenSize(tls, h, childRes)
	var bufferChildStep int32 = bufferSize / 7
	var isAPentagon int32 = Xh3IsPentagon(tls, h)
	{
		var i int32 = 0
	__1:
		if !(i < 7) {
			goto __3
		}
		{
			if isAPentagon != 0 && i == K_AXES_DIGIT {
				var nextChild uintptr = children + uintptr(bufferChildStep)*8
				for children < nextChild {
					*(*TH3Index)(unsafe.Pointer(children)) = uint64(DH3_NULL)
					children += 8
				}
			} else {
				Xh3ToChildren(tls, XmakeDirectChild(tls, h, i), childRes, children)
				children += 8 * uintptr(bufferChildStep)
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// *
// h3ToCenterChild produces the center child index for a given H3 index at
// the specified resolution
//
// @param h H3Index to find center child of
// @param childRes The resolution to switch to
//
// @return H3Index of the center child, or H3_NULL if you actually asked for a
// parent
func Xh3ToCenterChild(tls *libc.TLS, h TH3Index, childRes int32) TH3Index { /* h3Index.c:255:9: */
	var parentRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if !(_isValidChildRes(tls, parentRes, childRes) != 0) {
		return uint64(DH3_NULL)
	} else if childRes == parentRes {
		return h
	}
	var child TH3Index = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|Tuint64_t(childRes)<<DH3_RES_OFFSET)
	{
		var i int32 = parentRes + 1
	__1:
		if !(i <= childRes) {
			goto __3
		}
		{
			child = child & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(uint64(0))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return child
}

// *
// compact takes a set of hexagons all at the same resolution and compresses
// them by pruning full child branches to the parent level. This is also done
// for all parents recursively to get the minimum number of hex addresses that
// perfectly cover the defined space.
// @param h3Set Set of hexagons
// @param compactedSet The output array of compressed hexagons (preallocated)
// @param numHexes The size of the input and output arrays (possible that no
// contiguous regions exist in the set at all and no compression possible)
// @return an error code on bad input data
func Xcompact(tls *libc.TLS, h3Set uintptr, compactedSet uintptr, numHexes int32) int32 { /* h3Index.c:280:5: */
	if numHexes == 0 {
		return DCOMPACT_SUCCESS
	}
	var res int32 = int32(*(*TH3Index)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if res == 0 {
		// No compaction possible, just copy the set to output
		{
			var i int32 = 0
		__1:
			if !(i < numHexes) {
				goto __3
			}
			{
				*(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(h3Set + uintptr(i)*8))

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
		}
		return DCOMPACT_SUCCESS
	}
	var remainingHexes uintptr = libc.Xmalloc(tls, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
	if !(remainingHexes != 0) {
		return -3
	}
	libc.Xmemcpy(tls, remainingHexes, h3Set, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
	var hashSetArray uintptr = libc.Xcalloc(tls, uint64(numHexes), uint64(unsafe.Sizeof(TH3Index(0))))
	if !(hashSetArray != 0) {
		libc.Xfree(tls, remainingHexes)
		return -3
	}
	var compactedSetOffset uintptr = compactedSet
	var numRemainingHexes int32 = numHexes
	for numRemainingHexes != 0 {
		res = int32(*(*TH3Index)(unsafe.Pointer(remainingHexes)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		var parentRes int32 = res - 1
		// Put the parents of the hexagons into the temp array
		// via a hashing mechanism, and use the reserved bits
		// to track how many times a parent is duplicated
		{
			var i int32 = 0
		__4:
			if !(i < numRemainingHexes) {
				goto __6
			}
			{
				var currIndex TH3Index = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i)*8))
				if currIndex != uint64(0) {
					var parent TH3Index = Xh3ToParent(tls, currIndex, parentRes)
					// Modulus hash the parent into the temp array
					var loc int32 = int32(parent % TH3Index(numRemainingHexes))
					var loopCount int32 = 0
					for *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != uint64(0) {
						if loopCount > numRemainingHexes { // LCOV_EXCL_BR_LINE
							// LCOV_EXCL_START
							// This case should not be possible because at most one
							// index is placed into hashSetArray per
							// numRemainingHexes.
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return -1
							// LCOV_EXCL_STOP
						}
						var tempIndex TH3Index = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
						if tempIndex == parent {
							var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
							var limitCount int32 = 7
							if Xh3IsPentagon(tls,
								tempIndex&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
								limitCount--
							}
							// One is added to count for this check to match one
							// being added to count later in this function when
							// checking for all children being present.
							if count+1 > limitCount {
								// Only possible on duplicate input
								libc.Xfree(tls, remainingHexes)
								libc.Xfree(tls, hashSetArray)
								return -2
							}
							parent = parent&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(count)<<DH3_RESERVED_OFFSET
							*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = uint64(DH3_NULL)
						} else {
							loc = (loc + 1) % numRemainingHexes
						}
						loopCount++
					}
					*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = parent
				}

			}
			goto __5
		__5:
			i++
			goto __4
			goto __6
		__6:
		}
		// Determine which parent hexagons have a complete set
		// of children and put them in the compactableHexes array
		var compactableCount int32 = 0
		var maxCompactableCount int32 = numRemainingHexes / 6 // Somehow all pentagons; conservative
		if maxCompactableCount == 0 {
			libc.Xmemcpy(tls, compactedSetOffset, remainingHexes,
				uint64(numRemainingHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
			break
		}
		var compactableHexes uintptr = libc.Xcalloc(tls, uint64(maxCompactableCount), uint64(unsafe.Sizeof(TH3Index(0))))
		if !(compactableHexes != 0) {
			libc.Xfree(tls, remainingHexes)
			libc.Xfree(tls, hashSetArray)
			return -3
		}
		{
			var i1 int32 = 0
		__7:
			if !(i1 < numRemainingHexes) {
				goto __9
			}
			{
				if *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8)) == uint64(0) {
					goto __8
				}
				var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
				// Include the deleted direction for pentagons as implicitly "there"
				if Xh3IsPentagon(tls, *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
					// We need this later on, no need to recalculate
					*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8)) = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(count)<<DH3_RESERVED_OFFSET
					// Increment count after setting the reserved bits,
					// since count is already incremented above, so it
					// will be the expected value for a complete hexagon.
					count++
				}
				if count == 7 {
					// Bingo! Full set!
					*(*TH3Index)(unsafe.Pointer(compactableHexes + uintptr(compactableCount)*8)) = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(i1)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
					compactableCount++
				}

			}
			goto __8
		__8:
			i1++
			goto __7
			goto __9
		__9:
		}
		// Uncompactable hexes are immediately copied into the
		// output compactedSetOffset
		var uncompactableCount int32 = 0
		{
			var i2 int32 = 0
		__10:
			if !(i2 < numRemainingHexes) {
				goto __12
			}
			{
				var currIndex TH3Index = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i2)*8))
				if currIndex != uint64(DH3_NULL) {
					var parent TH3Index = Xh3ToParent(tls, currIndex, parentRes)
					// Modulus hash the parent into the temp array
					// to determine if this index was included in
					// the compactableHexes array
					var loc int32 = int32(parent % TH3Index(numRemainingHexes))
					var loopCount int32 = 0
					var isUncompactable uint8 = uint8(Dtrue)
					for __ccgo := true; __ccgo; __ccgo = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != parent {
						if loopCount > numRemainingHexes { // LCOV_EXCL_BR_LINE
							// LCOV_EXCL_START
							// This case should not be possible because at most one
							// index is placed into hashSetArray per input hexagon.
							libc.Xfree(tls, compactableHexes)
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return -1
							// LCOV_EXCL_STOP
						}
						var tempIndex TH3Index = *(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)
						if tempIndex == parent {
							var count int32 = int32(*(*TH3Index)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
							if count == 7 {
								isUncompactable = uint8(Dfalse)
							}
							break
						} else {
							loc = (loc + 1) % numRemainingHexes
						}
						loopCount++
					}
					if isUncompactable != 0 {
						*(*TH3Index)(unsafe.Pointer(compactedSetOffset + uintptr(uncompactableCount)*8)) = *(*TH3Index)(unsafe.Pointer(remainingHexes + uintptr(i2)*8))
						uncompactableCount++
					}
				}

			}
			goto __11
		__11:
			i2++
			goto __10
			goto __12
		__12:
		}
		// Set up for the next loop
		libc.Xmemset(tls, hashSetArray, 0, uint64(numHexes)*uint64(unsafe.Sizeof(TH3Index(0))))
		compactedSetOffset += 8 * uintptr(uncompactableCount)
		libc.Xmemcpy(tls, remainingHexes, compactableHexes,
			uint64(compactableCount)*uint64(unsafe.Sizeof(TH3Index(0))))
		numRemainingHexes = compactableCount
		libc.Xfree(tls, compactableHexes)
	}
	libc.Xfree(tls, remainingHexes)
	libc.Xfree(tls, hashSetArray)
	return DCOMPACT_SUCCESS
}

// *
// uncompact takes a compressed set of hexagons and expands back to the
// original set of hexagons.
// @param compactedSet Set of hexagons
// @param numHexes The number of hexes in the input set
// @param h3Set Output array of decompressed hexagons (preallocated)
// @param maxHexes The size of the output array to bound check against
// @param res The hexagon resolution to decompress to
// @return An error code if output array is too small or any hexagon is
// smaller than the output resolution.
func Xuncompact(tls *libc.TLS, compactedSet uintptr, numHexes int32, h3Set uintptr, maxHexes int32, res int32) int32 { /* h3Index.c:461:5: */
	var outOffset int32 = 0
	{
		var i int32 = 0
	__1:
		if !(i < numHexes) {
			goto __3
		}
		{
			if *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) == uint64(0) {
				goto __2
			}
			if outOffset >= maxHexes {
				// We went too far, abort!
				return -1
			}
			var currentRes int32 = int32(*(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
			if !(_isValidChildRes(tls, currentRes, res) != 0) {
				// Nonsensical. Abort.
				return -2
			}
			if currentRes == res {
				// Just copy and move along
				*(*TH3Index)(unsafe.Pointer(h3Set + uintptr(outOffset)*8)) = *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8))
				outOffset++
			} else {
				// Bigger hexagon to reduce in size
				var numHexesToGen int32 = XmaxH3ToChildrenSize(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)), res)
				if outOffset+numHexesToGen > maxHexes {
					// We're about to go too far, abort!
					return -1
				}
				Xh3ToChildren(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)), res, h3Set+uintptr(outOffset)*8)
				outOffset = outOffset + numHexesToGen
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return 0
}

// *
// maxUncompactSize takes a compacted set of hexagons are provides an
// upper-bound estimate of the size of the uncompacted set of hexagons.
// @param compactedSet Set of hexagons
// @param numHexes The number of hexes in the input set
// @param res The hexagon resolution to decompress to
// @return The number of hexagons to allocate memory for, or a negative
// number if an error occurs.
func XmaxUncompactSize(tls *libc.TLS, compactedSet uintptr, numHexes int32, res int32) int32 { /* h3Index.c:503:5: */
	var maxNumHexagons int32 = 0
	{
		var i int32 = 0
	__1:
		if !(i < numHexes) {
			goto __3
		}
		{
			if *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) == uint64(0) {
				goto __2
			}
			var currentRes int32 = int32(*(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
			if !(_isValidChildRes(tls, currentRes, res) != 0) {
				// Nonsensical. Abort.
				return -1
			}
			if currentRes == res {
				maxNumHexagons++
			} else {
				// Bigger hexagon to reduce in size
				var numHexesToGen int32 = XmaxH3ToChildrenSize(tls, *(*TH3Index)(unsafe.Pointer(compactedSet + uintptr(i)*8)), res)
				maxNumHexagons = maxNumHexagons + numHexesToGen
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return maxNumHexagons
}

// *
// h3IsResClassIII takes a hexagon ID and determines if it is in a
// Class III resolution (rotated versus the icosahedron and subject
// to shape distortion adding extra points on icosahedron edges, making
// them not true hexagons).
// @param h The H3Index to check.
// @return Returns 1 if the hexagon is class III, otherwise 0.
func Xh3IsResClassIII(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:533:5: */
	return int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) % 2
}

// *
// h3IsPentagon takes an H3Index and determines if it is actually a
// pentagon.
// @param h The H3Index to check.
// @return Returns 1 if it is a pentagon, otherwise 0.
func Xh3IsPentagon(tls *libc.TLS, h TH3Index) int32 { /* h3Index.c:541:5: */
	return libc.Bool32(X_isBaseCellPentagon(tls, int32(h&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0 && !(X_h3LeadingNonZeroDigit(tls, h) != 0))
}

// *
// Returns the highest resolution non-zero digit in an H3Index.
// @param h The H3Index.
// @return The highest resolution non-zero digit in the H3Index.
func X_h3LeadingNonZeroDigit(tls *libc.TLS, h TH3Index) TDirection { /* h3Index.c:551:11: */
	{
		var r int32 = 1
	__1:
		if !(r <= int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET)) {
			goto __3
		}
		if TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != 0 {
			return TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}

	// if we're here it's all 0's
	return CENTER_DIGIT
}

// *
// Rotate an H3Index 60 degrees counter-clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60ccw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:563:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			// rotate this digit
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60ccw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != TDirection(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60ccw(tls, h)
				}
			}

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}
	return h
}

// *
// Rotate an H3Index 60 degrees clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60cw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:589:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			// rotate this digit
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60cw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != TDirection(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60cw(tls, h)
				}
			}

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}
	return h
}

// *
// Rotate an H3Index 60 degrees counter-clockwise.
// @param h The H3Index.
func X_h3Rotate60ccw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:614:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			var oldDigit TDirection = TDirection(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60ccw(tls, oldDigit))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}

	return h
}

// *
// Rotate an H3Index 60 degrees clockwise.
// @param h The H3Index.
func X_h3Rotate60cw(tls *libc.TLS, h TH3Index) TH3Index { /* h3Index.c:627:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_rotate60cw(tls, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}

	return h
}

// *
// Convert an FaceIJK address to the corresponding H3Index.
// @param fijk The FaceIJK address.
// @param res The cell resolution.
// @return The encoded H3Index (or H3_NULL on failure).
func X_faceIjkToH3(tls *libc.TLS, fijk uintptr, res int32) TH3Index { /* h3Index.c:641:9: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// initialize the index
	var h TH3Index = 35184372088831
	h = h&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_HEXAGON_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		if (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk > DMAX_FACE_COORD {
			// out of range input
			return uint64(DH3_NULL)
		}

		h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(X_faceIjkToBaseCell(tls, fijk))<<DH3_BC_OFFSET
		return h
	}

	// we need to find the correct base cell FaceIJK for this H3 index;
	// start with the passed in face and resolution res ijk coordinates
	// in that face's coordinate system
	*(*TFaceIJK)(unsafe.Pointer(bp /* fijkBC */)) = *(*TFaceIJK)(unsafe.Pointer(fijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	var ijk uintptr = bp + 4
	{
		var r int32 = res - 1
	__1:
		if !(r >= 0) {
			goto __3
		}
		{
			*(*TCoordIJK)(unsafe.Pointer(bp + 28 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
			// var lastCenter TCoordIJK at bp+16, 12

			if XisResClassIII(tls, r+1) != 0 {
				// rotate ccw
				X_upAp7(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7(tls, bp+16)
			} else {
				// rotate cw
				X_upAp7r(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7r(tls, bp+16)
			}
			// var diff TCoordIJK at bp+40, 12

			X_ijkSub(tls, bp+28, bp+16, bp+40)
			X_ijkNormalize(tls, bp+40)

			h = h & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_unitIjkToDigit(tls, bp+40))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		r--
		goto __1
		goto __3
	__3:
	}

	// fijkBC should now hold the IJK of the base cell in the
	// coordinate system of the current face

	if (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fk > DMAX_FACE_COORD {
		// out of range input
		return uint64(DH3_NULL)
	}

	// lookup the correct base cell
	var baseCell int32 = X_faceIjkToBaseCell(tls, bp)
	h = h&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET

	// rotate if necessary to get canonical base cell orientation
	// for this base cell
	var numRots int32 = X_faceIjkToBaseCellCCWrot60(tls, bp)
	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
			// check for a cw/ccw offset face; default is ccw
			if X_baseCellIsCwOffset(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp)).Fface) != 0 {
				h = X_h3Rotate60cw(tls, h)
			} else {
				h = X_h3Rotate60ccw(tls, h)
			}
		}

		{
			var i int32 = 0
		__4:
			if !(i < numRots) {
				goto __6
			}
			h = X_h3RotatePent60ccw(tls, h)
			goto __5
		__5:
			i++
			goto __4
			goto __6
		__6:
		}
	} else {
		{
			var i int32 = 0
		__7:
			if !(i < numRots) {
				goto __9
			}
			{
				h = X_h3Rotate60ccw(tls, h)

			}
			goto __8
		__8:
			i++
			goto __7
			goto __9
		__9:
		}
	}

	return h
}

func XisXFinite(tls *libc.TLS, f float64) uint8 { /* h3Index.c:727:6: */
	return libc.BoolUint8(!(libc.X__builtin_isnan(tls, f-f) != 0))
}

// *
// Encodes a coordinate on the sphere to the H3 index of the containing cell at
// the specified resolution.
//
// Returns 0 on invalid input.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @return The encoded H3Index (or H3_NULL on failure).
func XgeoToH3(tls *libc.TLS, g uintptr, res int32) TH3Index { /* h3Index.c:739:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if res < 0 || res > DMAX_H3_RES {
		return uint64(DH3_NULL)
	}
	if !(XisXFinite(tls, (*TGeoCoord)(unsafe.Pointer(g)).Flat) != 0) || !(XisXFinite(tls, (*TGeoCoord)(unsafe.Pointer(g)).Flon) != 0) {
		return uint64(DH3_NULL)
	}
	// var fijk TFaceIJK at bp, 16

	X_geoToFaceIjk(tls, g, res, bp)
	return X_faceIjkToH3(tls, bp, res)
}

// *
// Convert an H3Index to the FaceIJK address on a specified icosahedral face.
// @param h The H3Index.
// @param fijk The FaceIJK address, initialized with the desired face
//        and normalized base cell coordinates.
// @return Returns 1 if the possibility of overage exists, otherwise 0.
func X_h3ToFaceIjkWithInitializedFijk(tls *libc.TLS, h TH3Index, fijk uintptr) int32 { /* h3Index.c:759:5: */
	var ijk uintptr = fijk + 4
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	// center base cell hierarchy is entirely on this face
	var possibleOverage int32 = 1
	if !(X_isBaseCellPentagon(tls, int32(h&(Tuint64_t(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0) && (res == 0 || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk == 0) {
		possibleOverage = 0
	}

	{
		var r int32 = 1
	__1:
		if !(r <= res) {
			goto __3
		}
		{
			if XisResClassIII(tls, r) != 0 {
				// Class III == rotate ccw
				X_downAp7(tls, ijk)
			} else {
				// Class II == rotate cw
				X_downAp7r(tls, ijk)
			}

			X_neighbor(tls, ijk, TDirection(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)))

		}
		goto __2
	__2:
		r++
		goto __1
		goto __3
	__3:
	}

	return possibleOverage
}

// *
// Convert an H3Index to a FaceIJK address.
// @param h The H3Index.
// @param fijk The corresponding FaceIJK address.
func X_h3ToFaceIjk(tls *libc.TLS, h TH3Index, fijk uintptr) { /* h3Index.c:790:6: */
	var baseCell int32 = int32(h & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	// adjust for the pentagonal missing sequence; all of sub-sequence 5 needs
	// to be adjusted (and some of sub-sequence 4 below)
	if X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == TDirection(5) {
		h = X_h3Rotate60cw(tls, h)
	}

	// start with the "home" face and ijk+ coordinates for the base cell of c
	*(*TFaceIJK)(unsafe.Pointer(fijk)) = XbaseCellData[baseCell].FhomeFijk
	if !(X_h3ToFaceIjkWithInitializedFijk(tls, h, fijk) != 0) {
		return
	} // no overage is possible; h lies on this face

	// if we're here we have the potential for an "overage"; i.e., it is
	// possible that c lies on an adjacent face

	var origIJK = (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord

	// if we're in Class III, drop into the next finer Class II grid
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if XisResClassIII(tls, res) != 0 {
		// Class III
		X_downAp7r(tls, fijk+4)
		res++
	}

	// adjust for overage if needed
	// a pentagon base cell with a leading 4 digit requires special handling
	var pentLeading4 int32 = libc.Bool32(X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == TDirection(4))
	if X_adjustOverageClassII(tls, fijk, res, pentLeading4, 0) != NO_OVERAGE {
		// if the base cell is a pentagon we have the potential for secondary
		// overages
		if X_isBaseCellPentagon(tls, baseCell) != 0 {
			for X_adjustOverageClassII(tls, fijk, res, 0, 0) != NO_OVERAGE {
				continue
			}
		}

		if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
			X_upAp7r(tls, fijk+4)
		}
	} else if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord = origIJK
	}
}

// *
// Determines the spherical coordinates of the center point of an H3 index.
//
// @param h3 The H3 index.
// @param g The spherical coordinates of the H3 cell center.
func Xh3ToGeo(tls *libc.TLS, h3 TH3Index, g uintptr) { /* h3Index.c:839:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	X_h3ToFaceIjk(tls, h3, bp)
	X_faceIjkToGeo(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), g)
}

// *
// Determines the cell boundary in spherical coordinates for an H3 index.
//
// @param h3 The H3 index.
// @param gb The boundary of the H3 cell in spherical coordinates.
func Xh3ToGeoBoundary(tls *libc.TLS, h3 TH3Index, gb uintptr) { /* h3Index.c:851:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	X_h3ToFaceIjk(tls, h3, bp)
	if Xh3IsPentagon(tls, h3) != 0 {
		X_faceIjkPentToGeoBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0,
			DNUM_PENT_VERTS, gb)
	} else {
		X_faceIjkToGeoBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0, DNUM_HEX_VERTS,
			gb)
	}
}

// *
// Returns the max number of possible icosahedron faces an H3 index
// may intersect.
//
// @return int count of faces
func XmaxFaceCount(tls *libc.TLS, h3 TH3Index) int32 { /* h3Index.c:869:5: */
	// a pentagon always intersects 5 faces, a hexagon never intersects more
	// than 2 (but may only intersect 1)
	if Xh3IsPentagon(tls, h3) != 0 {
		return 5
	}
	return 2
}

// *
// Find all icosahedron faces intersected by a given H3 index, represented
// as integers from 0-19. The array is sparse; since 0 is a valid value,
// invalid array values are represented as -1. It is the responsibility of
// the caller to filter out invalid values.
//
// @param h3 The H3 index
// @param out Output array. Must be of size maxFaceCount(h3).
func Xh3GetFaces(tls *libc.TLS, h3 TH3Index, out uintptr) { /* h3Index.c:884:6: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	*(*int32)(unsafe.Pointer(bp + 16 /* res */)) = int32(h3 & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPentagon int32 = Xh3IsPentagon(tls, h3)

	// We can't use the vertex-based approach here for class II pentagons,
	// because all their vertices are on the icosahedron edges. Their
	// direct child pentagons cross the same faces, so use those instead.
	if isPentagon != 0 && !(XisResClassIII(tls, *(*int32)(unsafe.Pointer(bp + 16))) != 0) {
		// Note that this would not work for res 15, but this is only run on
		// Class II pentagons, it should never be invoked for a res 15 index.
		var childPentagon TH3Index = XmakeDirectChild(tls, h3, 0)
		Xh3GetFaces(tls, childPentagon, out)
		return
	}

	// convert to FaceIJK
	// var fijk TFaceIJK at bp, 16

	X_h3ToFaceIjk(tls, h3, bp)

	// Get all vertices as FaceIJK addresses. For simplicity, always
	// initialize the array with 6 verts, ignoring the last one for pentagons
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	var vertexCount int32

	if isPentagon != 0 {
		vertexCount = DNUM_PENT_VERTS
		X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)
	} else {
		vertexCount = DNUM_HEX_VERTS
		X_faceIjkToVerts(tls, bp, bp+16, bp+20)
	}

	// We may not use all of the slots in the output array,
	// so fill with invalid values to indicate unused slots
	var faceCount int32 = XmaxFaceCount(tls, h3)
	{
		var i int32 = 0
	__1:
		if !(i < faceCount) {
			goto __3
		}
		{
			*(*int32)(unsafe.Pointer(out + uintptr(i)*4)) = -1

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// add each vertex face, using the output array as a hash set
	{
		var i1 int32 = 0
	__4:
		if !(i1 < vertexCount) {
			goto __6
		}
		{
			var vert uintptr = bp + 20 + uintptr(i1)*16

			// Adjust overage, determining whether this vertex is
			// on another face
			if isPentagon != 0 {
				X_adjustPentVertOverage(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)))
			} else {
				X_adjustOverageClassII(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)), 0, 1)
			}

			// Save the face to the output array
			var face int32 = (*TFaceIJK)(unsafe.Pointer(vert)).Fface
			var pos int32 = 0
			// Find the first empty output position, or the first position
			// matching the current face
			for *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != -1 && *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != face {
				pos++
			}
			*(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) = face

		}
		goto __5
	__5:
		i1++
		goto __4
		goto __6
	__6:
	}
}

// *
// pentagonIndexCount returns the number of pentagons (same at any resolution)
//
// @return int count of pentagon indexes
func XpentagonIndexCount(tls *libc.TLS) int32 { /* h3Index.c:950:5: */
	return DNUM_PENTAGONS
}

// *
// Generates all pentagons at the specified resolution
//
// @param res The resolution to produce pentagons at.
// @param out Output array. Must be of size pentagonIndexCount().
func XgetPentagonIndexes(tls *libc.TLS, res int32, out uintptr) { /* h3Index.c:958:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32 = 0
	{
		var bc int32 = 0
	__1:
		if !(bc < DNUM_BASE_CELLS) {
			goto __3
		}
		{
			if X_isBaseCellPentagon(tls, bc) != 0 {
				// var pentagon TH3Index at bp, 8

				XsetH3Index(tls, bp, res, bc, uint32(0))
				*(*TH3Index)(unsafe.Pointer(out + uintptr(libc.PostIncInt32(&i, 1))*8)) = *(*TH3Index)(unsafe.Pointer(bp /* pentagon */))
			}

		}
		goto __2
	__2:
		bc++
		goto __1
		goto __3
	__3:
	}
}

// *
// Returns whether or not a resolution is a Class III grid. Note that odd
// resolutions are Class III and even resolutions are Class II.
// @param res The H3 resolution.
// @return 1 if the resolution is a Class III grid, and 0 if the resolution is
//         a Class II grid.
func XisResClassIII(tls *libc.TLS, res int32) int32 { /* h3Index.c:976:5: */
	return res % 2
}

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file  vertex.h
//  @brief Functions for working with cell vertexes.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

// Copyright 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lon.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// * @struct PentagonDirectionFaces
//  @brief  The faces in each axial direction of a given pentagon base cell
type TPentagonDirectionFaces = struct {
	FbaseCell int32
	Ffaces    [5]int32
} /* vertex.h:33:3 */

// *
// Returns whether or not the provided H3Indexes are neighbors.
// @param origin The origin H3 index.
// @param destination The destination H3 index.
// @return 1 if the indexes are neighbors, 0 otherwise;
func Xh3IndexesAreNeighbors(tls *libc.TLS, origin TH3Index, destination TH3Index) int32 { /* h3UniEdge.c:36:5: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// Make sure they're hexagon indexes
	if int32(origin&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_HEXAGON_MODE || int32(destination&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_HEXAGON_MODE {
		return 0
	}

	// Hexagons cannot be neighbors with themselves
	if origin == destination {
		return 0
	}

	// Only hexagons in the same resolution can be neighbors
	if int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) != int32(destination&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return 0
	}

	// H3 Indexes that share the same parent are very likely to be neighbors
	// Child 0 is neighbor with all of its parent's 'offspring', the other
	// children are neighbors with 3 of the 7 children. So a simple comparison
	// of origin and destination parents and then a lookup table of the children
	// is a super-cheap way to possibly determine they are neighbors.
	var parentRes int32 = int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	if parentRes > 0 && Xh3ToParent(tls, origin, parentRes) == Xh3ToParent(tls, destination, parentRes) {
		var originResDigit TDirection = TDirection(origin >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
		var destinationResDigit TDirection = TDirection(destination >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
		if originResDigit == CENTER_DIGIT || destinationResDigit == CENTER_DIGIT {
			return 1
		}
		// These sets are the relevant neighbors in the clockwise
		// and counter-clockwise
		*(*[7]TDirection)(unsafe.Pointer(bp /* neighborSetClockwise */)) = [7]TDirection{
			CENTER_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, J_AXES_DIGIT,
			IK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT}
		*(*[7]TDirection)(unsafe.Pointer(bp + 28 /* neighborSetCounterclockwise */)) = [7]TDirection{
			CENTER_DIGIT, IK_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT,
			IJ_AXES_DIGIT, I_AXES_DIGIT, J_AXES_DIGIT}
		if *(*TDirection)(unsafe.Pointer(bp + uintptr(originResDigit)*4)) == destinationResDigit || *(*TDirection)(unsafe.Pointer(bp + 28 + uintptr(originResDigit)*4)) == destinationResDigit {
			return 1
		}
	}

	// Otherwise, we have to determine the neighbor relationship the "hard" way.
	*(*[7]TH3Index)(unsafe.Pointer(bp + 56 /* neighborRing */)) = [7]TH3Index{0: uint64(0)}
	XkRing(tls, origin, 1, bp+56)
	{
		var i int32 = 0
	__1:
		if !(i < 7) {
			goto __3
		}
		{
			if *(*TH3Index)(unsafe.Pointer(bp + 56 + uintptr(i)*8)) == destination {
				return 1
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// Made it here, they definitely aren't neighbors
	return 0
}

// *
// Returns a unidirectional edge H3 index based on the provided origin and
// destination
// @param origin The origin H3 hexagon index
// @param destination The destination H3 hexagon index
// @return The unidirectional edge H3Index, or H3_NULL on failure.
func XgetH3UnidirectionalEdge(tls *libc.TLS, origin TH3Index, destination TH3Index) TH3Index { /* h3UniEdge.c:103:9: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// Short-circuit and return an invalid index value if they are not neighbors
	if Xh3IndexesAreNeighbors(tls, origin, destination) == 0 {
		return uint64(DH3_NULL)
	}

	// Otherwise, determine the IJK direction from the origin to the destination
	var output TH3Index = origin
	output = output&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_UNIEDGE_MODE))<<DH3_MODE_OFFSET

	var isPentagon uint8 = uint8(Xh3IsPentagon(tls, origin))

	// Checks each neighbor, in order, to determine which direction the
	// destination neighbor is located. Skips CENTER_DIGIT since that
	// would be this index.
	var neighbor TH3Index
	// Excluding from branch coverage as we never hit the end condition
	// LCOV_EXCL_BR_START
	{
		var direction TDirection
		if isPentagon != 0 {
			direction = J_AXES_DIGIT
		} else {
			direction = K_AXES_DIGIT
		}
	__1:
		if !(direction < NUM_DIGITS) {
			goto __3
		}
		{
			// LCOV_EXCL_BR_STOP
			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			neighbor = Xh3NeighborRotations(tls, origin, direction, bp)
			if neighbor == destination {
				output = output&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(direction)<<DH3_RESERVED_OFFSET
				return output
			}

		}
		goto __2
	__2:
		direction++
		goto __1
		goto __3
	__3:
	}

	// This should be impossible, return H3_NULL in this case;
	return uint64(DH3_NULL) // LCOV_EXCL_LINE
}

// *
// Returns the origin hexagon from the unidirectional edge H3Index
// @param edge The edge H3 index
// @return The origin H3 hexagon index, or H3_NULL on failure
func XgetOriginH3IndexFromUnidirectionalEdge(tls *libc.TLS, edge TH3Index) TH3Index { /* h3UniEdge.c:142:9: */
	if int32(edge&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_UNIEDGE_MODE {
		return uint64(DH3_NULL)
	}
	var origin TH3Index = edge
	origin = origin&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_HEXAGON_MODE))<<DH3_MODE_OFFSET
	origin = origin&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(uint64(0))<<DH3_RESERVED_OFFSET
	return origin
}

// *
// Returns the destination hexagon from the unidirectional edge H3Index
// @param edge The edge H3 index
// @return The destination H3 hexagon index, or H3_NULL on failure
func XgetDestinationH3IndexFromUnidirectionalEdge(tls *libc.TLS, edge TH3Index) TH3Index { /* h3UniEdge.c:157:9: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if int32(edge&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_UNIEDGE_MODE {
		return uint64(DH3_NULL)
	}
	var direction TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
	var destination TH3Index = Xh3NeighborRotations(tls,
		XgetOriginH3IndexFromUnidirectionalEdge(tls, edge), direction,
		bp)
	return destination
}

// *
// Determines if the provided H3Index is a valid unidirectional edge index
// @param edge The unidirectional edge H3Index
// @return 1 if it is a unidirectional edge H3Index, otherwise 0.
func Xh3UnidirectionalEdgeIsValid(tls *libc.TLS, edge TH3Index) int32 { /* h3UniEdge.c:174:5: */
	if int32(edge&(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_UNIEDGE_MODE {
		return 0
	}

	var neighborDirection TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	if neighborDirection <= CENTER_DIGIT || neighborDirection >= NUM_DIGITS {
		return 0
	}

	var origin TH3Index = XgetOriginH3IndexFromUnidirectionalEdge(tls, edge)
	if Xh3IsPentagon(tls, origin) != 0 && neighborDirection == K_AXES_DIGIT {
		return 0
	}

	return Xh3IsValid(tls, origin)
}

// *
// Returns the origin, destination pair of hexagon IDs for the given edge ID
// @param edge The unidirectional edge H3Index
// @param originDestination Pointer to memory to store origin and destination
// IDs
func XgetH3IndexesFromUnidirectionalEdge(tls *libc.TLS, edge TH3Index, originDestination uintptr) { /* h3UniEdge.c:198:6: */
	*(*TH3Index)(unsafe.Pointer(originDestination)) = XgetOriginH3IndexFromUnidirectionalEdge(tls, edge)
	*(*TH3Index)(unsafe.Pointer(originDestination + 1*8)) = XgetDestinationH3IndexFromUnidirectionalEdge(tls, edge)
}

// *
// Provides all of the unidirectional edges from the current H3Index.
// @param origin The origin hexagon H3Index to find edges for.
// @param edges The memory to store all of the edges inside.
func XgetH3UnidirectionalEdgesFromHexagon(tls *libc.TLS, origin TH3Index, edges uintptr) { /* h3UniEdge.c:211:6: */
	// Determine if the origin is a pentagon and special treatment needed.
	var isPentagon int32 = Xh3IsPentagon(tls, origin)

	// This is actually quite simple. Just modify the bits of the origin
	// slightly for each direction, except the 'k' direction in pentagons,
	// which is zeroed.
	{
		var i int32 = 0
	__1:
		if !(i < 6) {
			goto __3
		}
		{
			if isPentagon != 0 && i == 0 {
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = uint64(DH3_NULL)
			} else {
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = origin
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_UNIEDGE_MODE))<<DH3_MODE_OFFSET
				*(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*TH3Index)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(Tuint64_t(uint64(7))<<DH3_RESERVED_OFFSET) | Tuint64_t(i+1)<<DH3_RESERVED_OFFSET
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// *
// Provides the coordinates defining the unidirectional edge.
// @param edge The unidirectional edge H3Index
// @param gb The geoboundary object to store the edge coordinates.
func XgetH3UnidirectionalEdgeBoundary(tls *libc.TLS, edge TH3Index, gb uintptr) { /* h3UniEdge.c:235:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Get the origin and neighbor direction from the edge
	var direction TDirection = TDirection(int32(edge & (Tuint64_t(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	var origin TH3Index = XgetOriginH3IndexFromUnidirectionalEdge(tls, edge)

	// Get the start vertex for the edge
	var startVertex int32 = XvertexNumForDirection(tls, origin, direction)
	if startVertex == -1 {
		// This is not actually an edge (i.e. no valid direction),
		// so return no vertices.
		(*TGeoBoundary)(unsafe.Pointer(gb)).FnumVerts = 0
		return
	}

	// Get the geo boundary for the appropriate vertexes of the origin. Note
	// that while there are always 2 topological vertexes per edge, the
	// resulting edge boundary may have an additional distortion vertex if it
	// crosses an edge of the icosahedron.
	// var fijk TFaceIJK at bp, 16

	X_h3ToFaceIjk(tls, origin, bp)
	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPentagon int32 = Xh3IsPentagon(tls, origin)

	if isPentagon != 0 {
		X_faceIjkPentToGeoBoundary(tls, bp, res, startVertex, 2, gb)
	} else {
		X_faceIjkToGeoBoundary(tls, bp, res, startVertex, 2, gb)
	}
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// *
// Add a linked polygon to the current polygon
// @param  polygon Polygon to add link to
// @return         Pointer to new polygon
func XaddNewLinkedPolygon(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:34:17: */
	if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext == uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+229, ts+251, uint32(35), uintptr(unsafe.Pointer(&__func__3)))
	}
	var next uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoPolygon{})))
	if next != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+280, ts+251, uint32(37), uintptr(unsafe.Pointer(&__func__3)))
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext = next
	return next
}

var __func__3 = *(*[20]uint8)(unsafe.Pointer(ts + 293)) /* linkedGeo.c:34:66 */

// *
// Add a new linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddNewLinkedLoop(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:47:14: */
	var loop uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoLoop{})))
	if loop != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+313, ts+251, uint32(49), uintptr(unsafe.Pointer(&__func__4)))
	}
	return XaddLinkedLoop(tls, polygon, loop)
}

var __func__4 = *(*[17]uint8)(unsafe.Pointer(ts + 326)) /* linkedGeo.c:47:60 */

// *
// Add an existing linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddLinkedLoop(tls *libc.TLS, polygon uintptr, loop uintptr) uintptr { /* linkedGeo.c:58:14: */
	var last uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+343, ts+251, uint32(61), uintptr(unsafe.Pointer(&__func__5)))
		}
		(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst = loop
	} else {
		(*TLinkedGeoLoop)(unsafe.Pointer(last)).Fnext = loop
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast = loop
	return loop
}

var __func__5 = *(*[14]uint8)(unsafe.Pointer(ts + 366)) /* linkedGeo.c:58:78 */

// *
// Add a new linked coordinate to the current loop
// @param  loop   Loop to add coordinate to
// @param  vertex Coordinate to add
// @return        Pointer to the coordinate
func XaddLinkedCoord(tls *libc.TLS, loop uintptr, vertex uintptr) uintptr { /* linkedGeo.c:76:15: */
	var coord uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TLinkedGeoCoord{})))
	if coord != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+380, ts+251, uint32(78), uintptr(unsafe.Pointer(&__func__6)))
	}
	*(*TLinkedGeoCoord)(unsafe.Pointer(coord)) = TLinkedGeoCoord{Fvertex: *(*TGeoCoord)(unsafe.Pointer(vertex))}
	var last uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+394, ts+251, uint32(82), uintptr(unsafe.Pointer(&__func__6)))
		}
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst = coord
	} else {
		(*TLinkedGeoCoord)(unsafe.Pointer(last)).Fnext = coord
	}
	(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast = coord
	return coord
}

var __func__6 = *(*[15]uint8)(unsafe.Pointer(ts + 414)) /* linkedGeo.c:76:77 */

// *
// Free all allocated memory for a linked geo loop. The caller is
// responsible for freeing memory allocated to input loop struct.
// @param loop Loop to free
func XdestroyLinkedGeoLoop(tls *libc.TLS, loop uintptr) { /* linkedGeo.c:96:6: */
	var nextCoord uintptr
	{
		var currentCoord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
	__1:
		if !(currentCoord != uintptr(0)) {
			goto __3
		}
		{
			nextCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
			libc.Xfree(tls, currentCoord)

		}
		goto __2
	__2:
		currentCoord = nextCoord
		goto __1
		goto __3
	__3:
	}
}

// *
// Free all allocated memory for a linked geo structure. The caller is
// responsible for freeing memory allocated to input polygon struct.
// @param polygon Pointer to the first polygon in the structure
func XdestroyLinkedPolygon(tls *libc.TLS, polygon uintptr) { /* linkedGeo.c:110:6: */
	// flag to skip the input polygon
	var skip uint8 = uint8(Dtrue)
	var nextPolygon uintptr
	var nextLoop uintptr
	{
		var currentPolygon uintptr = polygon
	__1:
		if !(currentPolygon != uintptr(0)) {
			goto __3
		}
		{
			{
				var currentLoop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Ffirst
			__4:
				if !(currentLoop != uintptr(0)) {
					goto __6
				}
				{
					XdestroyLinkedGeoLoop(tls, currentLoop)
					nextLoop = (*TLinkedGeoLoop)(unsafe.Pointer(currentLoop)).Fnext
					libc.Xfree(tls, currentLoop)

				}
				goto __5
			__5:
				currentLoop = nextLoop
				goto __4
				goto __6
			__6:
			}
			nextPolygon = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Fnext
			if skip != 0 {
				// do not free the input polygon
				skip = uint8(Dfalse)
			} else {
				libc.Xfree(tls, currentPolygon)
			}

		}
		goto __2
	__2:
		currentPolygon = nextPolygon
		goto __1
		goto __3
	__3:
	}
}

// *
// Count the number of polygons in a linked list
// @param  polygon Starting polygon
// @return         Count
func XcountLinkedPolygons(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:138:5: */
	var count int32 = 0
	for polygon != uintptr(0) {
		count++
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
	}
	return count
}

// *
// Count the number of linked loops in a polygon
// @param  polygon Polygon to count loops for
// @return         Count
func XcountLinkedLoops(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:152:5: */
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst
	var count int32 = 0
	for loop != uintptr(0) {
		count++
		loop = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
	}
	return count
}

// *
// Count the number of coordinates in a loop
// @param  loop Loop to count coordinates for
// @return      Count
func XcountLinkedCoords(tls *libc.TLS, loop uintptr) int32 { /* linkedGeo.c:167:5: */
	var coord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
	var count int32 = 0
	for coord != uintptr(0) {
		count++
		coord = (*TLinkedGeoCoord)(unsafe.Pointer(coord)).Fnext
	}
	return count
}

// *
// Count the number of polygons containing a given loop.
// @param  loop         Loop to count containers for
// @param  polygons     Polygons to test
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the test array
// @return              Number of polygons containing the loop
func countContainers(tls *libc.TLS, loop uintptr, polygons uintptr, bboxes uintptr, polygonCount int32) int32 { /* linkedGeo.c:185:12: */
	var containerCount int32 = 0
	{
		var i int32 = 0
	__1:
		if !(i < polygonCount) {
			goto __3
		}
		{
			if loop != (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst && XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, *(*uintptr)(unsafe.Pointer(bboxes + uintptr(i)*8)),
				(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
				containerCount++
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return containerCount
}

// *
// Given a list of nested containers, find the one most deeply nested.
// @param  polygons     Polygon containers to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the list
// @return              Deepest container, or null if list is empty
func findDeepestContainer(tls *libc.TLS, polygons uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:206:30: */
	// Set the initial return value to the first candidate
	var parent uintptr
	if polygonCount > 0 {
		parent = *(*uintptr)(unsafe.Pointer(polygons))
	} else {
		parent = uintptr(0)
	}

	// If we have multiple polygons, they must be nested inside each other.
	// Find the innermost polygon by taking the one with the most containers
	// in the list.
	if polygonCount > 1 {
		var max int32 = -1
		{
			var i int32 = 0
		__1:
			if !(i < polygonCount) {
				goto __3
			}
			{
				var count int32 = countContainers(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, polygons, bboxes,
					polygonCount)
				if count > max {
					parent = *(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8))
					max = count
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
		}
	}

	return parent
}

// *
// Find the polygon to which a given hole should be allocated. Note that this
// function will return null if no parent is found.
// @param  loop         Inner loop describing a hole
// @param  polygon      Head of a linked list of polygons to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons to check
// @return              Pointer to parent polygon, or null if not found
func findPolygonForHole(tls *libc.TLS, loop uintptr, polygon uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:239:30: */
	// Early exit with no polygons
	if polygonCount == 0 {
		return uintptr(0)
	}
	// Initialize arrays for candidate loops and their bounding boxes
	var candidates uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidates != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+429, ts+251, uint32(249), uintptr(unsafe.Pointer(&__func__7)))
	}
	var candidateBBoxes uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidateBBoxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+448, ts+251, uint32(252), uintptr(unsafe.Pointer(&__func__7)))
	}

	// Find all polygons that contain the loop
	var candidateCount int32 = 0
	var index int32 = 0
	for polygon != 0 {
		// We are guaranteed not to overlap, so just test the first point
		if XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst, bboxes+uintptr(index)*32,
			(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
			*(*uintptr)(unsafe.Pointer(candidates + uintptr(candidateCount)*8)) = polygon
			*(*uintptr)(unsafe.Pointer(candidateBBoxes + uintptr(candidateCount)*8)) = bboxes + uintptr(index)*32
			candidateCount++
		}
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
		index++
	}

	// The most deeply nested container is the immediate parent
	var parent uintptr = findDeepestContainer(tls, candidates, candidateBBoxes, candidateCount)

	// Free allocated memory
	libc.Xfree(tls, candidates)
	libc.Xfree(tls, candidateBBoxes)

	return parent
}

var __func__7 = *(*[19]uint8)(unsafe.Pointer(ts + 472)) /* linkedGeo.c:241:49 */

// *
// Normalize a LinkedGeoPolygon in-place into a structure following GeoJSON
// MultiPolygon rules: Each polygon must have exactly one outer loop, which
// must be first in the list, followed by any holes. Holes in this algorithm
// are identified by winding order (holes are clockwise), which is guaranteed
// by the h3SetToVertexGraph algorithm.
//
// Input to this function is assumed to be a single polygon including all
// loops to normalize. It's assumed that a valid arrangement is possible.
//
// @param root Root polygon including all loops
// @return     0 on success, or an error code > 0 for invalid input
func XnormalizeMultiPolygon(tls *libc.TLS, root uintptr) int32 { /* linkedGeo.c:293:5: */
	// We assume that the input is a single polygon with loops;
	// if it has multiple polygons, don't touch it
	if (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Fnext != 0 {
		return DNORMALIZATION_ERR_MULTIPLE_POLYGONS
	}

	// Count loops, exiting early if there's only one
	var loopCount int32 = XcountLinkedLoops(tls, root)
	if loopCount <= 1 {
		return DNORMALIZATION_SUCCESS
	}

	var resultCode int32 = DNORMALIZATION_SUCCESS
	var polygon uintptr = uintptr(0)
	var next uintptr
	var innerCount int32 = 0
	var outerCount int32 = 0

	// Create an array to hold all of the inner loops. Note that
	// this array will never be full, as there will always be fewer
	// inner loops than outer loops.
	var innerLoops uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if innerLoops != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+491, ts+251, uint32(317), uintptr(unsafe.Pointer(&__func__8)))
	}

	// Create an array to hold the bounding boxes for the outer loops
	var bboxes uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(TBBox{})))
	if bboxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts, ts+251, uint32(321), uintptr(unsafe.Pointer(&__func__8)))
	}

	// Get the first loop and unlink it from root
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Ffirst
	*(*TLinkedGeoPolygon)(unsafe.Pointer(root)) = TLinkedGeoPolygon{}

	// Iterate over all loops, moving inner loops into an array and
	// assigning outer loops to new polygons
	for loop != 0 {
		if XisClockwiseLinkedGeoLoop(tls, loop) != 0 {
			*(*uintptr)(unsafe.Pointer(innerLoops + uintptr(innerCount)*8)) = loop
			innerCount++
		} else {
			if polygon == uintptr(0) {
				polygon = root
			} else {
				polygon = XaddNewLinkedPolygon(tls, polygon)
			}
			XaddLinkedLoop(tls, polygon, loop)
			XbboxFromLinkedGeoLoop(tls, loop, bboxes+uintptr(outerCount)*32)
			outerCount++
		}
		// get the next loop and unlink it from this one
		next = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext = uintptr(0)
		loop = next
	}

	// Find polygon for each inner loop and assign the hole to it
	{
		var i int32 = 0
	__1:
		if !(i < innerCount) {
			goto __3
		}
		{
			polygon = findPolygonForHole(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)), root,
				bboxes, outerCount)
			if polygon != 0 {
				XaddLinkedLoop(tls, polygon, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
			} else {
				// If we can't find a polygon (possible with invalid input), then
				// we need to release the memory for the hole, because the loop has
				// been unlinked from the root and the caller will no longer have
				// a way to destroy it with destroyLinkedPolygon.
				XdestroyLinkedGeoLoop(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				resultCode = DNORMALIZATION_ERR_UNASSIGNED_HOLES
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	// Free allocated memory
	libc.Xfree(tls, innerLoops)
	libc.Xfree(tls, bboxes)

	return resultCode
}

var __func__8 = *(*[22]uint8)(unsafe.Pointer(ts + 510)) /* linkedGeo.c:293:51 */

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TGeoCoord)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TGeoCoord)(unsafe.Pointer(coord)).Flon < float64(0) {
			return (*TGeoCoord)(unsafe.Pointer(coord)).Flon + 6.28318530717958647692528676655900576839433
		}
		return (*TGeoCoord)(unsafe.Pointer(coord)).Flon
	}()
	var a TGeoCoord
	var b TGeoCoord

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedGeoCoord)(unsafe.Pointer(nextCoord)).Fvertex

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flon < float64(0) {
				return a.Flon + 6.28318530717958647692528676655900576839433
			}
			return a.Flon
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flon < float64(0) {
				return b.Flon + 6.28318530717958647692528676655900576839433
			}
			return b.Flon
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
// - Does not support polygons with two adjacent points > 180 degrees of
//   longitude apart. These will be interpreted as crossing the antimeridian.
// - Does not currently support polygons containing a pole.
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:137:6: */
	// Early exit if there are no vertices
	if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLon float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLon float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lon float64
	var coord TGeoCoord
	var next TGeoCoord

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		coord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		next = (*TLinkedGeoCoord)(unsafe.Pointer(nextCoord)).Fvertex

		lat = coord.Flat
		lon = coord.Flon
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lon < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lon
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lon > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lon
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lon > float64(0) && lon < minPosLon {
			minPosLon = lon
		}
		if lon < float64(0) && lon > maxNegLon {
			maxNegLon = lon
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lon-next.Flon) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLon
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLon
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedLinkedGeoLoop(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:191:13: */
	var sum float64 = float64(0)
	var a TGeoCoord
	var b TGeoCoord

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)
	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedGeoCoord)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedGeoCoord)(unsafe.Pointer(nextCoord)).Fvertex
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flon-b.Flon) > 3.14159265358979323846 {
			return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flon < float64(0) {
				return b.Flon + 6.28318530717958647692528676655900576839433
			}
			return b.Flon
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flon < float64(0) {
				return a.Flon + 6.28318530717958647692528676655900576839433
			}
			return a.Flon
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseLinkedGeoLoop(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:219:6: */
	return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dfalse))
}

// *
// Origin leading digit -> index leading digit -> rotations 60 cw
// Either being 1 (K axis) is invalid.
// No good default at 0.
var XPENTAGON_ROTATIONS = [7][7]int32{
	{0, -1, 0, 0, 0, 0, 0},       // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, -1, 0, 0, 0, 1, 0},       // 2
	{0, -1, 0, 0, 1, 1, 0},       // 3
	{0, -1, 0, 5, 0, 0, 0},       // 4
	{0, -1, 5, 5, 0, 0, 0},       // 5
	{0, -1, 0, 0, 0, 0, 0},       // 6
} /* localij.c:38:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when
// the origin is on a pentagon (regardless of the base cell of the index.)
var XPENTAGON_ROTATIONS_REVERSE = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 5, 0, 5, 0, 0, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:52:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_NONPOLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:66:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a polar pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_POLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 1, 1, 1, 1, 1},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 1, 0, 0, 1, 1, 1},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 1, 1, 0, 1, 1, 1},        // 6
} /* localij.c:80:11 */

// *
// Prohibited directions when unfolding a pentagon.
//
// Indexes by two directions, both relative to the pentagon base cell. The first
// is the direction of the origin index and the second is the direction of the
// index to unfold. Direction refers to the direction from base cell to base
// cell if the indexes are on different base cells, or the leading digit if
// within the pentagon base cell.
//
// This previously included a Class II/Class III check but these were removed
// due to failure cases. It's possible this could be restricted to a narrower
// set of a failure cases. Currently, the logic is any unfolding across more
// than one icosahedron face is not permitted.
var XFAILED_DIRECTIONS = [7][7]uint8{
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 0
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 1
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse)},   // 2
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue)},   // 3
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)},   // 4
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue)},   // 5
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse)},   // 6
} /* localij.c:104:12 */

// *
// Produces ijk+ coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param index Index to find the coordinates of
// @param out ijk+ coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func Xh3ToLocalIjk(tls *libc.TLS, origin TH3Index, h3 TH3Index, out uintptr) int32 { /* localij.c:131:5: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if res != int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return 1
	}

	var originBaseCell int32 = int32(origin & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	var baseCell int32 = int32(h3 & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)

	// Direction from origin base cell to index base cell
	var dir TDirection = CENTER_DIGIT
	var revDir TDirection = CENTER_DIGIT
	if originBaseCell != baseCell {
		dir = X_getBaseCellDirection(tls, originBaseCell, baseCell)
		if dir == INVALID_DIGIT {
			// Base cells are not neighbors, can't unfold.
			return 2
		}
		revDir = X_getBaseCellDirection(tls, baseCell, originBaseCell)
		if revDir != INVALID_DIGIT {
		} else {
			libc.X__assert_fail(tls, ts+532, ts+556, uint32(151), uintptr(unsafe.Pointer(&__func__9)))
		}
	}

	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)
	var indexOnPent int32 = X_isBaseCellPentagon(tls, baseCell)

	*(*TFaceIJK)(unsafe.Pointer(bp /* indexFijk */)) = TFaceIJK{}
	if dir != CENTER_DIGIT {
		// Rotate index into the orientation of the origin base cell.
		// cw because we are undoing the rotation into that base cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if indexOnPent != 0 {
			{
				var i int32 = 0
			__1:
				if !(i < baseCellRotations) {
					goto __3
				}
				{
					h3 = X_h3RotatePent60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)
					if revDir == K_AXES_DIGIT {
						revDir = X_rotate60cw(tls, revDir)
					}

				}
				goto __2
			__2:
				i++
				goto __1
				goto __3
			__3:
			}
		} else {
			{
				var i int32 = 0
			__4:
				if !(i < baseCellRotations) {
					goto __6
				}
				{
					h3 = X_h3Rotate60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)

				}
				goto __5
			__5:
				i++
				goto __4
				goto __6
			__6:
			}
		}
	}
	// Face is unused. This produces coordinates in base cell coordinate space.
	X_h3ToFaceIjkWithInitializedFijk(tls, h3, bp)

	if dir != CENTER_DIGIT {
		if baseCell != originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+583, ts+556, uint32(181), uintptr(unsafe.Pointer(&__func__9)))
		}
		if !(originOnPent != 0 && indexOnPent != 0) {
		} else {
			libc.X__assert_fail(tls, ts+610, ts+556, uint32(182), uintptr(unsafe.Pointer(&__func__9)))
		}

		var pentagonRotations int32 = 0
		var directionRotations int32 = 0

		if originOnPent != 0 {
			var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))

			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(dir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return 3
			}

			directionRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			pentagonRotations = directionRotations
		} else if indexOnPent != 0 {
			var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(indexLeadingDigit)*7 + uintptr(revDir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return 4
			}

			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
		}

		if pentagonRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+641, ts+556, uint32(212), uintptr(unsafe.Pointer(&__func__9)))
		}
		if directionRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+664, ts+556, uint32(213), uintptr(unsafe.Pointer(&__func__9)))
		}

		{
			var i int32 = 0
		__7:
			if !(i < pentagonRotations) {
				goto __9
			}
			{
				X_ijkRotate60cw(tls, bp+4)

			}
			goto __8
		__8:
			i++
			goto __7
			goto __9
		__9:
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* offset */)) = TCoordIJK{}
		X_neighbor(tls, bp+16, dir)
		// Scale offset based on resolution
		{
			var r int32 = res - 1
		__10:
			if !(r >= 0) {
				goto __12
			}
			{
				if XisResClassIII(tls, r+1) != 0 {
					// rotate ccw
					X_downAp7(tls, bp+16)
				} else {
					// rotate cw
					X_downAp7r(tls, bp+16)
				}

			}
			goto __11
		__11:
			r--
			goto __10
			goto __12
		__12:
		}

		{
			var i1 int32 = 0
		__13:
			if !(i1 < directionRotations) {
				goto __15
			}
			{
				X_ijkRotate60cw(tls, bp+16)

			}
			goto __14
		__14:
			i1++
			goto __13
			goto __15
		__15:
		}

		// Perform necessary translation
		X_ijkAdd(tls, bp+4, bp+16, bp+4)
		X_ijkNormalize(tls, bp+4)
	} else if originOnPent != 0 && indexOnPent != 0 {
		// If the origin and index are on pentagon, and we checked that the base
		// cells are the same or neighboring, then they must be the same base
		// cell.
		if baseCell == originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+688, ts+556, uint32(243), uintptr(unsafe.Pointer(&__func__9)))
		}

		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(indexLeadingDigit))) != 0 {
			// TODO: We may be unfolding the pentagon incorrectly in this case;
			// return an error code until this is guaranteed to be correct.
			return 5
		}

		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))

		{
			var i int32 = 0
		__16:
			if !(i < withinPentagonRotations) {
				goto __18
			}
			{
				X_ijkRotate60cw(tls, bp+4)

			}
			goto __17
		__17:
			i++
			goto __16
			goto __18
		__18:
		}
	}

	*(*TCoordIJK)(unsafe.Pointer(out)) = (*TFaceIJK)(unsafe.Pointer(bp /* &indexFijk */)).Fcoord
	return 0
}

var __func__9 = *(*[13]uint8)(unsafe.Pointer(ts + 715)) /* localij.c:131:61 */

// *
// Produces an index for ijk+ coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the coordinates are too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param ijk IJK+ Coordinates to find the index of
// @param out The index will be placed here on success
// @return 0 on success, or another value on failure.
func XlocalIjkToH3(tls *libc.TLS, origin TH3Index, ijk uintptr, out uintptr) int32 { /* localij.c:280:5: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var originBaseCell int32 = int32(origin & (Tuint64_t(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)

	// This logic is very similar to faceIjkToH3
	// initialize the index
	*(*TH3Index)(unsafe.Pointer(out)) = 35184372088831
	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(15))<<DH3_MODE_OFFSET) | Tuint64_t(uint64(DH3_HEXAGON_MODE))<<DH3_MODE_OFFSET
	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | Tuint64_t(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi > 1 || (*TCoordIJK)(unsafe.Pointer(ijk)).Fj > 1 || (*TCoordIJK)(unsafe.Pointer(ijk)).Fk > 1 {
			// out of range input
			return 1
		}

		var dir TDirection = X_unitIjkToDigit(tls, ijk)
		var newBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
		if newBaseCell == DINVALID_BASE_CELL {
			// Moving in an invalid direction off a pentagon.
			return 1
		}
		*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(newBaseCell)<<DH3_BC_OFFSET
		return 0
	}

	// we need to find the correct base cell offset (if any) for this H3 index;
	// start with the passed in base cell and resolution res ijk coordinates
	// in that base cell's coordinate system
	*(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	{
		var r int32 = res - 1
	__1:
		if !(r >= 0) {
			goto __3
		}
		{
			*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
			// var lastCenter TCoordIJK at bp+12, 12

			if XisResClassIII(tls, r+1) != 0 {
				// rotate ccw
				X_upAp7(tls, bp)
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7(tls, bp+12)
			} else {
				// rotate cw
				X_upAp7r(tls, bp)
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7r(tls, bp+12)
			}
			// var diff TCoordIJK at bp+36, 12

			X_ijkSub(tls, bp+24, bp+12, bp+36)
			X_ijkNormalize(tls, bp+36)

			*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out)) & ^(Tuint64_t(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | Tuint64_t(X_unitIjkToDigit(tls, bp+36))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)

		}
		goto __2
	__2:
		r--
		goto __1
		goto __3
	__3:
	}

	// ijkCopy should now hold the IJK of the base cell in the
	// coordinate system of the current base cell

	if (*TCoordIJK)(unsafe.Pointer(bp)).Fi > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fj > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fk > 1 {
		// out of range input
		return 2
	}

	// lookup the correct base cell
	var dir TDirection = X_unitIjkToDigit(tls, bp)
	var baseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
	// If baseCell is invalid, it must be because the origin base cell is a
	// pentagon, and because pentagon base cells do not border each other,
	// baseCell must not be a pentagon.
	var indexOnPent int32 = func() int32 {
		if baseCell == DINVALID_BASE_CELL {
			return 0
		}
		return X_isBaseCellPentagon(tls, baseCell)
	}()

	if dir != CENTER_DIGIT {
		// If the index is in a warped direction, we need to unwarp the base
		// cell direction. There may be further need to rotate the index digits.
		var pentagonRotations int32 = 0
		if originOnPent != 0 {
			var originLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, origin)
			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			{
				var i int32 = 0
			__4:
				if !(i < pentagonRotations) {
					goto __6
				}
				{
					dir = X_rotate60ccw(tls, dir)

				}
				goto __5
			__5:
				i++
				goto __4
				goto __6
			__6:
			}
			// The pentagon rotations are being chosen so that dir is not the
			// deleted direction. If it still happens, it means we're moving
			// into a deleted subsequence, so there is no index here.
			if dir == K_AXES_DIGIT {
				return 3
			}
			baseCell = X_getBaseCellNeighbor(tls, originBaseCell, dir)

			// indexOnPent does not need to be checked again since no pentagon
			// base cells border each other.
			if baseCell != DINVALID_BASE_CELL {
			} else {
				libc.X__assert_fail(tls, ts+728, ts+556, uint32(376), uintptr(unsafe.Pointer(&__func__10)))
			}
			if !(X_isBaseCellPentagon(tls, baseCell) != 0) {
			} else {
				libc.X__assert_fail(tls, ts+758, ts+556, uint32(377), uintptr(unsafe.Pointer(&__func__10)))
			}
		}

		// Now we can determine the relation between the origin and target base
		// cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if baseCellRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+789, ts+556, uint32(384), uintptr(unsafe.Pointer(&__func__10)))
		}

		// Adjust for pentagon warping within the base cell. The base cell
		// should be in the right location, so now we need to rotate the index
		// back. We might not need to check for errors since we would just be
		// double mapping.
		if indexOnPent != 0 {
			var revDir TDirection = X_getBaseCellDirection(tls, baseCell, originBaseCell)
			if revDir != INVALID_DIGIT {
			} else {
				libc.X__assert_fail(tls, ts+532, ts+556, uint32(393), uintptr(unsafe.Pointer(&__func__10)))
			}

			// Adjust for the different coordinate space in the two base cells.
			// This is done first because we need to do the pentagon rotations
			// based on the leading digit in the pentagon's coordinate system.
			{
				var i int32 = 0
			__7:
				if !(i < baseCellRotations) {
					goto __9
				}
				{
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))

				}
				goto __8
			__8:
				i++
				goto __7
				goto __9
			__9:
			}

			var indexLeadingDigit TDirection = X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out)))
			if X_isBaseCellPolarPentagon(tls, baseCell) != 0 {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_POLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			} else {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_NONPOLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			}

			if pentagonRotations >= 0 {
			} else {
				libc.X__assert_fail(tls, ts+641, ts+556, uint32(412), uintptr(unsafe.Pointer(&__func__10)))
			}
			{
				var i1 int32 = 0
			__10:
				if !(i1 < pentagonRotations) {
					goto __12
				}
				{
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3RotatePent60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))

				}
				goto __11
			__11:
				i1++
				goto __10
				goto __12
			__12:
			}
		} else {
			if pentagonRotations >= 0 {
			} else {
				libc.X__assert_fail(tls, ts+641, ts+556, uint32(417), uintptr(unsafe.Pointer(&__func__10)))
			}
			{
				var i int32 = 0
			__13:
				if !(i < pentagonRotations) {
					goto __15
				}
				{
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))

				}
				goto __14
			__14:
				i++
				goto __13
				goto __15
			__15:
			}

			// Adjust for the different coordinate space in the two base cells.
			{
				var i1 int32 = 0
			__16:
				if !(i1 < baseCellRotations) {
					goto __18
				}
				{
					*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))

				}
				goto __17
			__17:
				i1++
				goto __16
				goto __18
			__18:
			}
		}
	} else if originOnPent != 0 && indexOnPent != 0 {
		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out))))

		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))
		if withinPentagonRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+812, ts+556, uint32(433), uintptr(unsafe.Pointer(&__func__10)))
		}

		{
			var i int32 = 0
		__19:
			if !(i < withinPentagonRotations) {
				goto __21
			}
			{
				*(*TH3Index)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*TH3Index)(unsafe.Pointer(out)))

			}
			goto __20
		__20:
			i++
			goto __19
			goto __21
		__21:
		}
	}

	if indexOnPent != 0 {
		// TODO: There are cases in h3ToLocalIjk which are failed but not
		// accounted for here - instead just fail if the recovered index is
		// invalid.
		if X_h3LeadingNonZeroDigit(tls, *(*TH3Index)(unsafe.Pointer(out))) == K_AXES_DIGIT {
			return 4
		}
	}

	*(*TH3Index)(unsafe.Pointer(out)) = *(*TH3Index)(unsafe.Pointer(out))&libc.CplUint64(Tuint64_t(uint64(127))<<DH3_BC_OFFSET) | Tuint64_t(baseCell)<<DH3_BC_OFFSET
	return 0
}

var __func__10 = *(*[13]uint8)(unsafe.Pointer(ts + 841)) /* localij.c:280:69 */

// *
// Produces ij coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function is experimental, and its output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param index Index to find the coordinates of
// @param out ij coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func XexperimentalH3ToLocalIj(tls *libc.TLS, origin TH3Index, h3 TH3Index, out uintptr) int32 { /* localij.c:473:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// This function is currently experimental. Once ready to be part of the
	// non-experimental API, this function (with the experimental prefix) will
	// be marked as deprecated and to be removed in the next major version. It
	// will be replaced with a non-prefixed function name.
	// var ijk TCoordIJK at bp, 12

	var failed int32 = Xh3ToLocalIjk(tls, origin, h3, bp)
	if failed != 0 {
		return failed
	}

	XijkToIj(tls, bp, out)

	return 0
}

// *
// Produces an index for ij coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function is experimental, and its output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param out ij coordinates to index.
// @param index Index will be placed here on success.
// @return 0 on success, or another value on failure.
func XexperimentalLocalIjToH3(tls *libc.TLS, origin TH3Index, ij uintptr, out uintptr) int32 { /* localij.c:507:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// This function is currently experimental. Once ready to be part of the
	// non-experimental API, this function (with the experimental prefix) will
	// be marked as deprecated and to be removed in the next major version. It
	// will be replaced with a non-prefixed function name.
	// var ijk TCoordIJK at bp, 12

	XijToIjk(tls, ij, bp)

	return XlocalIjkToH3(tls, origin, bp, out)
}

// *
// Produces the grid distance between the two indexes.
//
// This function may fail to find the distance between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// @param origin Index to find the distance from.
// @param index Index to find the distance to.
// @return The distance, or a negative number if the library could not
// compute the distance.
func Xh3Distance(tls *libc.TLS, origin TH3Index, h3 TH3Index) int32 { /* localij.c:531:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var originIjk TCoordIJK at bp, 12

	// var h3Ijk TCoordIJK at bp+12, 12

	if Xh3ToLocalIjk(tls, origin, origin, bp) != 0 {
		// Currently there are no tests that would cause getting the coordinates
		// for an index the same as the origin to fail.
		return -1 // LCOV_EXCL_LINE
	}
	if Xh3ToLocalIjk(tls, origin, h3, bp+12) != 0 {
		return -1
	}

	return XijkDistance(tls, bp, bp+12)
}

// *
// Number of indexes in a line from the start index to the end index,
// to be used for allocating memory. Returns a negative number if the
// line cannot be computed.
//
// @param start Start index of the line
// @param end End index of the line
// @return Size of the line, or a negative number if the line cannot
// be computed.
func Xh3LineSize(tls *libc.TLS, start TH3Index, end TH3Index) int32 { /* localij.c:555:5: */
	var distance int32 = Xh3Distance(tls, start, end)
	if distance >= 0 {
		return distance + 1
	}
	return distance
}

// *
// Given cube coords as doubles, round to valid integer coordinates. Algorithm
// from https://www.redblobgames.com/grids/hexagons/#rounding
// @param i   Floating-point I coord
// @param j   Floating-point J coord
// @param k   Floating-point K coord
// @param ijk IJK coord struct, modified in place
func cubeRound(tls *libc.TLS, i float64, j float64, k float64, ijk uintptr) { /* localij.c:568:13: */
	var ri int32 = libc.Int32FromFloat64(libc.Xround(tls, i))
	var rj int32 = libc.Int32FromFloat64(libc.Xround(tls, j))
	var rk int32 = libc.Int32FromFloat64(libc.Xround(tls, k))

	var iDiff float64 = libc.Xfabs(tls, float64(ri)-i)
	var jDiff float64 = libc.Xfabs(tls, float64(rj)-j)
	var kDiff float64 = libc.Xfabs(tls, float64(rk)-k)

	// Round, maintaining valid cube coords
	if iDiff > jDiff && iDiff > kDiff {
		ri = -rj - rk
	} else if jDiff > kDiff {
		rj = -ri - rk
	} else {
		rk = -ri - rj
	}

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = ri
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = rj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = rk
}

// *
// Given two H3 indexes, return the line of indexes between them (inclusive).
//
// This function may fail to find the line between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// Notes:
//
//  - The specific output of this function should not be considered stable
//    across library versions. The only guarantees the library provides are
//    that the line length will be `h3Distance(start, end) + 1` and that
//    every index in the line will be a neighbor of the preceding index.
//  - Lines are drawn in grid space, and may not correspond exactly to either
//    Cartesian lines or great arcs.
//
// @param start Start index of the line
// @param end End index of the line
// @param out Output array, which must be of size h3LineSize(start, end)
// @return 0 on success, or another value on failure.
func Xh3Line(tls *libc.TLS, start TH3Index, end TH3Index, out uintptr) int32 { /* localij.c:612:5: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var distance int32 = Xh3Distance(tls, start, end)
	// Early exit if we can't calculate the line
	if distance < 0 {
		return distance
	}

	// Get IJK coords for the start and end. We've already confirmed
	// that these can be calculated with the distance check above.
	*(*TCoordIJK)(unsafe.Pointer(bp /* startIjk */)) = TCoordIJK{}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* endIjk */)) = TCoordIJK{}

	// Convert H3 addresses to IJK coords
	Xh3ToLocalIjk(tls, start, start, bp)
	Xh3ToLocalIjk(tls, start, end, bp+12)

	// Convert IJK to cube coordinates suitable for linear interpolation
	XijkToCube(tls, bp)
	XijkToCube(tls, bp+12)

	var iStep float64
	if distance != 0 {
		iStep = float64((*TCoordIJK)(unsafe.Pointer(bp+12)).Fi-(*TCoordIJK)(unsafe.Pointer(bp)).Fi) / float64(distance)
	} else {
		iStep = float64(0)
	}
	var jStep float64
	if distance != 0 {
		jStep = float64((*TCoordIJK)(unsafe.Pointer(bp+12)).Fj-(*TCoordIJK)(unsafe.Pointer(bp)).Fj) / float64(distance)
	} else {
		jStep = float64(0)
	}
	var kStep float64
	if distance != 0 {
		kStep = float64((*TCoordIJK)(unsafe.Pointer(bp+12)).Fk-(*TCoordIJK)(unsafe.Pointer(bp)).Fk) / float64(distance)
	} else {
		kStep = float64(0)
	}

	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* currentIjk */)) = TCoordIJK{Fi: (*TCoordIJK)(unsafe.Pointer(bp /* &startIjk */)).Fi, Fj: (*TCoordIJK)(unsafe.Pointer(bp /* &startIjk */)).Fj, Fk: (*TCoordIJK)(unsafe.Pointer(bp /* &startIjk */)).Fk}
	{
		var n int32 = 0
	__1:
		if !(n <= distance) {
			goto __3
		}
		{
			cubeRound(tls, float64((*TCoordIJK)(unsafe.Pointer(bp)).Fi)+iStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp)).Fj)+jStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp)).Fk)+kStep*float64(n), bp+24)
			// Convert cube -> ijk -> h3 index
			XcubeToIjk(tls, bp+24)
			XlocalIjkToH3(tls, start, bp+24, out+uintptr(n)*8)

		}
		goto __2
	__2:
		n++
		goto __1
		goto __3
	__3:
	}

	return 0
}

// *
// _ipow does integer exponentiation efficiently. Taken from StackOverflow.
//
// @param base the integer base
// @param exp the integer exponent
//
// @return the exponentiated value
func X_ipow(tls *libc.TLS, base int32, exp int32) int32 { /* mathExtensions.c:30:5: */
	var result int32 = 1
	for exp != 0 {
		if exp&1 != 0 {
			result = result * base
		}
		exp >>= 1
		base = base * base
	}

	return result
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2017-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Define macros used in polygon algos for Geofence

// Copyright 2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file
// @brief Include file for poylgon algorithms. This includes the core
//        logic for algorithms acting over loops of coordinates,
//        allowing them to be reused for both Geofence and
//        LinkegGeoLoop structures. This file is intended to be
//        included inline in a file that defines the type-specific
//        macros required for iteration.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Declarations for math functions.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Copyright (C) 1998-2022 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2017-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Copyright 2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file polygon.h
// @brief Polygon algorithms

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideGeofence(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TGeoCoord)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TGeoCoord)(unsafe.Pointer(coord)).Flon < float64(0) {
			return (*TGeoCoord)(unsafe.Pointer(coord)).Flon + 6.28318530717958647692528676655900576839433
		}
		return (*TGeoCoord)(unsafe.Pointer(coord)).Flon
	}()
	var a TGeoCoord
	var b TGeoCoord

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeofence)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeofence)(unsafe.Pointer(loop)).FnumVerts)*16))

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flon < float64(0) {
				return a.Flon + 6.28318530717958647692528676655900576839433
			}
			return a.Flon
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flon < float64(0) {
				return b.Flon + 6.28318530717958647692528676655900576839433
			}
			return b.Flon
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
// - Does not support polygons with two adjacent points > 180 degrees of
//   longitude apart. These will be interpreted as crossing the antimeridian.
// - Does not currently support polygons containing a pole.
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromGeofence(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:137:6: */
	// Early exit if there are no vertices
	if (*TGeofence)(unsafe.Pointer(loop)).FnumVerts == 0 {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLon float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLon float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lon float64
	var coord TGeoCoord
	var next TGeoCoord

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeofence)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		coord = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		next = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeofence)(unsafe.Pointer(loop)).FnumVerts)*16))

		lat = coord.Flat
		lon = coord.Flon
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lon < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lon
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lon > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lon
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lon > float64(0) && lon < minPosLon {
			minPosLon = lon
		}
		if lon < float64(0) && lon > maxNegLon {
			maxNegLon = lon
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lon-next.Flon) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLon
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLon
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedGeofence(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:191:13: */
	var sum float64 = float64(0)
	var a TGeoCoord
	var b TGeoCoord

	var loopIndex int32 = -1
	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeofence)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TGeoCoord)(unsafe.Pointer((*TGeofence)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeofence)(unsafe.Pointer(loop)).FnumVerts)*16))
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flon-b.Flon) > 3.14159265358979323846 {
			return isClockwiseNormalizedGeofence(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flon < float64(0) {
				return b.Flon + 6.28318530717958647692528676655900576839433
			}
			return b.Flon
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flon < float64(0) {
				return a.Flon + 6.28318530717958647692528676655900576839433
			}
			return a.Flon
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseGeofence(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:219:6: */
	return isClockwiseNormalizedGeofence(tls, loop, uint8(Dfalse))
}

// *
// Create a bounding box from a GeoPolygon
// @param polygon Input GeoPolygon
// @param bboxes  Output bboxes, one for the outer loop and one for each hole
func XbboxesFromGeoPolygon(tls *libc.TLS, polygon uintptr, bboxes uintptr) { /* polygon.c:50:6: */
	XbboxFromGeofence(tls, polygon, bboxes)
	{
		var i int32 = 0
	__1:
		if !(i < (*TGeoPolygon)(unsafe.Pointer(polygon)).FnumHoles) {
			goto __3
		}
		{
			XbboxFromGeofence(tls, (*TGeoPolygon)(unsafe.Pointer(polygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// *
// pointInsidePolygon takes a given GeoPolygon data structure and
// checks if it contains a given geo coordinate.
//
// @param geoPolygon The geofence and holes defining the relevant area
// @param bboxes     The bboxes for the main geofence and each of its holes
// @param coord      The coordinate to check
// @return           Whether the point is contained
func XpointInsidePolygon(tls *libc.TLS, geoPolygon uintptr, bboxes uintptr, coord uintptr) uint8 { /* polygon.c:66:6: */
	// Start with contains state of primary geofence
	var contains uint8 = XpointInsideGeofence(tls, geoPolygon, bboxes, coord)

	// If the point is contained in the primary geofence, but there are holes in
	// the geofence iterate through all holes and return false if the point is
	// contained in any hole
	if contains != 0 && (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles > 0 {
		{
			var i int32 = 0
		__1:
			if !(i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles) {
				goto __3
			}
			{
				if XpointInsideGeofence(tls, (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32,
					coord) != 0 {
					return uint8(Dfalse)
				}

			}
			goto __2
		__2:
			i++
			goto __1
			goto __3
		__3:
		}
	}

	return contains
}

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Macros to control TS 18661-3 glibc features on ldbl-128 platforms.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// *
// Calculates the magnitude of a 2D cartesian vector.
// @param v The 2D cartesian vector.
// @return The magnitude of the vector.
func X_v2dMag(tls *libc.TLS, v uintptr) float64 { /* vec2d.c:30:8: */
	return libc.Xsqrt(tls, (*TVec2d)(unsafe.Pointer(v)).Fx*(*TVec2d)(unsafe.Pointer(v)).Fx+(*TVec2d)(unsafe.Pointer(v)).Fy*(*TVec2d)(unsafe.Pointer(v)).Fy)
}

// *
// Finds the intersection between two lines. Assumes that the lines intersect
// and that the intersection is not at an endpoint of either line.
// @param p0 The first endpoint of the first line.
// @param p1 The second endpoint of the first line.
// @param p2 The first endpoint of the second line.
// @param p3 The second endpoint of the second line.
// @param inter The intersection point.
func X_v2dIntersect(tls *libc.TLS, p0 uintptr, p1 uintptr, p2 uintptr, p3 uintptr, inter uintptr) { /* vec2d.c:41:6: */
	var s1 TVec2d
	var s2 TVec2d
	s1.Fx = (*TVec2d)(unsafe.Pointer(p1)).Fx - (*TVec2d)(unsafe.Pointer(p0)).Fx
	s1.Fy = (*TVec2d)(unsafe.Pointer(p1)).Fy - (*TVec2d)(unsafe.Pointer(p0)).Fy
	s2.Fx = (*TVec2d)(unsafe.Pointer(p3)).Fx - (*TVec2d)(unsafe.Pointer(p2)).Fx
	s2.Fy = (*TVec2d)(unsafe.Pointer(p3)).Fy - (*TVec2d)(unsafe.Pointer(p2)).Fy
	var t float32
	t = float32((s2.Fx*((*TVec2d)(unsafe.Pointer(p0)).Fy-(*TVec2d)(unsafe.Pointer(p2)).Fy) - s2.Fy*((*TVec2d)(unsafe.Pointer(p0)).Fx-(*TVec2d)(unsafe.Pointer(p2)).Fx)) / (-s2.Fx*s1.Fy + s1.Fx*s2.Fy))

	(*TVec2d)(unsafe.Pointer(inter)).Fx = (*TVec2d)(unsafe.Pointer(p0)).Fx + float64(t)*s1.Fx
	(*TVec2d)(unsafe.Pointer(inter)).Fy = (*TVec2d)(unsafe.Pointer(p0)).Fy + float64(t)*s1.Fy
}

// *
// Whether two 2D vectors are equal. Does not consider possible false
// negatives due to floating-point errors.
// @param v1 First vector to compare
// @param v2 Second vector to compare
// @return Whether the vectors are equal
func X_v2dEquals(tls *libc.TLS, v1 uintptr, v2 uintptr) uint8 { /* vec2d.c:64:6: */
	return uint8(libc.Bool32((*TVec2d)(unsafe.Pointer(v1)).Fx == (*TVec2d)(unsafe.Pointer(v2)).Fx && (*TVec2d)(unsafe.Pointer(v1)).Fy == (*TVec2d)(unsafe.Pointer(v2)).Fy))
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// *
// Square of a number
//
// @param x The input number.
// @return The square of the input number.
func X_square(tls *libc.TLS, x float64) float64 { /* vec3d.c:30:8: */
	return x * x
}

// *
// Calculate the square of the distance between two 3D coordinates.
//
// @param v1 The first 3D coordinate.
// @param v2 The second 3D coordinate.
// @return The square of the distance between the given points.
func X_pointSquareDist(tls *libc.TLS, v1 uintptr, v2 uintptr) float64 { /* vec3d.c:39:8: */
	return X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fx-(*TVec3d)(unsafe.Pointer(v2)).Fx) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fy-(*TVec3d)(unsafe.Pointer(v2)).Fy) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fz-(*TVec3d)(unsafe.Pointer(v2)).Fz)
}

// *
// Calculate the 3D coordinate on unit sphere from the latitude and longitude.
//
// @param geo The latitude and longitude of the point.
// @param v The 3D coordinate of the point.
func X_geoToVec3d(tls *libc.TLS, geo uintptr, v uintptr) { /* vec3d.c:50:6: */
	var r float64 = libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(geo)).Flat)

	(*TVec3d)(unsafe.Pointer(v)).Fz = libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(geo)).Flat)
	(*TVec3d)(unsafe.Pointer(v)).Fx = libc.Xcos(tls, (*TGeoCoord)(unsafe.Pointer(geo)).Flon) * r
	(*TVec3d)(unsafe.Pointer(v)).Fy = libc.Xsin(tls, (*TGeoCoord)(unsafe.Pointer(geo)).Flon) * r
}

// Copyright 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lon.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

// * @brief Table of direction-to-face mapping for each pentagon
//
// Note that faces are in directional order, starting at J_AXES_DIGIT.
// This table is generated by the generatePentagonDirectionFaces script.
var pentagonDirectionFaces = [12]TPentagonDirectionFaces{
	{FbaseCell: 4, Ffaces: [5]int32{4, 0, 2, 1, 3}}, {FbaseCell: 14, Ffaces: [5]int32{6, 11, 2, 7, 1}},
	{FbaseCell: 24, Ffaces: [5]int32{5, 10, 1, 6, 0}}, {FbaseCell: 38, Ffaces: [5]int32{7, 12, 3, 8, 2}},
	{FbaseCell: 49, Ffaces: [5]int32{9, 14, 0, 5, 4}}, {FbaseCell: 58, Ffaces: [5]int32{8, 13, 4, 9, 3}},
	{FbaseCell: 63, Ffaces: [5]int32{11, 6, 15, 10, 16}}, {FbaseCell: 72, Ffaces: [5]int32{12, 7, 16, 11, 17}},
	{FbaseCell: 83, Ffaces: [5]int32{10, 5, 19, 14, 15}}, {FbaseCell: 97, Ffaces: [5]int32{13, 8, 17, 12, 18}},
	{FbaseCell: 107, Ffaces: [5]int32{14, 9, 18, 13, 19}}, {FbaseCell: 117, Ffaces: [5]int32{15, 19, 17, 18, 16}},
} /* vertex.c:34:37 */

// *
// Get the number of CCW rotations of the cell's vertex numbers
// compared to the directional layout of its neighbors.
// @return Number of CCW rotations for the cell
func XvertexRotations(tls *libc.TLS, cell TH3Index) int32 { /* vertex.c:48:5: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// Get the face and other info for the origin
	// var fijk TFaceIJK at bp, 16

	X_h3ToFaceIjk(tls, cell, bp)
	var baseCell int32 = Xh3GetBaseCell(tls, cell)
	var cellLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, cell))

	// get the base cell face
	// var baseFijk TFaceIJK at bp+16, 16

	X_baseCellToFaceIjk(tls, baseCell, bp+16)

	var ccwRot60 int32 = X_baseCellToCCWrot60(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp /* &fijk */)).Fface)

	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// Find the appropriate direction-to-face mapping
		// var dirFaces TPentagonDirectionFaces at bp+32, 24

		{
			var p int32 = 0
		__1:
			if !(p < DNUM_PENTAGONS) {
				goto __3
			}
			{
				if pentagonDirectionFaces[p].FbaseCell == baseCell {
					*(*TPentagonDirectionFaces)(unsafe.Pointer(bp + 32 /* dirFaces */)) = pentagonDirectionFaces[p]
					goto __3
				}

			}
			goto __2
		__2:
			p++
			goto __1
			goto __3
		__3:
		}

		// additional CCW rotation for polar neighbors or IK neighbors
		if (*TFaceIJK)(unsafe.Pointer(bp)).Fface != (*TFaceIJK)(unsafe.Pointer(bp+16)).Fface && (X_isBaseCellPolarPentagon(tls, baseCell) != 0 || (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4))) {
			ccwRot60 = (ccwRot60 + 1) % 6
		}

		// Check whether the cell crosses a deleted pentagon subsequence
		if cellLeadingDigit == JK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4)) {
			// Crosses from JK to IK: Rotate CW
			ccwRot60 = (ccwRot60 + 5) % 6
		} else if cellLeadingDigit == IK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 1*4)) {
			// Crosses from IK to JK: Rotate CCW
			ccwRot60 = (ccwRot60 + 1) % 6
		}
	}
	return ccwRot60
}

// * @brief Hexagon direction to vertex number relationships (same face).
//         Note that we don't use direction 0 (center).
var directionToVertexNumHex = [7]int32{
	INVALID_DIGIT, 3, 1, 2, 5, 4, 0} /* vertex.c:98:18 */

// * @brief Pentagon direction to vertex number relationships (same face).
//         Note that we don't use directions 0 (center) or 1 (deleted K axis).
var directionToVertexNumPent = [7]int32{
	INVALID_DIGIT, INVALID_DIGIT, 1, 2, 4, 3, 0} /* vertex.c:104:18 */

// *
// Get the first vertex number for a given direction. The neighbor in this
// direction is located between this vertex number and the next number in
// sequence.
// @returns The number for the first topological vertex, or INVALID_VERTEX_NUM
//          if the direction is not valid for this cell
func XvertexNumForDirection(tls *libc.TLS, origin TH3Index, direction TDirection) int32 { /* vertex.c:114:5: */
	var isPentagon int32 = Xh3IsPentagon(tls, origin)
	// Check for invalid directions
	if direction == CENTER_DIGIT || direction >= INVALID_DIGIT || isPentagon != 0 && direction == K_AXES_DIGIT {
		return -1
	}

	// Determine the vertex rotations for this cell
	var rotations int32 = XvertexRotations(tls, origin)

	// Find the appropriate vertex, rotating CCW if necessary
	if isPentagon != 0 {
		return (directionToVertexNumPent[direction] + DNUM_PENT_VERTS - rotations) % DNUM_PENT_VERTS
	} else {
		return (directionToVertexNumHex[direction] + DNUM_HEX_VERTS - rotations) % DNUM_HEX_VERTS
	}
	return int32(0)
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file geoCoord.h
// @brief   Geodetic (lat/lon) functions.

// *
// Initialize a new VertexGraph
// @param graph       Graph to initialize
// @param  numBuckets Number of buckets to include in the graph
// @param  res        Resolution of the hexagons whose vertices we're storing
func XinitVertexGraph(tls *libc.TLS, graph uintptr, numBuckets int32, res int32) { /* vertexGraph.c:37:6: */
	if numBuckets > 0 {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = libc.Xcalloc(tls, uint64(numBuckets), uint64(unsafe.Sizeof(uintptr(0))))
		if (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets != uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+854, ts+877, uint32(40), uintptr(unsafe.Pointer(&__func__11)))
		}
	} else {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = uintptr(0)
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets = numBuckets
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize = 0
	(*TVertexGraph)(unsafe.Pointer(graph)).Fres = res
}

var __func__11 = *(*[16]uint8)(unsafe.Pointer(ts + 908)) /* vertexGraph.c:37:67 */

// *
// Destroy a VertexGraph's sub-objects, freeing their memory. The caller is
// responsible for freeing memory allocated to the VertexGraph struct itself.
// @param graph Graph to destroy
func XdestroyVertexGraph(tls *libc.TLS, graph uintptr) { /* vertexGraph.c:54:6: */
	var node uintptr
	for libc.AssignUintptr(&node, XfirstVertexNode(tls, graph)) != uintptr(0) {
		XremoveVertexNode(tls, graph, node)
	}
	libc.Xfree(tls, (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets)
}

// *
// Get an integer hash for a lat/lon point, at a precision determined
// by the current hexagon resolution.
// TODO: Light testing suggests this might not be sufficient at resolutions
// finer than 10. Design a better hash function if performance and collisions
// seem to be an issue here.
// @param  vertex     Lat/lon vertex to hash
// @param  res        Resolution of the hexagon the vertex belongs to
// @param  numBuckets Number of buckets in the graph
// @return            Integer hash
func X_hashVertex(tls *libc.TLS, vertex uintptr, res int32, numBuckets int32) Tuint32_t { /* vertexGraph.c:73:10: */
	// Simple hash: Take the sum of the lat and lon with a precision level
	// determined by the resolution, converted to int, modulo bucket count.
	return libc.Uint32FromFloat64(libc.Xfmod(tls, libc.Xfabs(tls, ((*TGeoCoord)(unsafe.Pointer(vertex)).Flat+(*TGeoCoord)(unsafe.Pointer(vertex)).Flon)*libc.Xpow(tls, float64(10), float64(15-res))),
		float64(numBuckets)))
}

func X_initVertexNode(tls *libc.TLS, node uintptr, fromVtx uintptr, toVtx uintptr) { /* vertexGraph.c:80:6: */
	(*TVertexNode)(unsafe.Pointer(node)).Ffrom = *(*TGeoCoord)(unsafe.Pointer(fromVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fto = *(*TGeoCoord)(unsafe.Pointer(toVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fnext = uintptr(0)
}

// *
// Add a edge to the graph
// @param graph   Graph to add node to
// @param fromVtx Start vertex
// @param toVtx   End vertex
// @return        Pointer to the new node
func XaddVertexNode(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:94:11: */
	// Make the new node
	var node uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TVertexNode{})))
	if node != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+924, ts+877, uint32(98), uintptr(unsafe.Pointer(&__func__12)))
	}
	X_initVertexNode(tls, node, fromVtx, toVtx)
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if currentNode == uintptr(0) {
		// Set bucket to the new node
		*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = node
	} else {
		// Find the end of the list
		for __ccgo := true; __ccgo; __ccgo = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			// Check the the edge we're adding doesn't already exist
			if XgeoAlmostEqual(tls, currentNode, fromVtx) != 0 && XgeoAlmostEqual(tls, currentNode+16, toVtx) != 0 {
				// already exists, bail
				libc.Xfree(tls, node)
				return currentNode
			}
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
				currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
			}
		}
		// Add the new node to the end of the list
		(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = node
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize++
	return node
}

var __func__12 = *(*[14]uint8)(unsafe.Pointer(ts + 937)) /* vertexGraph.c:95:50 */

// *
// Remove a node from the graph. The input node will be freed, and should
// not be used after removal.
// @param graph Graph to mutate
// @param node  Node to remove
// @return      0 on success, 1 on failure (node not found)
func XremoveVertexNode(tls *libc.TLS, graph uintptr, node uintptr) int32 { /* vertexGraph.c:135:5: */
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, node, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	var found int32 = 0
	if currentNode != uintptr(0) {
		if currentNode == node {
			*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = (*TVertexNode)(unsafe.Pointer(node)).Fnext
			found = 1
		}
		// Look through the list
		for !(found != 0) && (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext == node {
				// splice the node out
				(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = (*TVertexNode)(unsafe.Pointer(node)).Fnext
				found = 1
			}
			currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
		}
	}
	if found != 0 {
		libc.Xfree(tls, node)
		(*TVertexGraph)(unsafe.Pointer(graph)).Fsize--
		return 0
	}
	// Failed to find the node
	return 1
}

// *
// Find the Vertex node for a given edge, if it exists
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @param  toVtx   End vertex, or NULL if we don't care
// @return         Pointer to the vertex node, if found
func XfindNodeForEdge(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:171:11: */
	// Determine location
	var index Tuint32_t = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var node uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if node != uintptr(0) {
		// Look through the list and see if we find the edge
		for __ccgo := true; __ccgo; __ccgo = node != uintptr(0) {
			if XgeoAlmostEqual(tls, node, fromVtx) != 0 && (toVtx == uintptr(0) || XgeoAlmostEqual(tls, node+16, toVtx) != 0) {
				return node
			}
			node = (*TVertexNode)(unsafe.Pointer(node)).Fnext
		}
	}
	// Iteration lookup fail
	return uintptr(0)
}

// *
// Find a Vertex node starting at the given vertex
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @return         Pointer to the vertex node, if found
func XfindNodeForVertex(tls *libc.TLS, graph uintptr, fromVtx uintptr) uintptr { /* vertexGraph.c:197:11: */
	return XfindNodeForEdge(tls, graph, fromVtx, uintptr(0))
}

// *
// Get the next vertex node in the graph.
// @param  graph Graph to iterate
// @return       Vertex node, or NULL if at the end
func XfirstVertexNode(tls *libc.TLS, graph uintptr) uintptr { /* vertexGraph.c:207:11: */
	var node uintptr = uintptr(0)
	var currentIndex int32 = 0
	for node == uintptr(0) {
		if currentIndex < (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets {
			// find the first node in the next bucket
			node = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(currentIndex)*8))
		} else {
			// end of iteration
			return uintptr(0)
		}
		currentIndex++
	}
	return node
}

var ts1 = "bboxes != NULL\x00../src/h3lib/lib/algos.c\x00_polyfillInternal\x00adjacentFaceDir[tmpFijk.face][fijk.face] == KI\x00../src/h3lib/lib/faceijk.c\x00_faceIjkPentToGeoBoundary\x00adjacentFaceDir[centerIJK.face][face2] == KI\x00_faceIjkToGeoBoundary\x00%lx\x00polygon->next == NULL\x00../src/h3lib/lib/linkedGeo.c\x00next != NULL\x00addNewLinkedPolygon\x00loop != NULL\x00addNewLinkedLoop\x00polygon->first == NULL\x00addLinkedLoop\x00coord != NULL\x00loop->first == NULL\x00addLinkedCoord\x00candidates != NULL\x00candidateBBoxes != NULL\x00findPolygonForHole\x00innerLoops != NULL\x00normalizeMultiPolygon\x00revDir != INVALID_DIGIT\x00../src/h3lib/lib/localij.c\x00baseCell != originBaseCell\x00!(originOnPent && indexOnPent)\x00pentagonRotations >= 0\x00directionRotations >= 0\x00baseCell == originBaseCell\x00h3ToLocalIjk\x00baseCell != INVALID_BASE_CELL\x00!_isBaseCellPentagon(baseCell)\x00baseCellRotations >= 0\x00withinPentagonRotations >= 0\x00localIjkToH3\x00graph->buckets != NULL\x00../src/h3lib/lib/vertexGraph.c\x00initVertexGraph\x00node != NULL\x00addVertexNode\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
